
 <!DOCTYPE HTML>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  
    <title>java 线程池 | ♀紫☆恋&amp;流★雪♂</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="Losileeya">
    

    
    <meta name="description" content="线程池：基本思想还是一种对象池的思想，开辟一块内存空间，里面存放了众多(未死亡)的线程，池中线程执行调度由池管理器来处理。当有线程任务时，从池中取一个，执行完成后线程对象归池，这样可以避免反复创建线程对象所带来的性能开销，节省了系统的资源。
ExecutorService通过上述分析，我们知道了通过new Thread().start()方式创建线程去处理任务的弊端，而为了解决这些问题，Java为">
<meta property="og:type" content="article">
<meta property="og:title" content="java 线程池">
<meta property="og:url" content="http://zilianliuxue.github.io/2016/08/25/java线程池/index.html">
<meta property="og:site_name" content="♀紫☆恋&流★雪♂">
<meta property="og:description" content="线程池：基本思想还是一种对象池的思想，开辟一块内存空间，里面存放了众多(未死亡)的线程，池中线程执行调度由池管理器来处理。当有线程任务时，从池中取一个，执行完成后线程对象归池，这样可以避免反复创建线程对象所带来的性能开销，节省了系统的资源。
ExecutorService通过上述分析，我们知道了通过new Thread().start()方式创建线程去处理任务的弊端，而为了解决这些问题，Java为">
<meta property="og:image" content="http://img.blog.csdn.net/20151116182357008">
<meta property="og:image" content="http://img.blog.csdn.net/20151116182627850">
<meta property="og:image" content="http://img.blog.csdn.net/20151116184528454">
<meta property="og:image" content="http://img.blog.csdn.net/20151116194526184">
<meta property="og:image" content="http://img.blog.csdn.net/20151116212159326">
<meta property="og:image" content="http://img.blog.csdn.net/20151117141139792">
<meta property="og:image" content="http://img.blog.csdn.net/20151117141553421">
<meta property="og:image" content="http://img.blog.csdn.net/20151117144914201">
<meta property="og:updated_time" content="2016-08-26T06:36:04.716Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="java 线程池">
<meta name="twitter:description" content="线程池：基本思想还是一种对象池的思想，开辟一块内存空间，里面存放了众多(未死亡)的线程，池中线程执行调度由池管理器来处理。当有线程任务时，从池中取一个，执行完成后线程对象归池，这样可以避免反复创建线程对象所带来的性能开销，节省了系统的资源。
ExecutorService通过上述分析，我们知道了通过new Thread().start()方式创建线程去处理任务的弊端，而为了解决这些问题，Java为">
<meta name="twitter:image" content="http://img.blog.csdn.net/20151116182357008">

    
    <link rel="alternative" href="/atom.xml" title="♀紫☆恋&amp;流★雪♂" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
    
	
    <form class="search" action="/search/index.html" method="get" accept-charset="utf-8">
	<label>Search</label>
	<input type="text" id="search" class="st-default-search-input" maxlength="20" placeholder="Search" />
	</form>
    
    <link rel="stylesheet" href="/css/style.css">
	
</head>

  <body>
    <header>
      
<div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.gif" alt="♀紫☆恋&amp;流★雪♂" title="♀紫☆恋&amp;流★雪♂"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="♀紫☆恋&amp;流★雪♂">♀紫☆恋&amp;流★雪♂</a></h1>
				<h2 class="blog-motto">编程中我们会遇到多少挫折？不放弃，沙漠尽头必是绿洲，不是天方夜谭</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">Home</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
						<li><a href="/about">About</a></li>
					
						<li><a href="/categories">分类</a></li>
					
					<li>
 					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="search" />
						<input type="hidden" name="q" value="site:zilianliuxue.github.io">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
  
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/08/25/java线程池/" title="java 线程池" itemprop="url">java 线程池</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Losileeya" target="_blank" itemprop="author">Losileeya</a>
		
  <p class="article-time">
    <time datetime="2016-08-25T12:30:16.351Z" itemprop="datePublished"> 发表于 2016-08-25</time>
   <span id="busuanzi_container_page_pv">
    总阅读<span id="busuanzi_value_page_pv"></span>次
   </span>
  </p>
</header>
	<div class="article-content">
		
		<div id="toc" class="toc-article">
			<strong class="toc-title">文章目录</strong>
		
			<ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#ExecutorService"><span class="toc-number">1.</span> <span class="toc-text">ExecutorService</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#使用线程池管理线程的优点"><span class="toc-number">1.1.</span> <span class="toc-text">使用线程池管理线程的优点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ExecutorService简介"><span class="toc-number">1.2.</span> <span class="toc-text">ExecutorService简介</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#线程池：ThreadPoolExecutor"><span class="toc-number">1.2.1.</span> <span class="toc-text">线程池：ThreadPoolExecutor</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#再撸一撸概念"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">再撸一撸概念</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#线程池ThreadPoolExecutor的使用"><span class="toc-number">1.3.</span> <span class="toc-text">线程池ThreadPoolExecutor的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#自定义线程池ThreadPoolExecutor"><span class="toc-number">1.3.1.</span> <span class="toc-text">自定义线程池ThreadPoolExecutor</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1、首先我们创建一个基于PriorityBlockingQueue实现的线程池，为了测试方便，我这里把核心线程数量设置为3，如下："><span class="toc-number">1.3.1.1.</span> <span class="toc-text">1、首先我们创建一个基于PriorityBlockingQueue实现的线程池，为了测试方便，我这里把核心线程数量设置为3，如下：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2、然后创建一个实现Runnable接口的类，并向外提供一个抽象方法供我们实现自定义功能，并实现Comparable接口，实现这个接口主要就是进行优先级的比较，代码如下："><span class="toc-number">1.3.1.2.</span> <span class="toc-text">2、然后创建一个实现Runnable接口的类，并向外提供一个抽象方法供我们实现自定义功能，并实现Comparable接口，实现这个接口主要就是进行优先级的比较，代码如下：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3、使用我们自己的PriorityRunnable提交任务，整体代码如下："><span class="toc-number">1.3.1.3.</span> <span class="toc-text">3、使用我们自己的PriorityRunnable提交任务，整体代码如下：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#测试效果"><span class="toc-number">1.3.1.4.</span> <span class="toc-text">测试效果</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#优先级线程池的优点"><span class="toc-number">1.3.1.5.</span> <span class="toc-text">优先级线程池的优点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#扩展线程池ThreadPoolExecutor"><span class="toc-number">1.3.2.</span> <span class="toc-text">扩展线程池ThreadPoolExecutor</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#优化线程池ThreadPoolExecutor"><span class="toc-number">1.3.3.</span> <span class="toc-text">优化线程池ThreadPoolExecutor</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#shutdown-和shutdownNow-的区别"><span class="toc-number">1.3.4.</span> <span class="toc-text">shutdown()和shutdownNow()的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#关于AsyncTask的实现"><span class="toc-number">1.3.5.</span> <span class="toc-text">关于AsyncTask的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#面试题"><span class="toc-number">1.3.5.1.</span> <span class="toc-text">面试题</span></a></li></ol></li></ol></li></ol></li></ol>
		
		</div>
		
		<p>线程池：基本思想还是一种对象池的思想，开辟一块内存空间，里面存放了众多(未死亡)的线程，池中线程执行调度由池管理器来处理。当有线程任务时，从池中取一个，执行完成后线程对象归池，这样可以避免反复创建线程对象所带来的性能开销，节省了系统的资源。</p>
<h1 id="ExecutorService"><a href="#ExecutorService" class="headerlink" title="ExecutorService"></a><strong>ExecutorService</strong></h1><p>通过上述分析，我们知道了通过new Thread().start()方式创建线程去处理任务的弊端，而为了解决这些问题，Java为我们提供了ExecutorService线程池来优化和管理线程的使用</p>
<h2 id="使用线程池管理线程的优点"><a href="#使用线程池管理线程的优点" class="headerlink" title="使用线程池管理线程的优点"></a><strong>使用线程池管理线程的优点</strong></h2><blockquote>
<p>1、线程的创建和销毁由线程池维护，一个线程在完成任务后并不会立即销毁，而是由后续的任务复用这个线程，从而减少线程的创建和销毁，节约系统的开销</p>
<p>2、线程池旨在线程的复用，这就可以节约我们用以往的方式创建线程和销毁所消耗的时间，减少线程频繁调度的开销，从而节约系统资源，提高系统吞吐量</p>
<p>3、在执行大量异步任务时提高了性能</p>
<p>4、Java内置的一套ExecutorService线程池相关的api，可以更方便的控制线程的最大并发数、线程的定时任务、单线程的顺序执行等</p>
</blockquote>
<h2 id="ExecutorService简介"><a href="#ExecutorService简介" class="headerlink" title="ExecutorService简介"></a><strong>ExecutorService简介</strong></h2><p>通常来说我们说到线程池第一时间想到的就是它：ExecutorService，它是一个接口，其实如果要从真正意义上来说，它可以叫做线程池的服务，因为它提供了众多接口api来控制线程池中的线程，而真正意义上的线程池就是：ThreadPoolExecutor，它实现了ExecutorService接口，并封装了一系列的api使得它具有线程池的特性，其中包括工作队列、核心线程数、最大线程数等。</p>
<h3 id="线程池：ThreadPoolExecutor"><a href="#线程池：ThreadPoolExecutor" class="headerlink" title="线程池：ThreadPoolExecutor"></a><strong>线程池：ThreadPoolExecutor</strong></h3><p>既然线程池就是ThreadPoolExecutor，所以我们要创建一个线程池只需要new ThreadPoolExecutor(…);就可以创建一个线程池，而如果这样创建线程池的话，我们需要配置一堆东西，非常麻烦，我们可以看一下它的构造方法就知道了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public ThreadPoolExecutor(int corePoolSize,</div><div class="line">                              int maximumPoolSize,</div><div class="line">                              long keepAliveTime,</div><div class="line">                              TimeUnit unit,</div><div class="line">                              BlockingQueue&lt;Runnable&gt; workQueue,</div><div class="line">                              ThreadFactory threadFactory,</div><div class="line">                              RejectedExecutionHandler handler) &#123;...&#125;1234567</div></pre></td></tr></table></figure>
<p>所以，官方也不推荐使用这种方法来创建线程池，而是推荐使用<strong>Executors</strong>的工厂方法来创建线程池，<strong>Executors</strong>类是官方提供的一个工厂类，它里面封装好了众多功能不一样的线程池，从而使得我们创建线程池非常的简便，主要提供了如下五种功能不一样的线程池：</p>
<blockquote>
<p><strong>1、newFixedThreadPool() ：</strong><br>作用：该方法返回一个固定线程数量的线程池，该线程池中的线程数量始终不变，即不会再创建新的线程，也不会销毁已经创建好的线程，自始自终都是那几个固定的线程在工作，所以该线程池可以控制线程的最大并发数。<br>栗子：假如有一个新任务提交时，线程池中如果有空闲的线程则立即使用空闲线程来处理任务，如果没有，则会把这个新任务存在一个任务队列中，一旦有线程空闲了，则按FIFO方式处理任务队列中的任务。</p>
<p><strong>2、newCachedThreadPool() ：</strong><br>作用：该方法返回一个可以根据实际情况调整线程池中线程的数量的线程池。即该线程池中的线程数量不确定，是根据实际情况动态调整的。<br>栗子：假如该线程池中的所有线程都正在工作，而此时有新任务提交，那么将会创建新的线程去处理该任务，而此时假如之前有一些线程完成了任务，现在又有新任务提交，那么将不会创建新线程去处理，而是复用空闲的线程去处理新任务。那么此时有人有疑问了，那这样来说该线程池的线程岂不是会越集越多？其实并不会，因为线程池中的线程都有一个“保持活动时间”的参数，通过配置它，如果线程池中的空闲线程的空闲时间超过该“保存活动时间”则立刻停止该线程，而该线程池默认的“保持活动时间”为60s。</p>
<p><strong>3、newSingleThreadExecutor() ：</strong><br>作用：该方法返回一个只有一个线程的线程池，即每次只能执行一个线程任务，多余的任务会保存到一个任务队列中，等待这一个线程空闲，当这个线程空闲了再按FIFO方式顺序执行任务队列中的任务。</p>
<p><strong>4、newScheduledThreadPool() ：</strong><br>作用：该方法返回一个可以控制线程池内线程定时或周期性执行某任务的线程池。</p>
<p><strong>5、newSingleThreadScheduledExecutor() ：</strong><br>作用：该方法返回一个可以控制线程池内线程定时或周期性执行某任务的线程池。只不过和上面的区别是该线程池大小为1，而上面的可以指定线程池的大小。</p>
</blockquote>
<p>好了，写了一堆来介绍这五种线程池的作用，接下来就是获取这五种线程池，通过<strong>Executors</strong>的工厂方法来获取：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ExecutorService fixedThreadPool = Executors.newFixedThreadPool(5);</div><div class="line">ExecutorService singleThreadPool = Executors.newSingleThreadExecutor();</div><div class="line">ExecutorService cachedThreadPool = Executors.newCachedThreadPool();</div><div class="line">ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(5);</div><div class="line">ScheduledExecutorService singleThreadScheduledPool = Executors.newSingleThreadScheduledExecutor();12345</div></pre></td></tr></table></figure>
<p>Executors 提供四种线程池：</p>
<ul>
<li>1）newCachedThreadPool 是一个可根据需要创建新线程的线程池，但是在以前构造的线程可用时将重用它们。对于执行很多短期异步任务的程序而言，这些线程池通常可提高程序性能。调用 execute() 将重用以前构造的线程（如果线程可用）。如果现有线程没有可用的，则创建一个新线程并添加到池中。终止并从缓存中移除那些已有 60 秒钟未被使用的线程。因此，长时间保持空闲的线程池不会使用任何资源。注意，可以使用 ThreadPoolExecutor 构造方法创建具有类似属性但细节不同（例如超时参数）的线程池。</li>
<li>2）newSingleThreadExecutor 创建是一个单线程池，也就是该线程池只有一个线程在工作，所有的任务是串行执行的，如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它，此线程池保证所有任务的执行顺序按照任务的提交顺序执行。</li>
<li>3）newFixedThreadPool 创建固定大小的线程池，每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小，线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。</li>
<li>4）newScheduledThreadPool 创建一个大小无限的线程池，此线程池支持定时以及周期性执行任务的需求。</li>
</ul>
<p>我们可以看到通过<strong>Executors</strong>的工厂方法来创建线程池极其简便，其实它的内部还是通过new ThreadPoolExecutor(…)的方式创建线程池的，我们看一下这些工厂方法的内部实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public static ExecutorService newFixedThreadPool(int nThreads) &#123;</div><div class="line">    return new ThreadPoolExecutor(nThreads, nThreads,</div><div class="line">                                  0L, TimeUnit.MILLISECONDS,</div><div class="line">                                  new LinkedBlockingQueue&lt;Runnable&gt;());</div><div class="line">&#125;</div><div class="line">public static ExecutorService newSingleThreadExecutor() &#123;</div><div class="line">    return new FinalizableDelegatedExecutorService</div><div class="line">        (new ThreadPoolExecutor(1, 1,</div><div class="line">                                0L, TimeUnit.MILLISECONDS,</div><div class="line">                                new LinkedBlockingQueue&lt;Runnable&gt;()));</div><div class="line">&#125;</div><div class="line">public static ExecutorService newCachedThreadPool() &#123;</div><div class="line">    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,</div><div class="line">                                  60L, TimeUnit.SECONDS,</div><div class="line">                                  new SynchronousQueue&lt;Runnable&gt;());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们可以清楚的看到这些方法的内部实现都是通过创建一个ThreadPoolExecutor对象来创建的，正所谓万变不离其宗，所以我们要了解线程池还是得了解ThreadPoolExecutor这个线程池类，其中由于和定时任务相关的线程池比较特殊（newScheduledThreadPool()、newSingleThreadScheduledExecutor()），它们创建的线程池内部实现是由ScheduledThreadPoolExecutor这个类实现的，而ScheduledThreadPoolExecutor是继承于ThreadPoolExecutor扩展而成的，所以本质还是一样的，只不过多封装了一些定时任务相关的api</p>
<h4 id="再撸一撸概念"><a href="#再撸一撸概念" class="headerlink" title="再撸一撸概念"></a>再撸一撸概念</h4><p>Java里面线程池的顶级接口是 Executor，不过真正的线程池接口是 ExecutorService， ExecutorService 的默认实现是 ThreadPoolExecutor；普通类 Executors 里面调用的就是 ThreadPoolExecutor。</p>
<p>照例看一下各个接口的源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">public interface Executor &#123;</div><div class="line">	void execute(Runnable command);</div><div class="line">&#125;</div><div class="line"></div><div class="line">public interface ExecutorService extends Executor &#123;</div><div class="line">	void shutdown();</div><div class="line">	List&lt;Runnable&gt; shutdownNow();</div><div class="line">	</div><div class="line">	boolean isShutdown();</div><div class="line">	boolean isTerminated();</div><div class="line">	</div><div class="line">	&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task);</div><div class="line">	&lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result);</div><div class="line">	Future&lt;?&gt; submit(Runnable task);</div><div class="line">	...</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Executors &#123;</div><div class="line">	public static ExecutorService newCachedThreadPool() &#123;</div><div class="line">    		return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, </div><div class="line">    						new SynchronousQueue&lt;Runnable&gt;());</div><div class="line">	&#125;</div><div class="line">	...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面我创建的一个线程池：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ExecutorService pool = Executors.newCachedThreadPool();</div></pre></td></tr></table></figure>
<p>通过 ThreadPoolExecutor 的构造函数，撸一撸线程池相关参数的概念：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public ThreadPoolExecutor(int corePoolSize,</div><div class="line">                          int maximumPoolSize,</div><div class="line">                          long keepAliveTime,</div><div class="line">                          TimeUnit unit,</div><div class="line">                          BlockingQueue&lt;Runnable&gt; workQueue,</div><div class="line">                          ThreadFactory threadFactory) &#123;</div><div class="line">    this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, </div><div class="line">    	threadFactory, defaultHandler);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>1）corePoolSize：线程池的核心线程数，一般情况下不管有没有任务都会一直在线程池中一直存活，只有在 ThreadPoolExecutor 中的方法 allowCoreThreadTimeOut(boolean value) 设置为 true 时，闲置的核心线程会存在超时机制，如果在指定时间没有新任务来时，核心线程也会被终止，而这个时间间隔由第3个属性 keepAliveTime 指定。</li>
<li>2）maximumPoolSize：线程池所能容纳的最大线程数，当活动的线程数达到这个值后，后续的新任务将会被阻塞。</li>
<li>3）keepAliveTime：控制线程闲置时的超时时长，超过则终止该线程。一般情况下用于非核心线程，只有在 ThreadPoolExecutor 中的方法 allowCoreThreadTimeOut(boolean value) 设置为 true时，也作用于核心线程。</li>
<li>4）unit：用于指定 keepAliveTime 参数的时间单位，TimeUnit 是个 enum 枚举类型，常用的有：TimeUnit.HOURS(小时)、TimeUnit.MINUTES(分钟)、TimeUnit.SECONDS(秒) 和 TimeUnit.MILLISECONDS(毫秒)等。</li>
<li>5）workQueue：线程池的任务队列，通过线程池的 execute(Runnable command) 方法会将任务 Runnable 存储在队列中。</li>
<li>6）threadFactory：线程工厂，它是一个接口，用来为线程池创建新线程的。<br>上面的参数理解起来都比较简单，不过workQueue这个任务队列却要再次说明一下，它是一个<code>BlockingQueue</code>对象，而泛型则限定它是用来存放Runnable对象的，刚刚上面讲了，不同的线程池它的任务队列实现肯定是不一样的，所以，保证不同线程池有着不同的功能的核心就是这个workQueue的实现了，细心的会发现在刚刚的用来创建线程池的工厂方法中，针对不同的线程池传入的workQueue也不一样，下面我总结一下这五种线程池分别用的是什么BlockingQueue：</li>
</ul>
<blockquote>
<p>1、newFixedThreadPool()—&gt;LinkedBlockingQueue<br>2、newSingleThreadExecutor()—&gt;LinkedBlockingQueue<br>3、newCachedThreadPool()—&gt;SynchronousQueue<br>4、newScheduledThreadPool()—&gt;DelayedWorkQueue<br>5、newSingleThreadScheduledExecutor()—&gt;DelayedWorkQueue</p>
</blockquote>
<p>这些队列分别表示：</p>
<blockquote>
<p><strong>LinkedBlockingQueue</strong>：无界的队列<br><strong>SynchronousQueue</strong>：直接提交的队列<br><strong>DelayedWorkQueue</strong>：等待队列</p>
</blockquote>
<p>当然实现了BlockingQueue接口的队列还有：ArrayBlockingQueue（有界的队列）、PriorityBlockingQueue（优先级队列）。这些队列的详细作用就不多介绍了。</p>
<p>线程池的关闭</p>
<p>ThreadPoolExecutor 提供了两个方法，用于线程池的关闭，分别是 shutdown() 和 shutdownNow()。</p>
<p>shutdown()：不会立即的终止线程池，而是要等所有任务缓存队列中的任务都执行完后才终止，但再也不会接受新的任务。<br>shutdownNow()：立即终止线程池，并尝试打断正在执行的任务，并且清空任务缓存队列，返回尚未执行的任务。</p>
<h2 id="线程池ThreadPoolExecutor的使用"><a href="#线程池ThreadPoolExecutor的使用" class="headerlink" title="线程池ThreadPoolExecutor的使用"></a><strong>线程池ThreadPoolExecutor的使用</strong></h2><p>使用线程池，其中涉及到一个极其重要的方法，即：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">execute(Runnable command)</div></pre></td></tr></table></figure>
<p>该方法意为执行给定的任务，该任务处理可能在新的线程、已入池的线程或者正调用的线程，这由ThreadPoolExecutor的实现决定。<br><strong>newFixedThreadPool</strong><br>创建一个固定线程数量的线程池，示例为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">ExecutorService fixedThreadPool = Executors.newFixedThreadPool(3);</div><div class="line">for (int i = 1; i &lt;= 10; i++) &#123;</div><div class="line">    final int index = i;</div><div class="line">    fixedThreadPool.execute(new Runnable() &#123;</div><div class="line">         @Override</div><div class="line">         public void run() &#123;</div><div class="line">             String threadName = Thread.currentThread().getName();</div><div class="line">             Log.v(&quot;zxy&quot;, &quot;线程：&quot;+threadName+&quot;,正在执行第&quot; + index + &quot;个任务&quot;);</div><div class="line">             try &#123;</div><div class="line">                    Thread.sleep(2000);</div><div class="line">             &#125; catch (InterruptedException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">             &#125;</div><div class="line">         &#125;</div><div class="line">     &#125;);</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>上述代码，我们创建了一个线程数为3的固定线程数量的线程池，同理该线程池支持的线程最大并发数也是3，而我模拟了10个任务让它处理，执行的情况则是首先执行前三个任务，后面7个则依次进入任务队列进行等待，执行完前三个任务后，再通过FIFO的方式从任务队列中取任务执行，直到最后任务都执行完毕。<br>为了体现出线程的复用，我特地在Log中加上了当前线程的名称，效果为：<br><img src="http://img.blog.csdn.net/20151116182357008" alt="这里写图片描述"><br><strong>newSingleThreadExecutor</strong><br>创建一个只有一个线程的线程池，每次只能执行一个线程任务，多余的任务会保存到一个任务队列中，等待线程处理完再依次处理任务队列中的任务，示例为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">ExecutorService singleThreadPool = Executors.newSingleThreadExecutor();</div><div class="line">for (int i = 1; i &lt;= 10; i++) &#123;</div><div class="line">    final int index = i;</div><div class="line">    singleThreadPool.execute(new Runnable() &#123;</div><div class="line">        @Override</div><div class="line">        public void run() &#123;</div><div class="line">            String threadName = Thread.currentThread().getName();</div><div class="line">            Log.v(&quot;zxy&quot;, &quot;线程：&quot;+threadName+&quot;,正在执行第&quot; + index + &quot;个任务&quot;);</div><div class="line">            try &#123;</div><div class="line">                Thread.sleep(1000);</div><div class="line">            &#125; catch (InterruptedException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>代码还是差不多，只不过改了线程池的实现方式，效果我想大家都知道，即依次一个一个的处理任务，而且都是复用一个线程，效果为：<br><img src="http://img.blog.csdn.net/20151116182627850" alt="这里写图片描述"></p>
<p>其实我们通过newSingleThreadExecutor()和newFixedThreadPool()的方法发现，创建一个singleThreadExecutorPool实际上就是创建一个核心线程数和最大线程数都为1的fixedThreadPool。<br><strong>newCachedThreadPool</strong><br>创建一个可以根据实际情况调整线程池中线程的数量的线程池，示例为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">ExecutorService cachedThreadPool = Executors.newCachedThreadPool();</div><div class="line">for (int i = 1; i &lt;= 10; i++) &#123;</div><div class="line">    final int index = i;</div><div class="line">    try &#123;</div><div class="line">        Thread.sleep(1000);</div><div class="line">    &#125; catch (InterruptedException e) &#123;</div><div class="line">        e.printStackTrace();</div><div class="line">    &#125;</div><div class="line">    cachedThreadPool.execute(new Runnable() &#123;</div><div class="line">        @Override</div><div class="line">        public void run() &#123;</div><div class="line">            String threadName = Thread.currentThread().getName();</div><div class="line">            Log.v(&quot;zxy&quot;, &quot;线程：&quot; + threadName + &quot;,正在执行第&quot; + index + &quot;个任务&quot;);</div><div class="line">            try &#123;</div><div class="line">                long time = index * 500;</div><div class="line">                Thread.sleep(time);</div><div class="line">            &#125; catch (InterruptedException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>为了体现该线程池可以自动根据实现情况进行线程的重用，而不是一味的创建新的线程去处理任务，我设置了每隔1s去提交一个新任务，这个新任务执行的时间也是动态变化的，所以，效果为：<br><img src="http://img.blog.csdn.net/20151116184528454" alt="这里写图片描述"><br><strong>newScheduledThreadPool</strong><br>创建一个可以定时或者周期性执行任务的线程池，示例为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(3);</div><div class="line">//延迟2秒后执行该任务</div><div class="line">scheduledThreadPool.schedule(new Runnable() &#123;</div><div class="line">    @Override</div><div class="line">    public void run() &#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;, 2, TimeUnit.SECONDS);</div><div class="line">//延迟1秒后，每隔2秒执行一次该任务</div><div class="line">scheduledThreadPool.scheduleAtFixedRate(new Runnable() &#123;</div><div class="line">    @Override</div><div class="line">    public void run() &#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;, 1, 2, TimeUnit.SECONDS);123456789101112131415</div></pre></td></tr></table></figure>
<p><strong>newSingleThreadScheduledExecutor</strong><br>创建一个可以定时或者周期性执行任务的线程池，该线程池的线程数为1，示例为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">ScheduledExecutorService singleThreadScheduledPool = Executors.newSingleThreadScheduledExecutor();</div><div class="line">//延迟1秒后，每隔2秒执行一次该任务</div><div class="line">singleThreadScheduledPool.scheduleAtFixedRate(new Runnable() &#123;</div><div class="line">    @Override</div><div class="line">    public void run() &#123;</div><div class="line">        String threadName = Thread.currentThread().getName();</div><div class="line">        Log.v(&quot;zxy&quot;, &quot;线程：&quot; + threadName + &quot;,正在执行&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;,1,2,TimeUnit.SECONDS);123456789</div></pre></td></tr></table></figure>
<p>实际上这个和上面的没什么太大区别，只不过是线程池内线程数量的不同，效果为：<br><img src="http://img.blog.csdn.net/20151116194526184" alt="这里写图片描述"><br>每隔2秒就会执行一次该任务</p>
<h3 id="自定义线程池ThreadPoolExecutor"><a href="#自定义线程池ThreadPoolExecutor" class="headerlink" title="自定义线程池ThreadPoolExecutor"></a><strong>自定义线程池ThreadPoolExecutor</strong></h3><p>Java内置只为我们提供了五种常用的线程池，一般来说这足够用了，不过有时候我们也可以根据需求来自定义我们自己的线程池，而要自定义不同功能的线程池，上面我们也说了线程池功能的不同归根到底还是内部的BlockingQueue实现不同，所以，我们要实现我们自己相要的线程池，就必须从BlockingQueue的实现上做手脚，而上面也说了BlockingQueue的实现类有多个，那么这次我们就选用PriorityBlockingQueue来实现一个功能是按任务的优先级来处理的线程池。</p>
<h4 id="1、首先我们创建一个基于PriorityBlockingQueue实现的线程池，为了测试方便，我这里把核心线程数量设置为3，如下："><a href="#1、首先我们创建一个基于PriorityBlockingQueue实现的线程池，为了测试方便，我这里把核心线程数量设置为3，如下：" class="headerlink" title="1、首先我们创建一个基于PriorityBlockingQueue实现的线程池，为了测试方便，我这里把核心线程数量设置为3，如下："></a><strong>1、首先我们创建一个基于PriorityBlockingQueue实现的线程池，为了测试方便，我这里把核心线程数量设置为3，如下：</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ExecutorService priorityThreadPool = new ThreadPoolExecutor(3,3,0L,TimeUnit.SECONDS,new PriorityBlockingQueue&lt;Runnable&gt;());1</div></pre></td></tr></table></figure>
<h4 id="2、然后创建一个实现Runnable接口的类，并向外提供一个抽象方法供我们实现自定义功能，并实现Comparable接口，实现这个接口主要就是进行优先级的比较，代码如下："><a href="#2、然后创建一个实现Runnable接口的类，并向外提供一个抽象方法供我们实现自定义功能，并实现Comparable接口，实现这个接口主要就是进行优先级的比较，代码如下：" class="headerlink" title="2、然后创建一个实现Runnable接口的类，并向外提供一个抽象方法供我们实现自定义功能，并实现Comparable接口，实现这个接口主要就是进行优先级的比较，代码如下："></a><strong>2、然后创建一个实现Runnable接口的类，并向外提供一个抽象方法供我们实现自定义功能，并实现Comparable接口，实现这个接口主要就是进行优先级的比较，代码如下：</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">public abstract class PriorityRunnable implements Runnable, Comparable&lt;PriorityRunnable&gt; &#123;</div><div class="line">    private int priority;</div><div class="line"></div><div class="line">    public PriorityRunnable(int priority) &#123;</div><div class="line">        if (priority &lt; 0)</div><div class="line">            throw new IllegalArgumentException();</div><div class="line">        this.priority = priority;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public int compareTo(PriorityRunnable another) &#123;</div><div class="line">        int my = this.getPriority();</div><div class="line">        int other = another.getPriority();</div><div class="line">        return my &lt; other ? 1 : my &gt; other ? -1 : 0;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void run() &#123;</div><div class="line">        doSth();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public abstract void doSth();</div><div class="line"></div><div class="line">    public int getPriority() &#123;</div><div class="line">        return priority;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="3、使用我们自己的PriorityRunnable提交任务，整体代码如下："><a href="#3、使用我们自己的PriorityRunnable提交任务，整体代码如下：" class="headerlink" title="3、使用我们自己的PriorityRunnable提交任务，整体代码如下："></a><strong>3、使用我们自己的PriorityRunnable提交任务，整体代码如下：</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">ExecutorService priorityThreadPool = new ThreadPoolExecutor(3, 3, 0L, TimeUnit.SECONDS, new PriorityBlockingQueue&lt;Runnable&gt;());</div><div class="line">for (int i = 1; i &lt;= 10; i++) &#123;</div><div class="line">    final int priority = i;</div><div class="line">    priorityThreadPool.execute(new PriorityRunnable(priority) &#123;</div><div class="line">        @Override</div><div class="line">        public void doSth() &#123;</div><div class="line">            String threadName = Thread.currentThread().getName();</div><div class="line">            Log.v(&quot;zxy&quot;, &quot;线程：&quot; + threadName + &quot;,正在执行优先级为：&quot; + priority + &quot;的任务&quot;);</div><div class="line">            try &#123;</div><div class="line">                Thread.sleep(2000);</div><div class="line">            &#125; catch (InterruptedException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="测试效果"><a href="#测试效果" class="headerlink" title="测试效果"></a><strong>测试效果</strong></h4><p>我们看下刚刚自定义的线程池是否达到了我们想要的功能，即根据任务的优先级进行优先处理任务，效果如下：<br><img src="http://img.blog.csdn.net/20151116212159326" alt="这里写图片描述"></p>
<p>可以从执行结果中看出，由于核心线程数设置为3，刚开始时，系统有3个空闲线程，所以无须使用任务队列，而是直接运行前三个任务，而后面再提交任务时由于当前没有空闲线程所以加入任务队列中进行等待，此时，由于我们的任务队列实现是由PriorityBlockingQueue实现的，所以进行等待的任务会经过优先级判断，优先级高的放在队列前面先处理。从效果图中也可以看到后面的任务是先执行优先级高的任务，然后依次递减。</p>
<h4 id="优先级线程池的优点"><a href="#优先级线程池的优点" class="headerlink" title="优先级线程池的优点"></a><strong>优先级线程池的优点</strong></h4><p>从上面我们可以得知，创建一个优先级线程池非常有用，它可以在线程池中线程数量不足或系统资源紧张时，优先处理我们想要先处理的任务，而优先级低的则放到后面再处理，这极大改善了系统默认线程池以FIFO方式处理任务的不灵活</p>
<h3 id="扩展线程池ThreadPoolExecutor"><a href="#扩展线程池ThreadPoolExecutor" class="headerlink" title="扩展线程池ThreadPoolExecutor"></a><strong>扩展线程池ThreadPoolExecutor</strong></h3><p>除了内置的功能外，ThreadPoolExecutor也向外提供了三个接口供我们自己扩展满足我们需求的线程池，这三个接口分别是：</p>
<blockquote>
<p>beforeExecute() - 任务执行前执行的方法<br>afterExecute() -任务执行结束后执行的方法<br>terminated() -线程池关闭后执行的方法</p>
</blockquote>
<p>这三个方法在ThreadPoolExecutor内部都没有实现</p>
<p>前面两个方法我们可以在ThreadPoolExecutor内部的runWorker()方法中找到，而runWorker()是ThreadPoolExecutor的内部类Worker实现的方法，Worker它实现了Runnable接口，也正是线程池内处理任务的工作线程，而Worker.runWorker()方法则是处理我们所提交的任务的方法，它会同时被多个线程访问，所以我们看runWorker()方法的实现，由于涉及到多个线程的异步调用，必然是需要使用锁来处理，而这里使用的是Lock来实现的，我们来看看runWorker()方法内主要实现：<br><img src="http://img.blog.csdn.net/20151117141139792" alt="这里写图片描述"></p>
<p>可以看到在task.run()之前和之后分别调用了beforeExecute和afterExecute方法，并传入了我们的任务Runnable对象</p>
<p>而terminated()则是在关闭线程池的方法中调用，而关闭线程池有两个方法，我贴其中一个：<br><img src="http://img.blog.csdn.net/20151117141553421" alt="这里写图片描述"></p>
<p>所以，我们要扩展线程池，只需要重写这三个方法，并实现我们自己的功能即可，这三个方法分别都会在任务执行前调用、任务执行完成后调用、线程池关闭后调用。<br>这里我验证一下，继承自ThreadPoolExecutor 并实现那三个方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">public class MyThreadPoolExecutor extends ThreadPoolExecutor &#123;</div><div class="line">    public MyThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue) &#123;</div><div class="line">        super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void beforeExecute(Thread t, Runnable r) &#123;</div><div class="line">        super.beforeExecute(t, r);</div><div class="line">        String threadName = t.getName();</div><div class="line">        Log.v(&quot;zxy&quot;, &quot;线程：&quot; + threadName + &quot;准备执行任务！&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void afterExecute(Runnable r, Throwable t) &#123;</div><div class="line">        super.afterExecute(r, t);</div><div class="line">        String threadName = Thread.currentThread().getName();</div><div class="line">        Log.v(&quot;zxy&quot;, &quot;线程：&quot; + threadName + &quot;任务执行结束！&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void terminated() &#123;</div><div class="line">        super.terminated();</div><div class="line">        Log.v(&quot;zxy&quot;, &quot;线程池结束！&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>而运行后的结果则是，这正符合刚刚说的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">11-17 05:47:51.184 1602-1619/? V/zxy: 线程：pool-6-thread-1准备执行任务！</div><div class="line">11-17 05:47:51.184 1602-1619/? V/zxy: 线程：pool-6-thread-1正在执行任务！</div><div class="line">11-17 05:47:53.184 1602-1619/? V/zxy: 线程：pool-6-thread-1任务执行结束！</div><div class="line">11-17 05:47:58.896 1602-1619/? V/zxy: 线程池结束！1234</div></pre></td></tr></table></figure>
<p>所以，在上面我们的优先级线程池的代码上，我们再扩展一个具有暂停功能的优先级线程池，代码如下：<br>具有暂时功能的线程池：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">public class PausableThreadPoolExecutor extends ThreadPoolExecutor &#123;</div><div class="line">    private boolean isPaused;</div><div class="line">    private ReentrantLock pauseLock = new ReentrantLock();</div><div class="line">    private Condition unpaused = pauseLock.newCondition();</div><div class="line"></div><div class="line">    public PausableThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue) &#123;</div><div class="line">        super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void beforeExecute(Thread t, Runnable r) &#123;</div><div class="line">        super.beforeExecute(t, r);</div><div class="line">        pauseLock.lock();</div><div class="line">        try &#123;</div><div class="line">            while (isPaused) unpaused.await();</div><div class="line">        &#125; catch (InterruptedException ie) &#123;</div><div class="line">            t.interrupt();</div><div class="line">        &#125; finally &#123;</div><div class="line">            pauseLock.unlock();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void pause() &#123;</div><div class="line">        pauseLock.lock();</div><div class="line">        try &#123;</div><div class="line">            isPaused = true;</div><div class="line">        &#125; finally &#123;</div><div class="line">            pauseLock.unlock();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void resume() &#123;</div><div class="line">        pauseLock.lock();</div><div class="line">        try &#123;</div><div class="line">            isPaused = false;</div><div class="line">            unpaused.signalAll();</div><div class="line">        &#125; finally &#123;</div><div class="line">            pauseLock.unlock();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后结合上面的优先级线程池的实现，创建具有暂停功能的优先级线程池：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">PausableThreadPoolExecutor pausableThreadPoolExecutor = new PausableThreadPoolExecutor(1, 1, 0L, TimeUnit.SECONDS, new PriorityBlockingQueue&lt;Runnable&gt;());</div><div class="line">for (int i = 1; i &lt;= 100; i++) &#123;</div><div class="line">    final int priority = i;</div><div class="line">    pausableThreadPoolExecutor.execute(new PriorityRunnable(priority) &#123;</div><div class="line">        @Override</div><div class="line">        public void doSth() &#123;</div><div class="line">            runOnUiThread(new Runnable() &#123;</div><div class="line">                @Override</div><div class="line">                public void run() &#123;</div><div class="line">                    textView.setText(priority + &quot;&quot;);</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">            try &#123;</div><div class="line">                Thread.sleep(1000);</div><div class="line">            &#125; catch (InterruptedException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里我为了演示效果，把这个线程池设为只有一个线程，然后直接在TextView中显示当前执行的任务的优先级，然后设置个开关，控制线程池的暂停与开始：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">if (isPause) &#123;</div><div class="line">    pausableThreadPoolExecutor.resume();</div><div class="line">    isPause = false;</div><div class="line">&#125; else &#123;</div><div class="line">    pausableThreadPoolExecutor.pause();</div><div class="line">    isPause = true;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>效果为：<br><img src="http://img.blog.csdn.net/20151117144914201" alt="这里写图片描述"></p>
<p>从效果上来看，该线程池和优先级线程一样，而且还多了一个暂停与开始的功能</p>
<h3 id="优化线程池ThreadPoolExecutor"><a href="#优化线程池ThreadPoolExecutor" class="headerlink" title="优化线程池ThreadPoolExecutor"></a><strong>优化线程池ThreadPoolExecutor</strong></h3><p>虽说线程池极大改善了系统的性能，不过创建线程池也是需要资源的，所以线程池内线程数量的大小也会影响系统的性能，大了反而浪费资源，小了反而影响系统的吞吐量，所以我们创建线程池需要把握一个度才能合理的发挥它的优点，通常来说我们要考虑的因素有CPU的数量、内存的大小、并发请求的数量等因素，按需调整。</p>
<p>通常核心线程数可以设为CPU数量+1，而最大线程数可以设为CPU的数量*2+1。</p>
<p>获取CPU数量的方法为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Runtime.getRuntime().availableProcessors();1</div></pre></td></tr></table></figure>
<h3 id="shutdown-和shutdownNow-的区别"><a href="#shutdown-和shutdownNow-的区别" class="headerlink" title="shutdown()和shutdownNow()的区别"></a><strong>shutdown()和shutdownNow()的区别</strong></h3><p>关于线程池的停止，ExecutorService为我们提供了两个方法：shutdown和shutdownNow，这两个方法各有不同，可以根据实际需求方便的运用，如下：</p>
<blockquote>
<p>1、shutdown()方法在终止前允许执行以前提交的任务。<br>2、shutdownNow()方法则是阻止正在任务队列中等待任务的启动并试图停止当前正在执行的任务。</p>
</blockquote>
<h3 id="关于AsyncTask的实现"><a href="#关于AsyncTask的实现" class="headerlink" title="关于AsyncTask的实现"></a><strong>关于AsyncTask的实现</strong></h3><p>大家都知道AsyncTask内部实现其实就是Thread+Handler。其中Handler是为了处理线程之间的通信，而这个Thread到底是指什么呢？通过AsyncTask源码可以得知，其实这个Thread是线程池，AsyncTask内部实现了两个线程池，分别是：串行线程池和固定线程数量的线程池。而这个固定线程数量则是通过CPU的数量决定的。</p>
<p>在默认情况下，我们大都通过AsyncTask::execute()来执行任务的，<br>，而execute()内部则是调用executeOnExecutor(sDefaultExecutor, params)方法执行的，第一个参数就是指定处理该任务的线程池，而默认情况下AsyncTask是传入串行线程池（在这里不讲版本的变化），也就是任务只能单个的按顺序执行，而我们要是想让AsyncTask并行的处理任务，大家都知道调用AsyncTask::executeOnExecutor(sDefaultExecutor, params)方法传入这个参数即可：AsyncTask.THREAD_POOL_EXECUTOR。<br>而这个参数的意义在于为任务指定了一个固定线程数量的线程池去处理，从而达到了并行处理的功能，我们可以在源码中看到AsyncTask.THREAD_POOL_EXECUTOR这个参数就是一个固定线程数量的线程池：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public static final Executor THREAD_POOL_EXECUTOR</div><div class="line">        = new ThreadPoolExecutor(CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE,</div><div class="line">                TimeUnit.SECONDS, sPoolWorkQueue, sThreadFactory);</div></pre></td></tr></table></figure>
<h4 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h4><p>1）什么是 Executor 框架？</p>
<p>Executor框架在Java 5中被引入，Executor 框架是一个根据一组执行策略调用、调度、执行和控制的异步任务的框架。</p>
<p>无限制的创建线程会引起应用程序内存溢出，所以创建一个线程池是个更好的的解决方案，因为可以限制线程的数量并且可以回收再利用这些线程。利用 Executor 框架可以非常方便的创建一个线程池。</p>
<p>2）Executors 类是什么？</p>
<p>Executors为Executor、ExecutorService、ScheduledExecutorService、ThreadFactory 和 Callable 类提供了一些工具方法。Executors 可以用于方便的创建线程池。</p>
<hr>
<p>未经许可不得转载，转载请注明zilianliuxue的blog,本人保留所有版权。</p>
  
	</div>
	
  <!-- css -->
  <style type="text/css">
      .center {
          text-align: center;
      }
      .hidden {
          display: none;
      }
    .donate_bar a.btn_donate{
      display: inline-block;
      width: 82px;
      height: 82px;
      background: url("http://7xsl28.com1.z0.glb.clouddn.com/btn_reward.gif") no-repeat;
      _background: url("http://7xsl28.com1.z0.glb.clouddn.com/btn_reward.gif") no-repeat;

      <!-- http://img.t.sinajs.cn/t5/style/images/apps_PRF/e_media/btn_reward.gif
           因为本 hexo 生成的博客所用的 theme 的 a:hover 带动画效果，
         为了在让打赏按钮显示效果正常 而 添加了以下几行 css，
         嵌入其它博客时不一定要它们。 -->
      -webkit-transition: background 0s;
      -moz-transition: background 0s;
      -o-transition: background 0s;
      -ms-transition: background 0s;
      transition: background 0s;
      <!-- /让打赏按钮的效果显示正常 而 添加的几行 css 到此结束 -->
    }

    .donate_bar a.btn_donate:hover{ background-position: 0px -82px;}
    .donate_bar .donate_txt {
      display: block;
      color: #9d9d9d;
      font: 14px/2 "Microsoft Yahei";
    }
    .bold{ font-weight: bold; }
  </style>
  <!-- /css -->

    <!-- Donate Module -->
    <div id="donate_module">

  <!-- btn_donate & tips -->
  <div id="donate_board" class="donate_bar center">
      <br>
      ------------------------------------------------------------------------------------------------------------------------------
      <br>
    <a id="btn_donate" class="btn_donate" target="_self" href="javascript:;" title="Donate 打赏"></a>
    <span class="donate_txt">
      打赏我一根冰棒钱，打赏我的人，运气都不会太差~
    </span>
      
    
  </div>
  <!-- /btn_donate & tips -->

  <!-- donate guide -->
    
  <div id="donate_guide" class="donate_bar center hidden">
        <br>
      ------------------------------------------------------------------------------------------------------------------------------
      <br>
      
      <div width="100%" align="center"><div name="dashmain" id="dash-main-id-87895f" class="dash-main-3 87895f-0.99"></div></div>
    <script type="text/javascript" charset="utf-8" src="http://www.dashangcloud.com/static/ds.js"></script>
    

    <a href="http://i.imgur.com/EhvkeWS.png" title="用微信扫一扫哦~" class="fancybox" rel="article0">
      <img src="http://i.imgur.com/EhvkeWS.png" title="微信打赏 Donate" height="190px" width="auto"/>
    </a>
        
          

    <a href="http://i.imgur.com/FhK6Sph.png" title="用支付宝扫一扫即可~" class="fancybox" rel="article0">
      <img src="http://i.imgur.com/FhK6Sph.png" title="支付宝打赏 Donate" height="190px" width="auto"/>
    </a>

    <span class="donate_txt">
      打赏我一根冰棒钱，打赏我的人，运气都不会太差~
    </span>

  </div>
  <!-- /donate guide -->

  <!-- donate script -->
  <script type="text/javascript">
    document.getElementById('btn_donate').onclick = function() {
      $('#donate_board').addClass('hidden');
      $('#donate_guide').removeClass('hidden');
    }

    function donate_on_web(){
      $('#donate').submit();
        }

    var original_window_onload = window.onload;
        window.onload = function () {
            if (original_window_onload) {
                original_window_onload();
            }
            document.getElementById('donate_board_wdg').className = 'hidden';
    }
  </script>
  <!-- /donate script -->
</div>
<!-- /Donate Module -->
   
		<footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/java/">java</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/线程池/">线程池</a>
  </div>

</div>



	<div class="article-share" id="share">
	
	  <div data-url="http://zilianliuxue.github.io/2016/08/25/java线程池/" data-title="java 线程池 | ♀紫☆恋&amp;流★雪♂" data-tsina="3290293743" class="share clearfix">
	  </div>
	
	</div>


</footer>

   	       
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev" >
 <a href="/2016/08/26/Android的线程和线程池/" title="Android的线程和线程池">
  <strong>上一篇：</strong><br/>
  <span>
  Android的线程和线程池</span>
</a>
</div>


<div class="next">
<a href="/2016/08/25/Java-Android并发编程引气入门篇/"  title="Java-Android并发编程引气入门篇">
 <strong>下一篇：</strong><br/> 
 <span>Java-Android并发编程引气入门篇
</span>
</a>
</div>

</nav>

	
<section id="comments" class="comment">
	<div class="ds-thread" data-thread-key="2016/08/25/java线程池/" data-title="java 线程池" data-url="http://zilianliuxue.github.io/2016/08/25/java线程池/"></div>
</section>


</div>  
      <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">文章目录</strong>
 
 <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#ExecutorService"><span class="toc-number">1.</span> <span class="toc-text">ExecutorService</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#使用线程池管理线程的优点"><span class="toc-number">1.1.</span> <span class="toc-text">使用线程池管理线程的优点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ExecutorService简介"><span class="toc-number">1.2.</span> <span class="toc-text">ExecutorService简介</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#线程池：ThreadPoolExecutor"><span class="toc-number">1.2.1.</span> <span class="toc-text">线程池：ThreadPoolExecutor</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#再撸一撸概念"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">再撸一撸概念</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#线程池ThreadPoolExecutor的使用"><span class="toc-number">1.3.</span> <span class="toc-text">线程池ThreadPoolExecutor的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#自定义线程池ThreadPoolExecutor"><span class="toc-number">1.3.1.</span> <span class="toc-text">自定义线程池ThreadPoolExecutor</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1、首先我们创建一个基于PriorityBlockingQueue实现的线程池，为了测试方便，我这里把核心线程数量设置为3，如下："><span class="toc-number">1.3.1.1.</span> <span class="toc-text">1、首先我们创建一个基于PriorityBlockingQueue实现的线程池，为了测试方便，我这里把核心线程数量设置为3，如下：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2、然后创建一个实现Runnable接口的类，并向外提供一个抽象方法供我们实现自定义功能，并实现Comparable接口，实现这个接口主要就是进行优先级的比较，代码如下："><span class="toc-number">1.3.1.2.</span> <span class="toc-text">2、然后创建一个实现Runnable接口的类，并向外提供一个抽象方法供我们实现自定义功能，并实现Comparable接口，实现这个接口主要就是进行优先级的比较，代码如下：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3、使用我们自己的PriorityRunnable提交任务，整体代码如下："><span class="toc-number">1.3.1.3.</span> <span class="toc-text">3、使用我们自己的PriorityRunnable提交任务，整体代码如下：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#测试效果"><span class="toc-number">1.3.1.4.</span> <span class="toc-text">测试效果</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#优先级线程池的优点"><span class="toc-number">1.3.1.5.</span> <span class="toc-text">优先级线程池的优点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#扩展线程池ThreadPoolExecutor"><span class="toc-number">1.3.2.</span> <span class="toc-text">扩展线程池ThreadPoolExecutor</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#优化线程池ThreadPoolExecutor"><span class="toc-number">1.3.3.</span> <span class="toc-text">优化线程池ThreadPoolExecutor</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#shutdown-和shutdownNow-的区别"><span class="toc-number">1.3.4.</span> <span class="toc-text">shutdown()和shutdownNow()的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#关于AsyncTask的实现"><span class="toc-number">1.3.5.</span> <span class="toc-text">关于AsyncTask的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#面试题"><span class="toc-number">1.3.5.1.</span> <span class="toc-text">面试题</span></a></li></ol></li></ol></li></ol></li></ol>
 
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">

  
<div class="github-card">
<p class="asidetitle">Github 名片</p>
<div class="github-card" data-github="zilianliuxue" data-width="220" data-height="88" data-theme="medium">
<script type="text/javascript" src="//cdn.jsdelivr.net/github-cards/latest/widget.js" ></script>
</div>
  </div>



  
<div class="categorieslist">
	<p class="asidetitle">分类</p>
		<ul>
		
		  
			<li><a href="/categories/android/" title="android">android<sup>19</sup></a></li>
		  
		
		  
			<li><a href="/categories/git/" title="git">git<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/hexo/" title="hexo">hexo<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/java/" title="java">java<sup>2</sup></a></li>
		  
		
		</ul>
</div>




  
<div class="tagslist">
	<p class="asidetitle">标签</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/Fragment/" title="Fragment">Fragment<sup>7</sup></a></li>
			
		
			
				<li><a href="/tags/线程池/" title="线程池">线程池<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/快速开发/" title="快速开发">快速开发<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/面试/" title="面试">面试<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/BroadcastReceiver/" title="BroadcastReceiver">BroadcastReceiver<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/EventBus3/" title="EventBus3">EventBus3<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/ContentProvider/" title="ContentProvider">ContentProvider<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/activity/" title="activity">activity<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/window/" title="window">window<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/git/" title="git">git<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/jacman/" title="jacman">jacman<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/jni-ndk/" title="jni ndk">jni ndk<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Service/" title="Service">Service<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Cache/" title="Cache">Cache<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/view事件机制/" title="view事件机制">view事件机制<sup>1</sup></a></li>
			
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">友情链接</p>
    <ul>
        
          <li>
            
            	<a href="http://www.jianshu.com/" target="_blank" title="一个面向程序员交流分享的新一代社区">jianshu</a>
            
          </li>
        
          <li>
            
            	<a href="http://blog.csdn.net/u013278099" target="_blank" title="Losileeya CSDN">Losileeya CSDN</a>
            
          </li>
        
          <li>
            
            	<a href="http://www.trinea.cn/" target="_blank" title="trinea">trinea</a>
            
          </li>
        
          <li>
            
            	<a href="http://blog.daimajia.com/" target="_blank" title="daimajia">daimajia</a>
            
          </li>
        
          <li>
            
            	<a href="http://www.lcode.org/" target="_blank" title="江清清的技术专栏">江清清的技术专栏</a>
            
          </li>
        
          <li>
            
            	<a href="https://www.aswifter.com/" target="_blank" title="阳春面的博客">阳春面的博客</a>
            
          </li>
        
    </ul>
</div>

  
  <div class="tagcloudlist">
    <p class="asidetitle">标签云</p>
    <div class="tagcloudlist clearfix">
       <a href="/tags/BroadcastReceiver/" style="font-size: 10px;">BroadcastReceiver</a> <a href="/tags/Cache/" style="font-size: 10px;">Cache</a> <a href="/tags/ContentProvider/" style="font-size: 10px;">ContentProvider</a> <a href="/tags/EventBus3/" style="font-size: 10px;">EventBus3</a> <a href="/tags/Fragment/" style="font-size: 20px;">Fragment</a> <a href="/tags/Service/" style="font-size: 10px;">Service</a> <a href="/tags/activity/" style="font-size: 10px;">activity</a> <a href="/tags/git/" style="font-size: 10px;">git</a> <a href="/tags/jacman/" style="font-size: 10px;">jacman</a> <a href="/tags/jni-ndk/" style="font-size: 10px;">jni ndk</a> <a href="/tags/view事件机制/" style="font-size: 10px;">view事件机制</a> <a href="/tags/window/" style="font-size: 10px;">window</a> <a href="/tags/快速开发/" style="font-size: 10px;">快速开发</a> <a href="/tags/线程池/" style="font-size: 15px;">线程池</a> <a href="/tags/面试/" style="font-size: 10px;">面试</a>
    </div>
  </div>


  <div class="rsspart">
	<a href="/atom.xml" target="_blank" title="rss">RSS 订阅</a>
</div>

  <div class="weiboshow">
  <p class="asidetitle">新浪微博</p>
    <iframe width="100%" height="119" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=119&fansRow=2&ptype=1&speed=0&skin=9&isTitle=1&noborder=1&isWeibo=0&isFans=0&uid=3290293743&verifier=20a2ffb1&dpc=1"></iframe>
</div>


</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> Hello ,I&#39;m Losileeya . <br/>
			This is my blog,believe it or not.</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		<a href="http://weibo.com/3290293743" target="_blank" class="icon-weibo" title="微博"></a>
		
		
		<a href="https://github.com/zilianliuxue" target="_blank" class="icon-github" title="github"></a>
		
		
		
		
		
		
		
		
		
		<a href="mailto:847457332@qq.com" target="_blank" class="icon-email" title="Email Me"></a>
		
	</div>
			
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2016 
		
		<a href="/about" target="_blank" title="Losileeya">Losileeya</a>
		
		
		</p>
		<script type="text/javascript">
  (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
  (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
  e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
  })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');
  
  _st('install','R4yoD_akDbrgyYA8-p3S','2.0.0');
</script>
	<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>	
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  c.click(function(){
    ta.css('display', 'block').addClass('fadeIn');
  });
  o.click(function(){
    ta.css('display', 'none');
  });
  $(window).scroll(function(){
    ta.css("top",Math.max(140,320-$(this).scrollTop()));
  });
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina'),
      description = $this.attr('description');
  var html = [
  '<div class="hoverqrcode clearfix"></div>',
  '<a class="overlay" id="qrcode"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="微信"></a>',
  '<a href="http://widget.renren.com/dialog/share?resourceUrl=' + encodedUrl + '&srcUrl=' + encodedUrl + '&title=' + title +'" class="article-share-renren" target="_blank" title="人人"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="微博"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);

  $('.hoverqrcode').hide();

  var myWidth = 0;
  function updatehoverqrcode(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
    var qrsize = myWidth > 1024 ? 200:100;
    var options = {render: 'image', size: qrsize, fill: '#2ca6cb', text: url, radius: 0.5, quiet: 1};
    var p = $('.article-share-qrcode').position();
    $('.hoverqrcode').empty().css('width', qrsize).css('height', qrsize)
                          .css('left', p.left-qrsize/2+20).css('top', p.top-qrsize-10)
                          .qrcode(options);
  };
  $(window).resize(function(){
    $('.hoverqrcode').hide();
  });
  $('.article-share-qrcode').click(function(){
    updatehoverqrcode();
    $('.hoverqrcode').toggle();
  });
  $('.article-share-qrcode').hover(function(){}, function(){
      $('.hoverqrcode').hide();
  });
});   
</script>



<script type="text/javascript">
  var duoshuoQuery = {short_name:"zilianliuxue"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
    || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script> 







<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?e6d1f421bbc9962127a50488f9ed37d1";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>



<script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1260017595'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s95.cnzz.com/z_stat.php%3Fid%3D1260017595%26online%3D1%26show%3Dline' type='text/javascript'%3E%3C/script%3E"));</script>


<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="返回顶部"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
</html>
