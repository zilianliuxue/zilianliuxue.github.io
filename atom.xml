<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>♀紫☆恋&amp;流★雪♂</title>
  <subtitle>编程中我们会遇到多少挫折？不放弃，沙漠尽头必是绿洲，不是天方夜谭</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://zilianliuxue.github.io/"/>
  <updated>2016-08-26T06:39:46.084Z</updated>
  <id>http://zilianliuxue.github.io/</id>
  
  <author>
    <name>Losileeya</name>
    <email>847457332@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Android的线程和线程池</title>
    <link href="http://zilianliuxue.github.io/2016/08/26/Android%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>http://zilianliuxue.github.io/2016/08/26/Android的线程和线程池/</id>
    <published>2016-08-26T06:35:26.963Z</published>
    <updated>2016-08-26T06:39:46.084Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>在操作系统中，线程是操作系统调度的最小单元，当系统中存在大量线程时，系统会通过时间片轮转的方式调度每个线程，当进程中频繁的创建和销毁线程的时候应该采用线程池，线程池会缓存一定数量的线程，避免频繁创建和销毁线程带来的系统开销。</p>
</blockquote>
<h2 id="主线程和子线程"><a href="#主线程和子线程" class="headerlink" title="主线程和子线程"></a>主线程和子线程</h2><p>(1) 在Java中默认情况下一个进程只有一个线程，也就是主线程，其他线程都是子线程，也叫工作线程。Android中的主线程主要处理和界面相关的事情，而子线程则往往用于执行耗时操作。线程的创建和销毁的开销较大，所以如果一个进程要频繁地创建和销毁线程的话，都会采用线程池的方式。</p>
<p>(2) 在Android中除了Thread，还有HandlerThread、AsyncTask以及IntentService等也都扮演着线程的角色，只是它们具有不同的特性和使用场景。AsyncTask封装了线程池和Handler，它主要是为了方便开发者在子线程中更新UI。HandlerThread是一种具有消息循环的线程，在它的内部可以使用Handler。IntentService是一个服务，它内部采用HandlerThread来执行任务，当任务执行完毕后就会自动退出。因为它是服务的缘故，所以和后台线程相比，它比较不容易被系统杀死。</p>
<p>(3). 从Android 3.0开始，系统要求网络访问必须在子线程中进行，否则网络访问将会失败并抛出NetworkOnMainThreadException这个异常，这样做是为了避免主线程由于被耗时操作所阻塞从而出现ANR现象。</p>
<h2 id="Android中的线程形态"><a href="#Android中的线程形态" class="headerlink" title="Android中的线程形态"></a>Android中的线程形态</h2><h3 id="AsyncTask"><a href="#AsyncTask" class="headerlink" title="AsyncTask"></a>AsyncTask</h3><p>AsyncTask是一个抽象泛型类，它提供了Params、Progress、Result三个泛型参数，如果task确实不需要传递具体的参数，那么都可以设置为Void。下面是它的四个核心方法，其中doInBackground不是在主线程执行的。<br>onPreExecute、doInBackground、onProgressUpdate、onPostResult</p>
<h4 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h4><ul>
<li>AsyncTask必须在主线程中加载</li>
<li>必须在诛仙城中创建</li>
<li>execute必须在UI线程调用</li>
<li>一个AsyncTask对象只能执行一次，即只能调用一次execute方法</li>
<li>在Android1.6的时候线程池是并行任务，在Android3.0为了避免并发错误采用串行执行任务。但是我们仍然可以用过executeOnExecutor方法并行执行任务。</li>
</ul>
<h3 id="HandlerThread"><a href="#HandlerThread" class="headerlink" title="HandlerThread"></a>HandlerThread</h3><p>它继承了Thread，是一种可以使用Handler的Thread.他的实现也很简单，就是在run方法中通过Looper。prepare来创建消息队列，并通过Looper.loop来开启消息循环，这样在使用的时候就可以在HandlerThread中创建Handler了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public void run() &#123;</div><div class="line">    mTid = Process.myTid();</div><div class="line">    Looper.prepare();</div><div class="line">    synchronized (this) &#123;</div><div class="line">        mLooper = Looper.myLooper();</div><div class="line">        notifyAll();</div><div class="line">    &#125;</div><div class="line">    Process.setThreadPriority(mPriority);</div><div class="line">    onLooperPrepared();</div><div class="line">    Looper.loop();</div><div class="line">    mTid = -1;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>HandlerThread在内部创建了消息队列，外界需要通过Handler的消息方式开通知它执行一个具体的任务，它的一个具体实现是IntentService。当我们不需要使用Handler的时候可以通过quit获取quitSafelt方法终结线程的执行。</p>
<h3 id="IntentService"><a href="#IntentService" class="headerlink" title="IntentService"></a>IntentService</h3><p>继承了Service是一个抽象类，必须创建它的子类才可以使用它，IntentService可以执行后台耗时任务，当任务执行完毕之后会自动停止，因为他是服务，所以他的优先级比普通的线程高，比较适合执行一些高优先级的后台任务。</p>
<h2 id="Android中的线程池"><a href="#Android中的线程池" class="headerlink" title="Android中的线程池"></a>Android中的线程池</h2><blockquote>
<p>Android里面，耗时的网络操作，都会开子线程，在程序里面直接开过多的线程会消耗过多的资源，在众多的开源框架中也总能看到线程池的踪影，所以线程池是必须要会把握的一个知识点;</p>
</blockquote>
<h4 id="线程池的优点："><a href="#线程池的优点：" class="headerlink" title="线程池的优点："></a>线程池的优点：</h4><ul>
<li>重用线程池中的线程，避免频繁创建和销毁带来的性能开销</li>
<li>可以有效控制线程池中的最大并发数，避免大量线程之间互相抢占系统资源导致阻塞</li>
<li>可以对线程进行简单管理。</li>
</ul>
<h4 id="线程运行机制"><a href="#线程运行机制" class="headerlink" title="线程运行机制"></a>线程运行机制</h4><ul>
<li>开启线程过多，会消耗<code>cpu资源</code></li>
<li>单核cpu，同一时刻只能处理一个线程，多核cpu同一时刻可以处理多个线程</li>
<li>操作系统为每个运行线程安排一定的CPU时间—-<code>时间片</code>，系统通过一种循环的方式为线程提供时间片，线程在自己的时间内运行，因为时间相当短，多个线程频繁地发生切换，因此给用户的感觉就是好像多个线程同时运行一样，但是如果计算机有多个CPU，线程就能真正意义上的同时运行了.</li>
</ul>
<h4 id="线程池的作用"><a href="#线程池的作用" class="headerlink" title="线程池的作用"></a>线程池的作用</h4><ul>
<li>线程池是预先创建线程的一种技术。线程池在还没有任务到来之前，创建一定数量的线程，放入空闲队列中，然后对这些资源进行复用。<code>减少频繁的创建和销毁对象。</code></li>
<li>频繁创建和销毁线程耗资源，耗时间</li>
<li>因为有的线程执行时间比创建和销毁一个线程的时间还短</li>
</ul>
<h4 id="线程池涉及的类"><a href="#线程池涉及的类" class="headerlink" title="线程池涉及的类"></a>线程池涉及的类</h4><ul>
<li>Executor:Java里面线程池的顶级接口。</li>
<li>ExecutorService:真正的线程池接口。</li>
<li>ScheduledExecutorService:能和Timer/TimerTask类似，解决那些需要任务重复执行的问题。</li>
<li>ThreadPoolExecutor(重点):ExecutorService的默认实现。</li>
<li>ScheduledThreadPoolExecutor:继承ThreadPoolExecutor的ScheduledExecutorService接口实现，周期性任务调度的类实现。</li>
<li>Executors:可以一行代码创建一些常见的线程池。</li>
</ul>
<h3 id="Executors介绍（把握使用，把握常见线程池）"><a href="#Executors介绍（把握使用，把握常见线程池）" class="headerlink" title="Executors介绍（把握使用，把握常见线程池）"></a>Executors介绍（把握使用，把握常见线程池）</h3><blockquote>
<p>Executors:jdk1.5之后的一个新类，<code>提供了一些静态方法，帮助我们方便的生成一些常用的线程池</code>，ThreadPoolExecutor是Executors类的底层实现</p>
</blockquote>
<p>1.newSingleThreadExecutor</p>
<blockquote>
<p>创建一个单线程的线程池。这个线程池只有一个线程在工作，也就是相当于单线程串行执行&gt;所有任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池&gt;保证所有任务的执行顺序按照任务的提交顺序执行。</p>
</blockquote>
<p>2.newFixedThreadPool</p>
<blockquote>
<p>创建固定大小的线程池。每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。</p>
</blockquote>
<p>3.newCachedThreadPool</p>
<blockquote>
<p>创建一个可缓存的线程池。如果线程池的大小超过了处理任务所需要的线程，<br>那么就会回收部分空闲（60秒不执行任务）的线程，当任务数增加时，此线程池又可以智能的添加新线程来处理任务。此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小。</p>
</blockquote>
<p>4.newScheduledThreadPool</p>
<blockquote>
<p>创建一个大小无限的线程池。此线程池支持定时以及周期性执行任务的需求。</p>
</blockquote>
<h4 id="ThreadPoolExecutor介绍"><a href="#ThreadPoolExecutor介绍" class="headerlink" title="ThreadPoolExecutor介绍"></a>ThreadPoolExecutor介绍</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//构造方法</div><div class="line">public ThreadPoolExecutor(int corePoolSize，//核心池的大小</div><div class="line">                              int maximumPoolSize，//线程池最大线程数</div><div class="line">                              long keepAliveTime，//保持时间</div><div class="line">                              TimeUnit unit，//时间单位</div><div class="line">                              BlockingQueue&lt;Runnable&gt; workQueue，//任务队列</div><div class="line">                              ThreadFactory threadFactory，//线程工厂</div><div class="line">                              RejectedExecutionHandler handler) //异常的捕捉器</div></pre></td></tr></table></figure>
<h4 id="构造相关参数解释"><a href="#构造相关参数解释" class="headerlink" title="构造相关参数解释"></a>构造相关参数解释</h4><ul>
<li><p>corePoolSize：<code>核心池的大小</code>，这个参数跟后面讲述的线程池的实现原理有非常大的关系。在创建了线程池后，默认情况下，线程池中并没有任何线程，而是等待有任务到来才创建线程去执行任务，除非调用了prestartAllCoreThreads()或者prestartCoreThread()方法，从这2个方法的名字就可以看出，是预创建线程的意思，即在没有任务到来之前就创建corePoolSize个线程或者一个线程。默认情况下，在创建了线程池后，线程池中的线程数为0，当有任务来之后，就会创建一个线程去执行任务，当线程池中的线程数目达到corePoolSize后，就会把到达的任务放到缓存队列当中；</p>
</li>
<li><p>maximumPoolSize：<code>’线程池最大线程数</code>，<br>这个参数也是一个非常重要的参数，它表示在线程池中最多能创建多少个线程；</p>
</li>
<li><p>keepAliveTime：<code>表示线程没有任务执行时最多保持多久时间会终止</code>。默认情况下，只有当线程池中的线程数大于corePoolSize时，keepAliveTime才会起作用，直到线程池中的线程数不大于corePoolSize，即当线程池中的线程数大于corePoolSize时，如果一个线程空闲的时间达到keepAliveTime，则会终止，直到线程池中的线程数不超过corePoolSize。但是如果调用了allowCoreThreadTimeOut(boolean)方法，在线程池中的线程数不大于corePoolSize时，keepAliveTime参数也会起作用，直到线程池中的线程数为0；</p>
</li>
<li><p>unit：参数keepAliveTime的<code>时间单位</code>，有7种取值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">TimeUnit.DAYS;               //天</div><div class="line">TimeUnit.HOURS;             //小时</div><div class="line">TimeUnit.MINUTES;           //分钟</div><div class="line">TimeUnit.SECONDS;           //秒</div><div class="line">TimeUnit.MILLISECONDS;      //毫秒</div><div class="line">TimeUnit.MICROSECONDS;      //微妙</div><div class="line">TimeUnit.NANOSECONDS;       //纳秒</div></pre></td></tr></table></figure>
</li>
<li><p>workQueue ： <code>任务队列</code>，是一个阻塞队列，用来存储等待执行的任务，这个参数的选择也很重要，会对线程池的运行过程产生重大影响，参考BlockingQueue</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ArrayBlockingQueue</div><div class="line">LinkedBlockingQueue</div><div class="line">SynchronousQueue</div></pre></td></tr></table></figure>
</li>
<li><p>threadFactory : <code>线程工厂</code>，如何去创建线程的</p>
</li>
<li><p>handler ： 任务队列添加<code>异常的捕捉器</code>，参考 RejectedExecutionHandler</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常。 </div><div class="line">ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。 </div><div class="line">ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）</div><div class="line">ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="基础API的介绍"><a href="#基础API的介绍" class="headerlink" title="基础API的介绍"></a>基础API的介绍</h4><ul>
<li>isShutdown() ： 判断线程池是否关闭</li>
<li>isTerminated() : 判断线程池中任务是否执行完成</li>
<li>shutdown() : 调用后不再接收新任务，如果里面有任务，就执行完</li>
<li>shutdownNow() : 调用后不再接受新任务，如果有等待任务，移出队列；有正在执行的，尝试停止之</li>
<li>submit() : 提交执行任务</li>
<li>execute() : 执行任务</li>
</ul>
<h4 id="任务提交给线程池之后的处理策略"><a href="#任务提交给线程池之后的处理策略" class="headerlink" title="任务提交给线程池之后的处理策略"></a>任务提交给线程池之后的处理策略</h4><ol>
<li>如果当前线程池中的线程数目小于corePoolSize，则每来一个任务，就会创建执行这个任务；</li>
<li>如果当前线程池中的线程数目&gt;=corePoolSize，则每来一个任务，会尝试将其添加到任务缓存队列当中<ol>
<li>若添加成功，则该任务会等待空闲线程将其取出去执行；</li>
<li>若添加失败（一般来说是任务缓存队列已满，针对的是有界队列），则会尝试创建新的线程去执行这个任务；</li>
</ol>
</li>
<li>如果当前线程池中的线程数目达到maximumPoolSize，则会采取任务拒绝策略进行处理；</li>
<li>如果线程池中的线程数量大于 corePoolSize时，如果某线程空闲时间超过keepAliveTime，线程将被终止，直至线程池中的线程数目不大于corePoolSize；如果允许为核心池中的线程设置存活时间，那么核心池中的线程空闲时间超过keepAliveTime，线程也会被终止。</li>
</ol>
<h4 id="任务提交给线程池之后的处理策略-比喻"><a href="#任务提交给线程池之后的处理策略-比喻" class="headerlink" title="任务提交给线程池之后的处理策略_比喻"></a>任务提交给线程池之后的处理策略_比喻</h4><blockquote>
<p>假如有一个工厂，工厂里面有10(<code>corePoolSize</code>)个工人，每个工人同时只能做一件任务。</p>
<p>因此只要当10个工人中有工人是空闲的，<code>来了任务就分配</code>给空闲的工人做；</p>
<p>当10个工人都有任务在做时，如果还来了任务，就把任务进行排队等待(<code>任务队列</code>)；</p>
<p>如果说新任务数目增长的速度远远大于工人做任务的速度，那么此时工厂主管可能会想补救措施，比如重新招4个临时工人(<code>创建新线程</code>)进来；然后就将任务也分配给这4个临时工人做；</p>
<p>如果说着14个工人做任务的速度还是不够，此时工厂主管可能就要考虑不再接收新的任务或者抛弃前面的一些任务了(<code>拒绝执行</code>)。</p>
<p>当这14个工人当中有人空闲时，而且空闲超过一定时间(<code>空闲时间</code>)，新任务增长的速度又比较缓慢，工厂主管可能就考虑辞掉4个临时工了，只保持原来的10个工人，毕竟请额外的工人是要花钱的</p>
</blockquote>
<h3 id="阻塞队列的介绍（BlockingQueue）"><a href="#阻塞队列的介绍（BlockingQueue）" class="headerlink" title="阻塞队列的介绍（BlockingQueue）"></a>阻塞队列的介绍（BlockingQueue）</h3><p>阻塞队列，如果BlockingQueue是空的，从BlockingQueue取东西的操作将会被阻断进入等待状态，直到BlockingQueue进了东西才会被唤醒，同样，如果BlockingQueue是满的，任何试图往里存东西的操作也会被阻断进入等待状态，直到BlockingQueue里有空间时才会被唤醒继续操作。</p>
<ol>
<li>基础API介绍<ul>
<li>往队列中加元素的方法<ul>
<li>add(E) : 非阻塞方法， 把元素加到BlockingQueue里，如果BlockingQueue可以容纳，则返回true，否则抛出异常。</li>
<li>offer(E) : 非阻塞， 表示如果可能的话，将元素加到BlockingQueue里，即如果BlockingQueue可以容纳，则返回true，否则返回false。</li>
<li>put(E)：阻塞方法， 把元素加到BlockingQueue里，如果BlockingQueue没有空间，则调用此方法的线程被阻断直到BlockingQueue里有空间再继续。</li>
</ul>
</li>
<li>从队列中取元素的方法<ul>
<li>poll(time)： 阻塞方法，取走BlockingQueue里排在首位的元素，若不能立即取出，则可以等time参数规定的时间，取不到时返回null。</li>
<li>take()：取走BlockingQueue里排在首位的对象，若BlockingQueue为空，阻断进入等待状态直到BlockingQueue有新的对象被加入为止。</li>
</ul>
</li>
</ul>
</li>
<li>子类介绍<ul>
<li><code>ArrayBlockingQueue(有界队列)</code>： FIFO 队列，规定大小的BlockingQueue，其构造函数必须带一个int参数来指明其大小</li>
<li><code>LinkedBlockingQueue(无界队列)</code>：FIFO 队列，大小不定的BlockingQueue，若其构造函数带一个规定大小的参数，生成的BlockingQueue有大小限制，若不带大小参数，所生成的BlockingQueue的大小由Integer.MAX_VALUE来决定。</li>
<li><code>PriorityBlockingQueue</code>：优先级队列， 类似于LinkedBlockingQueue，但队列中元素非 FIFO， 依据对象的自然排序顺序或者是构造函数所带的Comparator决定的顺序</li>
<li><code>SynchronousQueue(直接提交策略)</code>: 交替队列，<code>队列中操作时必须是先放进去，接着取出来</code>，交替着去处理元素的添加和移除，这是一个很有意思的阻塞队列，其中每个插入操作必须等待另一个线程的移除操作，同样任何一个移除操作都等待另一个线程的插入操作。因此此队列内部其 实没有任何一个元素，或者说容量是0，严格说并不是一种容器。由于队列没有容量，因此不能调用peek操作，因为只有移除元素时才有元素。</li>
</ul>
</li>
</ol>
<hr>
<p>未经许可不得转载，转载请注明zilianliuxue的blog,本人保留所有版权。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;在操作系统中，线程是操作系统调度的最小单元，当系统中存在大量线程时，系统会通过时间片轮转的方式调度每个线程，当进程中频繁的创建和销毁线程的时候应该采用线程池，线程池会缓存一定数量的线程，避免频繁创建和销毁线程带来的系统开销。&lt;/p&gt;
&lt;/block
    
    </summary>
    
      <category term="android" scheme="http://zilianliuxue.github.io/categories/android/"/>
    
    
      <category term="线程池" scheme="http://zilianliuxue.github.io/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>window和windowManager</title>
    <link href="http://zilianliuxue.github.io/2016/08/26/Window%E4%B8%8EWindowManager/"/>
    <id>http://zilianliuxue.github.io/2016/08/26/Window与WindowManager/</id>
    <published>2016-08-26T06:33:56.362Z</published>
    <updated>2016-08-26T06:43:46.600Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>Window是一个窗口的概念，是一个抽象类，具体实现是PhoneWindow。<br>通过WindowManager来创建Window。<br>Window的具体实现位于WindowManagerService，WindowsManager和WindowMannagerService的交互是一个IPC的过程。</p>
</blockquote>
<h2 id="Window与WindowManager"><a href="#Window与WindowManager" class="headerlink" title="Window与WindowManager"></a>Window与WindowManager</h2><p>(1). 使用WindowManager添加一个Window的过程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">Button button = new Button(this);</div><div class="line">button.setText(&quot;button&quot;);</div><div class="line">WindowManager.LayoutParams params = new WindowManager.LayoutParams(</div><div class="line">        WindowManager.LayoutParams.WRAP_CONTENT,</div><div class="line">        WindowManager.LayoutParams.WRAP_CONTENT,</div><div class="line">        0, 0, PixelFormat.TRANSPARENT);</div><div class="line">params.flags = WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE</div><div class="line">        | WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL</div><div class="line">        | WindowManager.LayoutParams.FLAG_SHOW_WHEN_LOCKED;</div><div class="line">params.gravity = Gravity.LEFT | Gravity.TOP;</div><div class="line">params.x = 100;</div><div class="line">params.y = 300;</div><div class="line">WindowManager windowManager = (WindowManager) getSystemService(WINDOW_SERVICE);</div><div class="line">windowManager.addView(button,params);</div></pre></td></tr></table></figure>
<p>上面的代码将一个Button添加到屏幕坐标为（100，300）的位置.<br>(2).WindowManager.LayoutParams中的flag参数表示Window的属性，下面是几个比较常用的属性。</p>
<ul>
<li>FLAG_NOT_FOCUSABLE</li>
</ul>
<p>表示window不需要获取焦点，也不需要接收各种输入事件。此标记会同时启用FLAG_NOT_TOUCH_MODAL，最终事件会直接传递给下层的具有焦点的window；</p>
<ul>
<li>FLAG_NOT_TOUCH_MODAL：</li>
</ul>
<p>在此模式下，系统会将window区域外的单击事件传递给底层的window，当前window区域内的单击事件则自己处理，一般都需要开启这个标记；</p>
<ul>
<li>FLAG_SHOW_WHEN_LOCKED</li>
</ul>
<p>开启此模式可以让Window显示在锁屏的界面上</p>
<p>(3).TYPE参数表示Window的类型，有三种，分别是应用Window，子Window和系统Window。</p>
<p>应用window对应着一个Activity，子window不能独立存在，需要附属在特定的父window之上，比如Dialog就是子window。系统window是需要声明权限才能创建的window，比如Toast和系统状态栏这些都是系统window，需要声明的权限是。</p>
<p>(4). window是分层的，每个window都对应着z-ordered，层级大的会覆盖在层级小的上面，应用window的层级范围是1~99，子window的层级范围是1000~1999，系统window的层级范围是2000~2999。<br>[注意，应用window的层级范围并不是1~999哟]</p>
<p>(5).WindowManager继承自ViewManager，常用的只有三个方法：addView、updateView和removeView。</p>
<h2 id="Window的内部机制"><a href="#Window的内部机制" class="headerlink" title="Window的内部机制"></a>Window的内部机制</h2><p>(1).Window是一个抽象的概念，不是实际存在的，它也是以View的形式存在。在实际使用中无法直接访问Window，只能通过WindowManager才能访问Window。每个Window都对应着一个View和一个ViewRootImpl，Window和View通过ViewRootImpl来建立联系。</p>
<p>(2). Window的添加、删除和更新过程都是IPC过程，以Window的添加为例，WindowManager的实现类对于addView、updateView和removeView方法都是委托给WindowManagerGlobal类，该类保存了很多数据列表，例如所有window对应的view集合mViews、所有window对应的ViewRootImpl的集合mRoots等，之后添加操作交给了ViewRootImpl来处理，接着会通过WindowSession来完成Window的添加过程，这个过程是一个IPC调用，因为最终是通过WindowManagerService来完成window的添加的。</p>
<h2 id="Window的添加过程"><a href="#Window的添加过程" class="headerlink" title="Window的添加过程"></a>Window的添加过程</h2><p>(1)Activity的window创建过程</p>
<p>1.Activity的启动过程很复杂，最终会由ActivityThread中的performLaunchActivity来完成整个启动过程，在这个方法内部会通过类加载器创建Activity的实例对象，并调用它的attach方法为其关联运行过程中所依赖的一系列上下文环境变量；</p>
<p>2.Activity实现了Window的Callback接口，当window接收到外界的状态变化时就会回调Activity的方法，例如onAttachedToWindow、onDetachedFromWindow、dispatchTouchEvent等；</p>
<p>3.Activity的Window是由PolicyManager来创建的，它的真正实现是Policy类，它会新建一个PhoneWindow对象，Activity的setContentView的实现是由PhoneWindow来实现的；</p>
<p>4.Activity的顶级View是DecorView，它本质上是一个FrameLayout。如果没有DecorView，那么PhoneWindow会先创建一个DecorView，然后加载具体的布局文件并将view添加到DecorView的mContentParent中，最后就是回调Activity的onContentChanged通知Activity视图已经发生了变化；</p>
<p>5.还有一个步骤是让WindowManager能够识别DecorView，在ActivityThread调用handleResumeActivity方法时，首先会调用Activity的onResume方法，然后会调用makeVisible方法，这个方法中DecorView真正地完成了添加和显示过程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ViewManager vm = getWindowManager();</div><div class="line">vm.addView(mDecor, getWindow().getAttributes());</div><div class="line">mWindowAdded = true;</div></pre></td></tr></table></figure>
<p>(2)Dialog的Window创建过程</p>
<p>1.过程与Activity的Window创建过程类似，普通的Dialog的有一个特别之处，即它必须采用Activity的Context，如果采用Application的Context会报错。原因是Application没有应用token，应用token一般是Activity拥有的。</p>
<p>(3)Toast的Window创建过程</p>
<p>1.Toast属于系统Window，它内部的视图由两种方式指定：一种是系统默认的演示；另一种是通过setView方法来指定一个自定义的View。</p>
<p>2.Toast具有定时取消功能，所以系统采用了Handler。Toast的显示和隐藏是IPC过程，都需要NotificationManagerService来实现。在Toast和NMS进行IPC过程时，NMS会跨进程回调Toast中的TN类中的方法，TN类是一个Binder类，运行在Binder线程池中，所以需要通过Handler将其切换到当前发送Toast请求所在的线程，所以Toast无法在没有Looper的线程中弹出。</p>
<p>3.对于非系统应用来说，mToastQueue最多能同时存在50个ToastRecord，这样做是为了防止DOS(Denial of Service，拒绝服务)。因为如果某个应用弹出太多的Toast会导致其他应用没有机会弹出Toast。</p>
<hr>
<p>未经许可不得转载，转载请注明zilianliuxue的blog,本人保留所有版权。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Window是一个窗口的概念，是一个抽象类，具体实现是PhoneWindow。&lt;br&gt;通过WindowManager来创建Window。&lt;br&gt;Window的具体实现位于WindowManagerService，WindowsManager和Win
    
    </summary>
    
      <category term="android" scheme="http://zilianliuxue.github.io/categories/android/"/>
    
    
      <category term="window" scheme="http://zilianliuxue.github.io/tags/window/"/>
    
  </entry>
  
  <entry>
    <title>ContentProvider的工作过程</title>
    <link href="http://zilianliuxue.github.io/2016/08/26/ContentProvider%E7%9A%84%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B/"/>
    <id>http://zilianliuxue.github.io/2016/08/26/ContentProvider的工作过程/</id>
    <published>2016-08-26T06:33:12.568Z</published>
    <updated>2016-08-26T06:38:38.456Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>ContentProvider是一种内容共享性组件，它通过Binder向其他组件乃至其他应用提供数据。</p>
</blockquote>
<p>首先来看一下流程图：</p>
<p><img src="https://imuhao.github.io/image/androidart_contentprovider.png" alt="img"></p>
<p>一个应用的入口方法为ActivityThread的main方法，该方法是一个静态方法，在main方法中会创建ActivityThread的实例并创建主线程的消息队列，然后在ActivityThread的attach方法中会远程调用AMS的attachApplication方法并将ApplicationThread对象提供给AMS，ApplicationThread是一个Binder对象，它的接口是IApplicattionThread，它主要用于ActivityThread和AMS之间通信。</p>
<p>访问ContentProvider需要通过ContentResolver，它是一个抽象类，通过Context的getContentResolver方法获取的实际上是ApplicationContentResolver对象，该类继承了ContentResolver并实现了ContentResolver中的抽象方法。通过ContentProvider的四个方法中任何一个都可以触发ContentProvider的启动。这里选择query方法。</p>
<p>ContentProvider的query方法首先会获取IContentProvider对象，最终会通过ApplicationContentResolver的acquireProvider方法，该方法没有做任何逻辑，直接调用了ActivityThread的acquireExistingProvider方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">public final IContentProvider acquireProvider(</div><div class="line">        Context c, String auth, int userId, boolean stable) &#123;</div><div class="line">    final IContentProvider provider = acquireExistingProvider(c, auth, userId, stable);</div><div class="line">    if (provider != null) &#123;</div><div class="line">        return provider;</div><div class="line">    &#125;</div><div class="line">    IActivityManager.ContentProviderHolder holder = null;</div><div class="line">    try &#123;</div><div class="line">        holder = ActivityManagerNative.getDefault().getContentProvider(</div><div class="line">                getApplicationThread(), auth, userId, stable);</div><div class="line">    &#125; catch (RemoteException ex) &#123;</div><div class="line">    &#125;</div><div class="line">    if (holder == null) &#123;</div><div class="line">        Slog.e(TAG, &quot;Failed to find provider info for &quot; + auth);</div><div class="line">        return null;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // Install provider will increment the reference count for us, and break</div><div class="line">    // any ties in the race.</div><div class="line">    holder = installProvider(c, holder, holder.info,</div><div class="line">            true /*noisy*/, holder.noReleaseNeeded, stable);</div><div class="line">    return holder.provider;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面代码中首先会从ActivityThread中查找是否已经存在ContentProvider，如果存在就直接返回，ActivityThread中通过mProviderMap来存储已经启动的ContentProvider对象，该容器的声明如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">final ArrayMap&lt;ProviderKey, ProviderClientRecord&gt; mProviderMap= new ArrayMap&lt;ProviderKey, ProviderClientRecord&gt;();</div></pre></td></tr></table></figure>
<p>如果不存在就发送一个进程间请求给AMS让其启动，再通过installProvider方法来修改引用计数。<br>AMS是通过startProcessLocked方法来完成进程的启动，内部主要通过Process的start方法来完成进程的启动，新进程启动后的入口方法为ActivityThread的main方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">public static void main(String[] args) &#123;</div><div class="line"></div><div class="line">       ActivityThread thread = new ActivityThread();</div><div class="line">       thread.attach(false);</div><div class="line"></div><div class="line">       if (sMainThreadHandler == null) &#123;</div><div class="line">           sMainThreadHandler = thread.getHandler();</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       if (false) &#123;</div><div class="line">           Looper.myLooper().setMessageLogging(new</div><div class="line">                   LogPrinter(Log.DEBUG, &quot;ActivityThread&quot;));</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       // End of event ActivityThreadMain.</div><div class="line">       Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</div><div class="line">       Looper.loop();</div><div class="line"></div><div class="line">       throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>在该方法中首先会调用ActivityThread的实例并调用attach方法进行初始化，然后进行消息循环，attach方法会将ApplicationThread对象通过AMS的attachApplication方法跨进程传给AMS，最终完成Contentprovider的创建。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">try &#123;</div><div class="line">                mgr.releaseSomeActivities(mAppThread);</div><div class="line">            &#125; catch (RemoteException e) &#123;</div><div class="line">            &#125;</div></pre></td></tr></table></figure>
<p>APS的attachApplication方法调用了attachApplicationLocked方法，该方法又调用了ApplicationThread的bindApplication方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">thread.bindApplication(processName, appInfo, providers, app.instrumentationClass,</div><div class="line">        profilerInfo, app.instrumentationArguments, app.instrumentationWatcher,</div><div class="line">        app.instrumentationUiAutomationConnection, testMode, enableOpenGlTrace,</div><div class="line">        isRestrictedBackupMode || !normalMode, app.persistent,</div><div class="line">        new Configuration(mConfiguration), app.compat,</div><div class="line">        getCommonServicesLocked(app.isolated),</div><div class="line">        mCoreSettingsObserver.getCoreSettingsLocked());</div></pre></td></tr></table></figure>
<p>ApplicationThread的bindApplication方法发送一个BIND_APPLICATION类型定位消息给mH，mH收到消息后会调用ActivityThread的handleBindApplication方法，该方法就完成了Application的创建以及Contentprovider的创建，可以分为四步：</p>
<p>1 创建ContextImpl和Instrumentation</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">ContextImpl instrContext = ContextImpl.createAppContext(this, pi);</div><div class="line"></div><div class="line">try &#123;</div><div class="line">    java.lang.ClassLoader cl = instrContext.getClassLoader();</div><div class="line">    mInstrumentation = (Instrumentation)</div><div class="line">        cl.loadClass(data.instrumentationName.getClassName()).newInstance();</div><div class="line">&#125; catch (Exception e) &#123;</div><div class="line">    throw new RuntimeException(</div><div class="line">        &quot;Unable to instantiate instrumentation &quot;</div><div class="line">        + data.instrumentationName + &quot;: &quot; + e.toString(), e);</div><div class="line">&#125;</div><div class="line"></div><div class="line">mInstrumentation.init(this, instrContext, appContext,</div><div class="line">       new ComponentName(ii.packageName, ii.name), data.instrumentationWatcher,</div><div class="line">       data.instrumentationUiAutomationConnection);</div></pre></td></tr></table></figure>
<p>2 创建Application对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Application app = data.info.makeApplication(data.restrictedBackupMode, null);</div><div class="line">mInitialApplication = app;</div></pre></td></tr></table></figure>
<p>3 启动当前进程的ContentProvider并调用其中onCreate方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">List&lt;ProviderInfo&gt; providers = data.providers;</div><div class="line">if (providers != null) &#123;</div><div class="line">    installContentProviders(app, providers);</div><div class="line">    // For process that contains content providers, we want to</div><div class="line">    // ensure that the JIT is enabled &quot;at some point&quot;.</div><div class="line">    mH.sendEmptyMessageDelayed(H.ENABLE_JIT, 10*1000);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>installContentProviders完成的ContentProvider的启动工作,首先会遍历当前进程的ProviderInfo的列表，并一一调用installProvider方法来启动他们，然后将启动的ContentProvider发布到AMS中，AMS会把他们存储在ProviderMap中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">private void installContentProviders(</div><div class="line">    Context context, List&lt;ProviderInfo&gt; providers) &#123;</div><div class="line">final ArrayList&lt;IActivityManager.ContentProviderHolder&gt; results =</div><div class="line">    new ArrayList&lt;IActivityManager.ContentProviderHolder&gt;();</div><div class="line"></div><div class="line">for (ProviderInfo cpi : providers) &#123;</div><div class="line">    if (DEBUG_PROVIDER) &#123;</div><div class="line">        StringBuilder buf = new StringBuilder(128);</div><div class="line">        buf.append(&quot;Pub &quot;);</div><div class="line">        buf.append(cpi.authority);</div><div class="line">        buf.append(&quot;: &quot;);</div><div class="line">        buf.append(cpi.name);</div><div class="line">        Log.i(TAG, buf.toString());</div><div class="line">    &#125;</div><div class="line">    IActivityManager.ContentProviderHolder cph = installProvider(context, null, cpi,</div><div class="line">            false /*noisy*/, true /*noReleaseNeeded*/, true /*stable*/);</div><div class="line">    if (cph != null) &#123;</div><div class="line">        cph.noReleaseNeeded = true;</div><div class="line">        results.add(cph);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">try &#123;</div><div class="line">    ActivityManagerNative.getDefault().publishContentProviders(</div><div class="line">        getApplicationThread(), results);</div><div class="line">&#125; catch (RemoteException ex) &#123;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面来看一下COntentProvider对象的创建过程，在installProvider方法中有下面一段代码，通过类加载器完成对象创建</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">final java.lang.ClassLoader cl = c.getClassLoader();</div><div class="line">localProvider = (ContentProvider)cl.</div><div class="line">    loadClass(info.name).newInstance();</div><div class="line">provider = localProvider.getIContentProvider();</div><div class="line">if (provider == null) &#123;</div><div class="line">    Slog.e(TAG, &quot;Failed to instantiate class &quot; +</div><div class="line">          info.name + &quot; from sourceDir &quot; +</div><div class="line">          info.applicationInfo.sourceDir);</div><div class="line">    return null;</div><div class="line">&#125;</div><div class="line">if (DEBUG_PROVIDER) Slog.v(</div><div class="line">    TAG, &quot;Instantiating local provider &quot; + info.name);</div><div class="line">// XXX Need to create the correct context for this provider.</div><div class="line">localProvider.attachInfo(c, info);</div></pre></td></tr></table></figure>
<p>上面代码还会调用COntentProvider的attachInfo方法来调用他的onCreate方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">private void attachInfo(Context context, ProviderInfo info, boolean testing) &#123;</div><div class="line">    mNoPerms = testing;</div><div class="line"></div><div class="line">    if (mContext == null) &#123;</div><div class="line">        mContext = context;</div><div class="line">        if (context != null) &#123;</div><div class="line">            mTransport.mAppOpsManager = (AppOpsManager) context.getSystemService(</div><div class="line">                    Context.APP_OPS_SERVICE);</div><div class="line">        &#125;</div><div class="line">        mMyUid = Process.myUid();</div><div class="line">        if (info != null) &#123;</div><div class="line">            setReadPermission(info.readPermission);</div><div class="line">            setWritePermission(info.writePermission);</div><div class="line">            setPathPermissions(info.pathPermissions);</div><div class="line">            mExported = info.exported;</div><div class="line">            mSingleUser = (info.flags &amp; ProviderInfo.FLAG_SINGLE_USER) != 0;</div><div class="line">            setAuthorities(info.authority);</div><div class="line">        &#125;</div><div class="line">        ContentProvider.this.onCreate();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>到此为止onCreate方法已经被调用，意味着ContentProvider已经启动完成。</p>
<p>4 调用Application的onCreate方法</p>
<p>经过上面四个步骤，ContentPorovider已经成功启动，然后其他应用就可通过AMS来访问这个ContentProvider，拿到该对象之后就可以通过它所提供的接口来访问它了。</p>
<hr>
<p>未经许可不得转载，转载请注明zilianliuxue的blog,本人保留所有版权。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;ContentProvider是一种内容共享性组件，它通过Binder向其他组件乃至其他应用提供数据。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;首先来看一下流程图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imuhao.github.i
    
    </summary>
    
      <category term="android" scheme="http://zilianliuxue.github.io/categories/android/"/>
    
    
      <category term="ContentProvider" scheme="http://zilianliuxue.github.io/tags/ContentProvider/"/>
    
  </entry>
  
  <entry>
    <title>BroadcastReceiver 的工作过程</title>
    <link href="http://zilianliuxue.github.io/2016/08/26/BroadcastReceiver%E7%9A%84%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B/"/>
    <id>http://zilianliuxue.github.io/2016/08/26/BroadcastReceiver的工作过程/</id>
    <published>2016-08-26T06:31:57.830Z</published>
    <updated>2016-08-26T06:42:16.251Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>本文将介绍BroadcastReceiver的工作过程,主要包含两个方面的内容，一个是广播的注册过程，一个是广播的发送和接受过程。</p>
</blockquote>
<h2 id="广播的注册过程"><a href="#广播的注册过程" class="headerlink" title="广播的注册过程"></a>广播的注册过程</h2><p>首先看下流程图：</p>
<p><img src="https://imuhao.github.io/image/androidart_broadcastreceiver1.png" alt="img"></p>
<p>广播注册分为静态和动态注册，静态注册是由PMS（PackageManagerService）来实现的，除了广播其他三大组建都是应用安装时由PMS解析并注册的。<br>这里只分析广播的动态注册，动态注册过程是从ContextWrapper的registerReceiver方法开始的，ContextWrapper并没有实际工作，而是将注册交给了ContextImpl来完成。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public Intent registerReceiver(BroadcastReceiver receiver, IntentFilter filter) &#123;</div><div class="line">    return registerReceiver(receiver, filter, null, null);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ContextImpl调用自己的registerReceiverInternal方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">private Intent registerReceiverInternal(BroadcastReceiver receiver, int userId,</div><div class="line">            IntentFilter filter, String broadcastPermission,</div><div class="line">            Handler scheduler, Context context) &#123;</div><div class="line">        IIntentReceiver rd = null;</div><div class="line">        if (receiver != null) &#123;</div><div class="line">            if (mPackageInfo != null &amp;&amp; context != null) &#123;</div><div class="line">                if (scheduler == null) &#123;</div><div class="line">                    scheduler = mMainThread.getHandler();</div><div class="line">                &#125;</div><div class="line">                rd = mPackageInfo.getReceiverDispatcher(</div><div class="line">                    receiver, context, scheduler,</div><div class="line">                    mMainThread.getInstrumentation(), true);</div><div class="line">            &#125; else &#123;</div><div class="line">                if (scheduler == null) &#123;</div><div class="line">                    scheduler = mMainThread.getHandler();</div><div class="line">                &#125;</div><div class="line">                rd = new LoadedApk.ReceiverDispatcher(</div><div class="line">                        receiver, context, scheduler, null, true).getIIntentReceiver();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        try &#123;</div><div class="line">            return ActivityManagerNative.getDefault().registerReceiver(</div><div class="line">                    mMainThread.getApplicationThread(), mBasePackageName,</div><div class="line">                    rd, filter, broadcastPermission, userId);</div><div class="line">        &#125; catch (RemoteException e) &#123;</div><div class="line">            return null;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>在上面代码中系统从mPackageInfo中获取IIntentReceiver对象，然后采用跨进成的方式向AMS发送广播注册的请求，之所以采用IIntentReceiver是因为注册是一个进程间通信的过程，IIntentReceiver是一个Binder接口，他的具体实现是LoadedApk.ReceiverDispatcher内部类，该内部类同时保存了BroadcastReceivr和InnerReceiver，这样当接受到广播时，ReceiverDispatcher可以很方便的调用广播的onReceiver方法。</p>
<p>广播的真正实现过程是在AMS中的，AMS的registerReceiver的关键只有下面一部分，最终会把远程的InnerReceiver对象以及IntentFilter对象存储起来。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public Intent registerReceiver(IApplicationThread caller, String callerPackage,IIntentReceiver receiver, 、</div><div class="line">IntentFilter filter, String permission, int userId) </div><div class="line"></div><div class="line">mRegisteredReceivers.put(receiver.asBinder(), rl);</div><div class="line">BroadcastFilter bf = new BroadcastFilter(filter, rl, callerPackage,</div><div class="line">                permission, callingUid, userId);</div><div class="line"> rl.add(bf);</div><div class="line">        if (!bf.debugCheck()) &#123;</div><div class="line">            Slog.w(TAG, &quot;==&gt; For Dynamic broadcast&quot;);</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<p>这样整个广播的注册过程就完成了。</p>
<h2 id="广播的发送和接受过程"><a href="#广播的发送和接受过程" class="headerlink" title="广播的发送和接受过程"></a>广播的发送和接受过程</h2><p>流程图：</p>
<p><img src="https://imuhao.github.io/image/androidart_broadcastreceiver2.png" alt="img"></p>
<p>当通过send方法来发送广播时，AMS会查找出匹配的广播接受者并将广播发送给他们处理。<br>广播发送有几种类型：普通广播、有序广播、粘性广播。这里只分析普通广播的实现。</p>
<p>广播的发送开始于ContextImpl的sendBroadcast，源码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public void sendBroadcast(Intent intent) &#123;</div><div class="line">    warnIfCallingFromSystemProcess();</div><div class="line">    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());</div><div class="line">    try &#123;</div><div class="line">        intent.prepareToLeaveProcess();</div><div class="line">        ActivityManagerNative.getDefault().broadcastIntent(</div><div class="line">                mMainThread.getApplicationThread(), intent, resolvedType, null,</div><div class="line">                Activity.RESULT_OK, null, null, null, AppOpsManager.OP_NONE, null, false, false,</div><div class="line">                getUserId());</div><div class="line">    &#125; catch (RemoteException e) &#123;</div><div class="line">        throw new RuntimeException(&quot;Failure from system&quot;, e);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ContextImpl几乎什么都没干，直接向AMS发起一个异步请求发送广播。下面是AMS对广播发送过程的处理。AMS的broadcastIntent的方法源码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public final int broadcastIntent(IApplicationThread caller,Intent intent, String resolvedType, IIntentReceiver resultTo,int resultCode, String resultData, Bundle resultExtras,String[] requiredPermissions, int appOp, Bundle options, boolean serialized, boolean sticky, int userId) &#123;</div><div class="line"></div><div class="line">    enforceNotIsolatedCaller(&quot;broadcastIntent&quot;);</div><div class="line">    synchronized(this) &#123;</div><div class="line">        intent = verifyBroadcastLocked(intent);</div><div class="line"></div><div class="line">        final ProcessRecord callerApp = getRecordForAppLocked(caller);</div><div class="line">        final int callingPid = Binder.getCallingPid();</div><div class="line">        final int callingUid = Binder.getCallingUid();</div><div class="line">        final long origId = Binder.clearCallingIdentity();</div><div class="line">        int res = broadcastIntentLocked(callerApp,</div><div class="line">                callerApp != null ? callerApp.info.packageName : null,</div><div class="line">                intent, resolvedType, resultTo, resultCode, resultData, resultExtras,</div><div class="line">                requiredPermissions, appOp, null, serialized, sticky,</div><div class="line">                callingPid, callingUid, userId);</div><div class="line">        Binder.restoreCallingIdentity(origId);</div><div class="line">        return res;</div><div class="line">    &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>broadcastIntent方法又调用了broadcastIntentLocked方法。该方法的开始有这一行代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// By default broadcasts do not go to stopped apps.</div><div class="line">   intent.addFlags(Intent.FLAG_EXCLUDE_STOPPED_PACKAGES);</div></pre></td></tr></table></figure>
<p>这表示广播不会发送给已经停止的我应用，从Android3.1开始已经具有这种特性，这是因为在Android3.1中为Intent添加了两个标记，分别是FLAG_EXCLUDE_STOPPED_PACKAGES和FLAG_EXCLUDE_STOPPED_PACKAGES用来控制广播是否对停止应用起作用。</p>
<ul>
<li>FLAG <em>INCLUDE </em>STOPPED _ PACKAGES</li>
</ul>
<p>表示包含已经停止的应用，这个时候广播会发送给已经停止的应用</p>
<ul>
<li>FLAG <em>EXCLUDE </em>STOPPED _ PACKAGES</li>
</ul>
<p>表示不包含已经停止的应用，这个时候广播不会发送给已经停止的应用。</p>
<p>从3.1开始默认为所有广播添加了FLAG <em>EXCLUDE </em>STOPPED _ PACKAGES标志。</p>
<p>处于停止状态分为两种情形：</p>
<ol>
<li>应用安装后未运行</li>
<li>应用被手动或其他应用强停。</li>
</ol>
<p>从Android3.1开始处于停止状态的应用同样无法接收到开机广播。</p>
<p>在broadcastIntentLocked内部会根据intentfilter查找匹配的广播接受者，将满足条件的广播添加到BroadcastQueue中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">if ((receivers != null &amp;&amp; receivers.size() &gt; 0)</div><div class="line">                || resultTo != null) &#123;</div><div class="line">            BroadcastQueue queue = broadcastQueueForIntent(intent);</div><div class="line">            BroadcastRecord r = new BroadcastRecord(queue, intent, callerApp,</div><div class="line">                    callerPackage, callingPid, callingUid, resolvedType,</div><div class="line">                    requiredPermissions, appOp, brOptions, receivers, resultTo, resultCode,</div><div class="line">                    resultData, resultExtras, ordered, sticky, false, userId);</div><div class="line"></div><div class="line">            if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST, &quot;Enqueueing ordered broadcast &quot; + r</div><div class="line">                    + &quot;: prev had &quot; + queue.mOrderedBroadcasts.size());</div><div class="line">            if (DEBUG_BROADCAST) Slog.i(TAG_BROADCAST,</div><div class="line">                    &quot;Enqueueing broadcast &quot; + r.intent.getAction());</div><div class="line"></div><div class="line">            boolean replaced = replacePending &amp;&amp; queue.replaceOrderedBroadcastLocked(r);</div><div class="line">            if (!replaced) &#123;</div><div class="line">                queue.enqueueOrderedBroadcastLocked(r);</div><div class="line">                queue.scheduleBroadcastsLocked();</div><div class="line">            &#125;</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<p>接着我们来看BroadcastQueue的scheduleBroadcastsLocked方法实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public void scheduleBroadcastsLocked() &#123;</div><div class="line">       if (mBroadcastsScheduled) &#123;</div><div class="line">           return;</div><div class="line">       &#125;</div><div class="line">       mHandler.sendMessage(mHandler.obtainMessage(BROADCAST_INTENT_MSG, this));</div><div class="line">       mBroadcastsScheduled = true;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>该方法并没有立即发送广播，而是发送了一个BROADCAST_INTENT_MSG类型的消息。当BroadcastQueue收到消息之后会调用processNextBroadcast方法。该方法对普通广播的处理如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">while (mParallelBroadcasts.size() &gt; 0) &#123;</div><div class="line">    r = mParallelBroadcasts.remove(0);</div><div class="line">    r.dispatchTime = SystemClock.uptimeMillis();</div><div class="line">    r.dispatchClockTime = System.currentTimeMillis();</div><div class="line">    final int N = r.receivers.size();</div><div class="line">    if (DEBUG_BROADCAST_LIGHT) Slog.v(TAG_BROADCAST, &quot;Processing parallel broadcast [&quot;</div><div class="line">            + mQueueName + &quot;] &quot; + r);</div><div class="line">    for (int i=0; i&lt;N; i++) &#123;</div><div class="line">        Object target = r.receivers.get(i);</div><div class="line">        if (DEBUG_BROADCAST)  Slog.v(TAG_BROADCAST,</div><div class="line">                &quot;Delivering non-ordered on [&quot; + mQueueName + &quot;] to registered &quot;</div><div class="line">                + target + &quot;: &quot; + r);</div><div class="line">        deliverToRegisteredReceiverLocked(r, (BroadcastFilter)target, false);</div><div class="line">    &#125;</div><div class="line">    addBroadcastToHistoryLocked(r);</div><div class="line">    if (DEBUG_BROADCAST_LIGHT) Slog.v(TAG_BROADCAST, &quot;Done with parallel broadcast [&quot;</div><div class="line">            + mQueueName + &quot;] &quot; + r);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到无序广播存储在mParallelBroadcasts中，系统会遍历该集合并发送给他们的处理者，具体的发送过程是通过deliverToRegisteredReceiverLocked方法来实现，该方法将一个广播发送给一个特定的接受者，它的内部调用了performReceiveLocked方法来完成具体的发送过程，实现如下，由于广播会调起应用程序，因此app.thread不为空app.thread指ApplicationThread。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">private static void performReceiveLocked(ProcessRecord app, IIntentReceiver receiver,</div><div class="line">        Intent intent, int resultCode, String data, Bundle extras,</div><div class="line">        boolean ordered, boolean sticky, int sendingUser) throws RemoteException &#123;</div><div class="line">    // Send the intent to the receiver asynchronously using one-way binder calls.</div><div class="line">    if (app != null) &#123;</div><div class="line">        if (app.thread != null) &#123;</div><div class="line">            // If we have an app thread, do the call through that so it is</div><div class="line">            // correctly ordered with other one-way calls.</div><div class="line">            app.thread.scheduleRegisteredReceiver(receiver, intent, resultCode,</div><div class="line">                    data, extras, ordered, sticky, sendingUser, app.repProcState);</div><div class="line">        &#125; else &#123;</div><div class="line">            // Application has died. Receiver doesn&apos;t exist.</div><div class="line">            throw new RemoteException(&quot;app.thread must not be null&quot;);</div><div class="line">        &#125;</div><div class="line">    &#125; else &#123;</div><div class="line">        receiver.performReceive(intent, resultCode, data, extras, ordered,</div><div class="line">                sticky, sendingUser);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该方法会调用ApplicationThread的scheduleRegisteredReceiver，他的实现比较简单，通过InnerReceiver来实现广播的接受。InnerReceiver的performRecerver方法会调用LoadedApk.ReceiverDispatcher的performReceive方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">    public void performReceive(Intent intent, int resultCode, String data,</div><div class="line">            Bundle extras, boolean ordered, boolean sticky, int sendingUser) &#123;</div><div class="line">        Args args = new Args(intent, resultCode, data, extras, ordered,</div><div class="line">                sticky, sendingUser);</div><div class="line">        if (!mActivityThread.post(args)) &#123;</div><div class="line">            if (mRegistered &amp;&amp; ordered) &#123;</div><div class="line">                IActivityManager mgr = ActivityManagerNative.getDefault();</div><div class="line">                if (ActivityThread.DEBUG_BROADCAST) Slog.i(ActivityThread.TAG,</div><div class="line">                        &quot;Finishing sync broadcast to &quot; + mReceiver);</div><div class="line">                args.sendFinished(mgr);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在上面代码中会创建一个Args对象并通过mActivityThread的post方法来执行args中的逻辑，而args实现了Runnable接口。mActivityThread是一个Handler，它其实就是ActivityThread中的mH，mH的类型是ActivityThread的内部类H。在args的run方法中有如下几行代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">final BroadcastReceiver receiver = mReceiver;</div><div class="line">receiver.setPendingResult(this);</div><div class="line">receiver.onReceive(mContext, intent);</div></pre></td></tr></table></figure>
<p>很显然这个时候BroadcastReceiver的onReceiver方法被执行了，也就是说应用已经接收到广播。</p>
<p>到这里这个广播的注册，发送和接受过程已经分析完了，读者应该对广播的整个过程有了一定的理解。</p>
<hr>
<p>未经许可不得转载，转载请注明zilianliuxue的blog,本人保留所有版权。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文将介绍BroadcastReceiver的工作过程,主要包含两个方面的内容，一个是广播的注册过程，一个是广播的发送和接受过程。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;广播的注册过程&quot;&gt;&lt;a href=&quot;#广播的注册过程&quot; clas
    
    </summary>
    
      <category term="android" scheme="http://zilianliuxue.github.io/categories/android/"/>
    
    
      <category term="BroadcastReceiver" scheme="http://zilianliuxue.github.io/tags/BroadcastReceiver/"/>
    
  </entry>
  
  <entry>
    <title>Service 的工作过程</title>
    <link href="http://zilianliuxue.github.io/2016/08/26/Service%E7%9A%84%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B/"/>
    <id>http://zilianliuxue.github.io/2016/08/26/Service的工作过程/</id>
    <published>2016-08-26T06:30:49.319Z</published>
    <updated>2016-08-26T06:41:29.728Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">本文将介绍Service的工作过程,通过本文分析,你将会对Service的一些工作原理有更进一步的认识</div><div class="line">比如Service的启动过程和绑定过程.</div></pre></td></tr></table></figure>
<h3 id="Service有两种状态-一种是启动状态-主要用于执行后台计算-另一种是绑定状态-主要用于与其他组件进行交互-这两种状态是可以共存的"><a href="#Service有两种状态-一种是启动状态-主要用于执行后台计算-另一种是绑定状态-主要用于与其他组件进行交互-这两种状态是可以共存的" class="headerlink" title="Service有两种状态,一种是启动状态,主要用于执行后台计算,另一种是绑定状态,主要用于与其他组件进行交互.这两种状态是可以共存的."></a>Service有两种状态,一种是启动状态,主要用于执行后台计算,另一种是绑定状态,主要用于与其他组件进行交互.这两种状态是可以共存的.</h3><h2 id="Service的启动过程"><a href="#Service的启动过程" class="headerlink" title="Service的启动过程"></a>Service的启动过程</h2><p>启动过程流程图</p>
<p><img src="https://imuhao.github.io/image/androidart_service1.png" alt="img"></p>
<p>Service的启动过程从ContextWrapper的startService方法开始,如下所示</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public ComponentName startService(Intent service) &#123;</div><div class="line">       return mBase.startService(service);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>上面代码中的mBase的类型是ContextImpl,在Activity创建时会通过attach方法将ContextImpl对象关联起来,ContextWrapper的大部分操作都是mBase来实现的,这种模式叫桥接模式.<br>在ContextImpl中,startService方法会调用startServiceCommon方法,而该方法会用过ActivityManagerNative.getDefault()对象来启动一个服务,也就是AMS,在AMS来启动服务的行为是一个远程过程调用,在AMS中会通过mServices这个对象完成后续的启动过程,mService对象 的类型是ActivityService,他是辅助AMS进行Service管理的类.包括启动、绑定、停止等.在它的startServiceLocked方法最后会调用startServiceInnerLocked方法,在该方法中并没有完成具体的启动工作,而是把后续的工作交给了bringUpServiceLocked来处理,在该方法中又调用了realStartServiceLocked方法,通过方法名来看这个方法应该是真正启动一个Service.</p>
<p>在realStartServiceLocked方法中首先是通过app.thread的scheduleCreateService方法来调用Service的其他方法,比如onStartCommand,这两个过程均是进程通信.</p>
<p>app.thread是IApplicationThread类型,它实际上是一个Bunder,他的具体实现是ApplicationThread和ApplicationThreadNative,而前者是继承与后者的,所以我们直接看ApplicationThread对Service启动过程的处理即可.这对应着它的scheduleCreateService方法,这个过程和Activity的启动过程是类似的,都是通过发送消息给Handler H来完成Service的最终完成.</p>
<p>handlerCreateService方法主要做了这几件事</p>
<ol>
<li>首先通过类加载器创建Service的实例</li>
<li>创建Application对象并调用其onCreate方法.创建过程只会有一次</li>
<li>创建ConTextImpl对象并通过Service的attach方法建立二者的关系.</li>
<li>最后调用Service的onCreate方法并将Service对象存储到ActivityThread中的一个列表中.</li>
</ol>
<p>到这里Service的启动过程已经分析完了,下面分析Service的绑定过程.</p>
<h2 id="Service的绑定过程"><a href="#Service的绑定过程" class="headerlink" title="Service的绑定过程"></a>Service的绑定过程</h2><p>绑定流程图<br><img src="https://imuhao.github.io/image/androidart_service2.png" alt="img"><br>和Service启动过程一样,它的绑定过程也是从ContextWrapper开始的,如下所示.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public boolean bindService(Intent service, ServiceConnection conn,</div><div class="line">           int flags) &#123;</div><div class="line">       return mBase.bindService(service, conn, flags);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>mBase同样是ContextImpl类型的对象,mBase的bindService方法最终会调用自己的bindServiceCommon方法</p>
<p>bindServiceCommon方法主要完成如下两件事:</p>
<p>首先将客户端的ServiceConnection对象转化为ServiceDispatcher.IServiceConnection对象.之所以不能使用ServiceConnection对象是因为服务的绑定可能是跨进成的,因此ServiceConnection对象必须借助与Binder才能让远程服务端回调自己的方法,而ServiceDispatcher的内部类IServiceConnection刚好充当了Binder这个角色.ServiceConnection起着连接SercviceConnection和InnerConnection的作用,这个过程由LoadedApk的getServiceDispatcher方法来完成</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public final IServiceConnection getServiceDispatcher(ServiceConnection c,</div><div class="line">        Context context, Handler handler, int flags) &#123;</div><div class="line">    synchronized (mServices) &#123;</div><div class="line">        LoadedApk.ServiceDispatcher sd = null;</div><div class="line">        ArrayMap&lt;ServiceConnection, LoadedApk.ServiceDispatcher&gt; map = mServices.get(context);</div><div class="line">        if (map != null) &#123;</div><div class="line">            sd = map.get(c);</div><div class="line">        &#125;</div><div class="line">        if (sd == null) &#123;</div><div class="line">            sd = new ServiceDispatcher(c, context, handler, flags);</div><div class="line">            if (map == null) &#123;</div><div class="line">                map = new ArrayMap&lt;ServiceConnection, LoadedApk.ServiceDispatcher&gt;();</div><div class="line">                mServices.put(context, map);</div><div class="line">            &#125;</div><div class="line">            map.put(c, sd);</div><div class="line">        &#125; else &#123;</div><div class="line">            sd.validate(context, handler);</div><div class="line">        &#125;</div><div class="line">        return sd.getIServiceConnection();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在上面的代码中mServices是一个ArrayMap,它存储了一个应用当前活动的ServiceConnection和ServiceDispatcher的映射关系,它的定义如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">private final ArrayMap&lt;Context, ArrayMap&lt;ServiceConnection, LoadedApk.ServiceDispatcher&gt;&gt; mServices</div></pre></td></tr></table></figure>
<p>接着bindServiceCommon方法会通过AMS完成Service的具体绑定过程.对应着AMS的binService方法,而该方法在调用bindServiceLocked方法,bindServiceLocked方法又会调用bringUpServiceLocked方法,bringUpServiceLocked又会调用realStartServiceLocked方法,realStartServiceLocked的执行逻辑和启动的逻辑类似,都是通过ApplicationThread来完成Service的创建并执行onCreate方法</p>
<p>和启动Service不同的是,Service的绑定过程会调用app.thread的scheduleBindService方法,这个过程的实现在ActivityService的requestServiceBindingLocked方法,在该方法中调用了app.thread的scheduleBindService方法,他的内部都是通过Handler H中转的.</p>
<p>在H内部接收到BIND_SERVICE这类消息时,会交给ActivityThread’的handleBind-Service方法来处理.在该方法中会根据Service的token取出Service对象,然后调用onBind方法.onBind方法会返回一个Binder对象给客户端使用.原则上此时已经属于绑定状态了,但是onBind方法是Service的方法,这个时候客户端并不知道已经成功连接了,所以还必须调用客户端的ServiceConnection中的onServiceConected,这个过程由ActivityManagerNative.getDefault()的publishService方法来完成的.他其实就是AMS.</p>
<p>而AMS的publishService方法将具体的工作交给了ActivityServices类型的mServices对象来处理.在ActiveServices的publishServiceLocked方法核心代码只有一句</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">c.conn.connected(r.name, service);</div></pre></td></tr></table></figure>
<p>其中c的类型是ConnectionRecore.c.conn的类型是ServiceDispatcherInnerConnection.service就是Service的onBind方法返回的Binder对象. 从InnerConection的定义可以看出他的connected方法又调用了ServiceDispatcher的connected方法.</p>
<p>对于Service的绑定过程来说,ServiceDisptcher的mActivityThread是一个Handler,他就是ActivityThread中的H,这样一来RunConnection就可以经过H的post方法从而运行在主线程中,因此客户端ServiceConnection中的方法是在主线程中回调的.</p>
<p>客户端的onServiceConnected方法执行完毕之后,Service的绑定过程也就分析完成了.</p>
<hr>
<p>未经许可不得转载，转载请注明zilianliuxue的blog,本人保留所有版权。</p>
]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;c
    
    </summary>
    
      <category term="android" scheme="http://zilianliuxue.github.io/categories/android/"/>
    
    
      <category term="Service" scheme="http://zilianliuxue.github.io/tags/Service/"/>
    
  </entry>
  
  <entry>
    <title>Activity 的工作过程</title>
    <link href="http://zilianliuxue.github.io/2016/08/26/Activity%E7%9A%84%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B/"/>
    <id>http://zilianliuxue.github.io/2016/08/26/Activity的工作过程/</id>
    <published>2016-08-26T06:29:04.100Z</published>
    <updated>2016-08-26T06:43:49.173Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>Activity对于开发者来说最普通不过了,但是你有没有想过当我们看到一个Activity的之后系统内部到底是如何启动一个Activity的呢?比如新Activity对象是何时创建的?Activity的onCreate方法又是在何时被系统回调的呢?</p>
</blockquote>
<p>首先来看一下流程图:</p>
<p><img src="https://imuhao.github.io/image/androidart_activity.png" alt="img"></p>
<p>从Activity的startActivity()方法开始分析,有好几个重载方法,他们最终都会调用startActivityFriResult方法,在该方法中会执行Instrumentation的execStartActivity方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public ActivityResult execStartActivity(Context who, IBinder contextThread, IBinder token, Activity target,</div><div class="line">       Intent intent, int requestCode, Bundle options)</div><div class="line">           ....省略代码...</div><div class="line">int result = ActivityManagerNative.getDefault()</div><div class="line">.startActivity(whoThread, who.getBasePackageName(), intent, intent.resolveTypeIfNeeded</div><div class="line">(who.getContentResolver()),token, target != null ? target.mEmbeddedID : null,</div><div class="line">                   requestCode, 0, null, options);</div></pre></td></tr></table></figure>
<p>从代码中可以启动Activity真正的实现由ActivityManagerNative.getDefault()的startActivity方法来完成,ActivityManagerNative(下面简称AMS)继承自Binder接口,因此AMS也是一个Binder,因此他也是一个Binder,它是IActivityManager类型的Binder对象.因此Activity的启动过程又转移到了AMS中.</p>
<p>在AMS的startActivity中又转移到了ActivityStacjSupervisor的startActivityMayWait方法中.</p>
<p>在该方法中又调用了startActivityLocked方法,接着调用了startActivityUncheckedLocked方法,又调用了ActivityStack的resumeTopActivityLocked.</p>
<p>这个时候启动已经从ActivityStackSupervisor转移到了ActivityStack,resumeTopActivityLocked调用了resumeTopActivityLocked方法,resumeTopActivityLocked方法,又调用了ActivityStackSupervisor的startSpecificActivityLocked方法</p>
<p>在该方法中调用了realStartActivityLocked方法,在该方法中有这么一段代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">app.thread.scheduleLaunchActivity(new Intent(r.intent), r.appToken,</div><div class="line">System.identityHashCode(r), r.info, new Configuration(mService.mConfiguration),</div><div class="line">new Configuration(stack.mOverrideConfig), r.compat, r.launchedFromPackage,</div><div class="line">task.voiceInteractor, app.repProcState, r.icicle, r.persistentState, results,</div><div class="line">newIntents, !andResume, mService.isNextTransitionForward(), profilerInfo);</div></pre></td></tr></table></figure>
<p>这段代码很重要,其中app.thread的类型为IApplicationThread,他继承了IInterface接口,所以他是一个Binder类型的接口.该接口内部包含了大量的启动、停止Activity的接口,此外还包含了启动和停止服务的接口,IApplicationThread这个Binder接口的实现者完成了大量的Activity以及Service启动停止相关的功能.他的实现者就是ActivityThread中的内部类ApplicationThread,</p>
<p>ApplicationThread继承了ApplicationThreadNative,而ApplicationThreadNative则继承了Binder并实现了IApplicationThread接口.</p>
<p>在ApplicationThreadNative的内部,还有一个ApplicationThreadProxy这个类为AIDL文件自动生成的代理类,种种迹象表明ApplicationThreadNative就是IAppilicationthread的实现者,由于ApplicationThreadNative被系统定义为抽象类,所以ApplicationThread就成了IApplicationthread最终的实现者.</p>
<p>绕了一大圈,Activity的启动过程最终回到了ApplicationThread中,ApplicationThread通过scheduleLaunchActivity方式来启动Activity,在该方法中通过发送一个启动Activity的消息交由Handler处理,这个Handler有个简洁的名字H,在H对LAUNCH_ACTIVITY这个消息进行处理可以知道,Activity启动过程由ActivityThread的handleLaunchActivity方法来实现</p>
<p>在该方法中最终通过performLaunchActivity方法完成了Activity对象的创建和启动过程,并且ActivityThread通过handleResumeActivity方法来调用被启动Activity的onResume这一生命周期.</p>
<p>performLaunchActivity方法主要完成了如下几件事</p>
<ol>
<li>从ActivityClientRecord中获取待启动Activity的组建信息.</li>
<li>通过mInstrumentation的newActivity方法使用类加载器创建Activity对象</li>
<li>通过LoadedApk的makeApplication方法尝试创建Application对象</li>
<li>创建ContextImpl对象并通过Activity的attach方法来完成这些重要数据的初始化</li>
<li>调用Activity的onCreate方法<br>mInstrumentation.callActivityOnCreate(activity, r.state);</li>
</ol>
<p>至此Activity已经完成了启动过程</p>
<hr>
<p>未经许可不得转载，转载请注明zilianliuxue的blog,本人保留所有版权。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Activity对于开发者来说最普通不过了,但是你有没有想过当我们看到一个Activity的之后系统内部到底是如何启动一个Activity的呢?比如新Activity对象是何时创建的?Activity的onCreate方法又是在何时被系统回调的呢?
    
    </summary>
    
      <category term="android" scheme="http://zilianliuxue.github.io/categories/android/"/>
    
    
      <category term="activity" scheme="http://zilianliuxue.github.io/tags/activity/"/>
    
  </entry>
  
  <entry>
    <title>java 线程池</title>
    <link href="http://zilianliuxue.github.io/2016/08/25/java%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>http://zilianliuxue.github.io/2016/08/25/java线程池/</id>
    <published>2016-08-25T12:30:16.351Z</published>
    <updated>2016-08-26T06:36:04.716Z</updated>
    
    <content type="html"><![CDATA[<p>线程池：基本思想还是一种对象池的思想，开辟一块内存空间，里面存放了众多(未死亡)的线程，池中线程执行调度由池管理器来处理。当有线程任务时，从池中取一个，执行完成后线程对象归池，这样可以避免反复创建线程对象所带来的性能开销，节省了系统的资源。</p>
<h1 id="ExecutorService"><a href="#ExecutorService" class="headerlink" title="ExecutorService"></a><strong>ExecutorService</strong></h1><p>通过上述分析，我们知道了通过new Thread().start()方式创建线程去处理任务的弊端，而为了解决这些问题，Java为我们提供了ExecutorService线程池来优化和管理线程的使用</p>
<h2 id="使用线程池管理线程的优点"><a href="#使用线程池管理线程的优点" class="headerlink" title="使用线程池管理线程的优点"></a><strong>使用线程池管理线程的优点</strong></h2><blockquote>
<p>1、线程的创建和销毁由线程池维护，一个线程在完成任务后并不会立即销毁，而是由后续的任务复用这个线程，从而减少线程的创建和销毁，节约系统的开销</p>
<p>2、线程池旨在线程的复用，这就可以节约我们用以往的方式创建线程和销毁所消耗的时间，减少线程频繁调度的开销，从而节约系统资源，提高系统吞吐量</p>
<p>3、在执行大量异步任务时提高了性能</p>
<p>4、Java内置的一套ExecutorService线程池相关的api，可以更方便的控制线程的最大并发数、线程的定时任务、单线程的顺序执行等</p>
</blockquote>
<h2 id="ExecutorService简介"><a href="#ExecutorService简介" class="headerlink" title="ExecutorService简介"></a><strong>ExecutorService简介</strong></h2><p>通常来说我们说到线程池第一时间想到的就是它：ExecutorService，它是一个接口，其实如果要从真正意义上来说，它可以叫做线程池的服务，因为它提供了众多接口api来控制线程池中的线程，而真正意义上的线程池就是：ThreadPoolExecutor，它实现了ExecutorService接口，并封装了一系列的api使得它具有线程池的特性，其中包括工作队列、核心线程数、最大线程数等。</p>
<h3 id="线程池：ThreadPoolExecutor"><a href="#线程池：ThreadPoolExecutor" class="headerlink" title="线程池：ThreadPoolExecutor"></a><strong>线程池：ThreadPoolExecutor</strong></h3><p>既然线程池就是ThreadPoolExecutor，所以我们要创建一个线程池只需要new ThreadPoolExecutor(…);就可以创建一个线程池，而如果这样创建线程池的话，我们需要配置一堆东西，非常麻烦，我们可以看一下它的构造方法就知道了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public ThreadPoolExecutor(int corePoolSize,</div><div class="line">                              int maximumPoolSize,</div><div class="line">                              long keepAliveTime,</div><div class="line">                              TimeUnit unit,</div><div class="line">                              BlockingQueue&lt;Runnable&gt; workQueue,</div><div class="line">                              ThreadFactory threadFactory,</div><div class="line">                              RejectedExecutionHandler handler) &#123;...&#125;1234567</div></pre></td></tr></table></figure>
<p>所以，官方也不推荐使用这种方法来创建线程池，而是推荐使用<strong>Executors</strong>的工厂方法来创建线程池，<strong>Executors</strong>类是官方提供的一个工厂类，它里面封装好了众多功能不一样的线程池，从而使得我们创建线程池非常的简便，主要提供了如下五种功能不一样的线程池：</p>
<blockquote>
<p><strong>1、newFixedThreadPool() ：</strong><br>作用：该方法返回一个固定线程数量的线程池，该线程池中的线程数量始终不变，即不会再创建新的线程，也不会销毁已经创建好的线程，自始自终都是那几个固定的线程在工作，所以该线程池可以控制线程的最大并发数。<br>栗子：假如有一个新任务提交时，线程池中如果有空闲的线程则立即使用空闲线程来处理任务，如果没有，则会把这个新任务存在一个任务队列中，一旦有线程空闲了，则按FIFO方式处理任务队列中的任务。</p>
<p><strong>2、newCachedThreadPool() ：</strong><br>作用：该方法返回一个可以根据实际情况调整线程池中线程的数量的线程池。即该线程池中的线程数量不确定，是根据实际情况动态调整的。<br>栗子：假如该线程池中的所有线程都正在工作，而此时有新任务提交，那么将会创建新的线程去处理该任务，而此时假如之前有一些线程完成了任务，现在又有新任务提交，那么将不会创建新线程去处理，而是复用空闲的线程去处理新任务。那么此时有人有疑问了，那这样来说该线程池的线程岂不是会越集越多？其实并不会，因为线程池中的线程都有一个“保持活动时间”的参数，通过配置它，如果线程池中的空闲线程的空闲时间超过该“保存活动时间”则立刻停止该线程，而该线程池默认的“保持活动时间”为60s。</p>
<p><strong>3、newSingleThreadExecutor() ：</strong><br>作用：该方法返回一个只有一个线程的线程池，即每次只能执行一个线程任务，多余的任务会保存到一个任务队列中，等待这一个线程空闲，当这个线程空闲了再按FIFO方式顺序执行任务队列中的任务。</p>
<p><strong>4、newScheduledThreadPool() ：</strong><br>作用：该方法返回一个可以控制线程池内线程定时或周期性执行某任务的线程池。</p>
<p><strong>5、newSingleThreadScheduledExecutor() ：</strong><br>作用：该方法返回一个可以控制线程池内线程定时或周期性执行某任务的线程池。只不过和上面的区别是该线程池大小为1，而上面的可以指定线程池的大小。</p>
</blockquote>
<p>好了，写了一堆来介绍这五种线程池的作用，接下来就是获取这五种线程池，通过<strong>Executors</strong>的工厂方法来获取：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ExecutorService fixedThreadPool = Executors.newFixedThreadPool(5);</div><div class="line">ExecutorService singleThreadPool = Executors.newSingleThreadExecutor();</div><div class="line">ExecutorService cachedThreadPool = Executors.newCachedThreadPool();</div><div class="line">ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(5);</div><div class="line">ScheduledExecutorService singleThreadScheduledPool = Executors.newSingleThreadScheduledExecutor();12345</div></pre></td></tr></table></figure>
<p>Executors 提供四种线程池：</p>
<ul>
<li>1）newCachedThreadPool 是一个可根据需要创建新线程的线程池，但是在以前构造的线程可用时将重用它们。对于执行很多短期异步任务的程序而言，这些线程池通常可提高程序性能。调用 execute() 将重用以前构造的线程（如果线程可用）。如果现有线程没有可用的，则创建一个新线程并添加到池中。终止并从缓存中移除那些已有 60 秒钟未被使用的线程。因此，长时间保持空闲的线程池不会使用任何资源。注意，可以使用 ThreadPoolExecutor 构造方法创建具有类似属性但细节不同（例如超时参数）的线程池。</li>
<li>2）newSingleThreadExecutor 创建是一个单线程池，也就是该线程池只有一个线程在工作，所有的任务是串行执行的，如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它，此线程池保证所有任务的执行顺序按照任务的提交顺序执行。</li>
<li>3）newFixedThreadPool 创建固定大小的线程池，每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小，线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。</li>
<li>4）newScheduledThreadPool 创建一个大小无限的线程池，此线程池支持定时以及周期性执行任务的需求。</li>
</ul>
<p>我们可以看到通过<strong>Executors</strong>的工厂方法来创建线程池极其简便，其实它的内部还是通过new ThreadPoolExecutor(…)的方式创建线程池的，我们看一下这些工厂方法的内部实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public static ExecutorService newFixedThreadPool(int nThreads) &#123;</div><div class="line">    return new ThreadPoolExecutor(nThreads, nThreads,</div><div class="line">                                  0L, TimeUnit.MILLISECONDS,</div><div class="line">                                  new LinkedBlockingQueue&lt;Runnable&gt;());</div><div class="line">&#125;</div><div class="line">public static ExecutorService newSingleThreadExecutor() &#123;</div><div class="line">    return new FinalizableDelegatedExecutorService</div><div class="line">        (new ThreadPoolExecutor(1, 1,</div><div class="line">                                0L, TimeUnit.MILLISECONDS,</div><div class="line">                                new LinkedBlockingQueue&lt;Runnable&gt;()));</div><div class="line">&#125;</div><div class="line">public static ExecutorService newCachedThreadPool() &#123;</div><div class="line">    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,</div><div class="line">                                  60L, TimeUnit.SECONDS,</div><div class="line">                                  new SynchronousQueue&lt;Runnable&gt;());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们可以清楚的看到这些方法的内部实现都是通过创建一个ThreadPoolExecutor对象来创建的，正所谓万变不离其宗，所以我们要了解线程池还是得了解ThreadPoolExecutor这个线程池类，其中由于和定时任务相关的线程池比较特殊（newScheduledThreadPool()、newSingleThreadScheduledExecutor()），它们创建的线程池内部实现是由ScheduledThreadPoolExecutor这个类实现的，而ScheduledThreadPoolExecutor是继承于ThreadPoolExecutor扩展而成的，所以本质还是一样的，只不过多封装了一些定时任务相关的api</p>
<h4 id="再撸一撸概念"><a href="#再撸一撸概念" class="headerlink" title="再撸一撸概念"></a>再撸一撸概念</h4><p>Java里面线程池的顶级接口是 Executor，不过真正的线程池接口是 ExecutorService， ExecutorService 的默认实现是 ThreadPoolExecutor；普通类 Executors 里面调用的就是 ThreadPoolExecutor。</p>
<p>照例看一下各个接口的源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">public interface Executor &#123;</div><div class="line">	void execute(Runnable command);</div><div class="line">&#125;</div><div class="line"></div><div class="line">public interface ExecutorService extends Executor &#123;</div><div class="line">	void shutdown();</div><div class="line">	List&lt;Runnable&gt; shutdownNow();</div><div class="line">	</div><div class="line">	boolean isShutdown();</div><div class="line">	boolean isTerminated();</div><div class="line">	</div><div class="line">	&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task);</div><div class="line">	&lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result);</div><div class="line">	Future&lt;?&gt; submit(Runnable task);</div><div class="line">	...</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Executors &#123;</div><div class="line">	public static ExecutorService newCachedThreadPool() &#123;</div><div class="line">    		return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, </div><div class="line">    						new SynchronousQueue&lt;Runnable&gt;());</div><div class="line">	&#125;</div><div class="line">	...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面我创建的一个线程池：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ExecutorService pool = Executors.newCachedThreadPool();</div></pre></td></tr></table></figure>
<p>通过 ThreadPoolExecutor 的构造函数，撸一撸线程池相关参数的概念：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public ThreadPoolExecutor(int corePoolSize,</div><div class="line">                          int maximumPoolSize,</div><div class="line">                          long keepAliveTime,</div><div class="line">                          TimeUnit unit,</div><div class="line">                          BlockingQueue&lt;Runnable&gt; workQueue,</div><div class="line">                          ThreadFactory threadFactory) &#123;</div><div class="line">    this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, </div><div class="line">    	threadFactory, defaultHandler);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>1）corePoolSize：线程池的核心线程数，一般情况下不管有没有任务都会一直在线程池中一直存活，只有在 ThreadPoolExecutor 中的方法 allowCoreThreadTimeOut(boolean value) 设置为 true 时，闲置的核心线程会存在超时机制，如果在指定时间没有新任务来时，核心线程也会被终止，而这个时间间隔由第3个属性 keepAliveTime 指定。</li>
<li>2）maximumPoolSize：线程池所能容纳的最大线程数，当活动的线程数达到这个值后，后续的新任务将会被阻塞。</li>
<li>3）keepAliveTime：控制线程闲置时的超时时长，超过则终止该线程。一般情况下用于非核心线程，只有在 ThreadPoolExecutor 中的方法 allowCoreThreadTimeOut(boolean value) 设置为 true时，也作用于核心线程。</li>
<li>4）unit：用于指定 keepAliveTime 参数的时间单位，TimeUnit 是个 enum 枚举类型，常用的有：TimeUnit.HOURS(小时)、TimeUnit.MINUTES(分钟)、TimeUnit.SECONDS(秒) 和 TimeUnit.MILLISECONDS(毫秒)等。</li>
<li>5）workQueue：线程池的任务队列，通过线程池的 execute(Runnable command) 方法会将任务 Runnable 存储在队列中。</li>
<li>6）threadFactory：线程工厂，它是一个接口，用来为线程池创建新线程的。<br>上面的参数理解起来都比较简单，不过workQueue这个任务队列却要再次说明一下，它是一个<code>BlockingQueue</code>对象，而泛型则限定它是用来存放Runnable对象的，刚刚上面讲了，不同的线程池它的任务队列实现肯定是不一样的，所以，保证不同线程池有着不同的功能的核心就是这个workQueue的实现了，细心的会发现在刚刚的用来创建线程池的工厂方法中，针对不同的线程池传入的workQueue也不一样，下面我总结一下这五种线程池分别用的是什么BlockingQueue：</li>
</ul>
<blockquote>
<p>1、newFixedThreadPool()—&gt;LinkedBlockingQueue<br>2、newSingleThreadExecutor()—&gt;LinkedBlockingQueue<br>3、newCachedThreadPool()—&gt;SynchronousQueue<br>4、newScheduledThreadPool()—&gt;DelayedWorkQueue<br>5、newSingleThreadScheduledExecutor()—&gt;DelayedWorkQueue</p>
</blockquote>
<p>这些队列分别表示：</p>
<blockquote>
<p><strong>LinkedBlockingQueue</strong>：无界的队列<br><strong>SynchronousQueue</strong>：直接提交的队列<br><strong>DelayedWorkQueue</strong>：等待队列</p>
</blockquote>
<p>当然实现了BlockingQueue接口的队列还有：ArrayBlockingQueue（有界的队列）、PriorityBlockingQueue（优先级队列）。这些队列的详细作用就不多介绍了。</p>
<p>线程池的关闭</p>
<p>ThreadPoolExecutor 提供了两个方法，用于线程池的关闭，分别是 shutdown() 和 shutdownNow()。</p>
<p>shutdown()：不会立即的终止线程池，而是要等所有任务缓存队列中的任务都执行完后才终止，但再也不会接受新的任务。<br>shutdownNow()：立即终止线程池，并尝试打断正在执行的任务，并且清空任务缓存队列，返回尚未执行的任务。</p>
<h2 id="线程池ThreadPoolExecutor的使用"><a href="#线程池ThreadPoolExecutor的使用" class="headerlink" title="线程池ThreadPoolExecutor的使用"></a><strong>线程池ThreadPoolExecutor的使用</strong></h2><p>使用线程池，其中涉及到一个极其重要的方法，即：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">execute(Runnable command)</div></pre></td></tr></table></figure>
<p>该方法意为执行给定的任务，该任务处理可能在新的线程、已入池的线程或者正调用的线程，这由ThreadPoolExecutor的实现决定。<br><strong>newFixedThreadPool</strong><br>创建一个固定线程数量的线程池，示例为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">ExecutorService fixedThreadPool = Executors.newFixedThreadPool(3);</div><div class="line">for (int i = 1; i &lt;= 10; i++) &#123;</div><div class="line">    final int index = i;</div><div class="line">    fixedThreadPool.execute(new Runnable() &#123;</div><div class="line">         @Override</div><div class="line">         public void run() &#123;</div><div class="line">             String threadName = Thread.currentThread().getName();</div><div class="line">             Log.v(&quot;zxy&quot;, &quot;线程：&quot;+threadName+&quot;,正在执行第&quot; + index + &quot;个任务&quot;);</div><div class="line">             try &#123;</div><div class="line">                    Thread.sleep(2000);</div><div class="line">             &#125; catch (InterruptedException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">             &#125;</div><div class="line">         &#125;</div><div class="line">     &#125;);</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>上述代码，我们创建了一个线程数为3的固定线程数量的线程池，同理该线程池支持的线程最大并发数也是3，而我模拟了10个任务让它处理，执行的情况则是首先执行前三个任务，后面7个则依次进入任务队列进行等待，执行完前三个任务后，再通过FIFO的方式从任务队列中取任务执行，直到最后任务都执行完毕。<br>为了体现出线程的复用，我特地在Log中加上了当前线程的名称，效果为：<br><img src="http://img.blog.csdn.net/20151116182357008" alt="这里写图片描述"><br><strong>newSingleThreadExecutor</strong><br>创建一个只有一个线程的线程池，每次只能执行一个线程任务，多余的任务会保存到一个任务队列中，等待线程处理完再依次处理任务队列中的任务，示例为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">ExecutorService singleThreadPool = Executors.newSingleThreadExecutor();</div><div class="line">for (int i = 1; i &lt;= 10; i++) &#123;</div><div class="line">    final int index = i;</div><div class="line">    singleThreadPool.execute(new Runnable() &#123;</div><div class="line">        @Override</div><div class="line">        public void run() &#123;</div><div class="line">            String threadName = Thread.currentThread().getName();</div><div class="line">            Log.v(&quot;zxy&quot;, &quot;线程：&quot;+threadName+&quot;,正在执行第&quot; + index + &quot;个任务&quot;);</div><div class="line">            try &#123;</div><div class="line">                Thread.sleep(1000);</div><div class="line">            &#125; catch (InterruptedException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>代码还是差不多，只不过改了线程池的实现方式，效果我想大家都知道，即依次一个一个的处理任务，而且都是复用一个线程，效果为：<br><img src="http://img.blog.csdn.net/20151116182627850" alt="这里写图片描述"></p>
<p>其实我们通过newSingleThreadExecutor()和newFixedThreadPool()的方法发现，创建一个singleThreadExecutorPool实际上就是创建一个核心线程数和最大线程数都为1的fixedThreadPool。<br><strong>newCachedThreadPool</strong><br>创建一个可以根据实际情况调整线程池中线程的数量的线程池，示例为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">ExecutorService cachedThreadPool = Executors.newCachedThreadPool();</div><div class="line">for (int i = 1; i &lt;= 10; i++) &#123;</div><div class="line">    final int index = i;</div><div class="line">    try &#123;</div><div class="line">        Thread.sleep(1000);</div><div class="line">    &#125; catch (InterruptedException e) &#123;</div><div class="line">        e.printStackTrace();</div><div class="line">    &#125;</div><div class="line">    cachedThreadPool.execute(new Runnable() &#123;</div><div class="line">        @Override</div><div class="line">        public void run() &#123;</div><div class="line">            String threadName = Thread.currentThread().getName();</div><div class="line">            Log.v(&quot;zxy&quot;, &quot;线程：&quot; + threadName + &quot;,正在执行第&quot; + index + &quot;个任务&quot;);</div><div class="line">            try &#123;</div><div class="line">                long time = index * 500;</div><div class="line">                Thread.sleep(time);</div><div class="line">            &#125; catch (InterruptedException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>为了体现该线程池可以自动根据实现情况进行线程的重用，而不是一味的创建新的线程去处理任务，我设置了每隔1s去提交一个新任务，这个新任务执行的时间也是动态变化的，所以，效果为：<br><img src="http://img.blog.csdn.net/20151116184528454" alt="这里写图片描述"><br><strong>newScheduledThreadPool</strong><br>创建一个可以定时或者周期性执行任务的线程池，示例为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(3);</div><div class="line">//延迟2秒后执行该任务</div><div class="line">scheduledThreadPool.schedule(new Runnable() &#123;</div><div class="line">    @Override</div><div class="line">    public void run() &#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;, 2, TimeUnit.SECONDS);</div><div class="line">//延迟1秒后，每隔2秒执行一次该任务</div><div class="line">scheduledThreadPool.scheduleAtFixedRate(new Runnable() &#123;</div><div class="line">    @Override</div><div class="line">    public void run() &#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;, 1, 2, TimeUnit.SECONDS);123456789101112131415</div></pre></td></tr></table></figure>
<p><strong>newSingleThreadScheduledExecutor</strong><br>创建一个可以定时或者周期性执行任务的线程池，该线程池的线程数为1，示例为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">ScheduledExecutorService singleThreadScheduledPool = Executors.newSingleThreadScheduledExecutor();</div><div class="line">//延迟1秒后，每隔2秒执行一次该任务</div><div class="line">singleThreadScheduledPool.scheduleAtFixedRate(new Runnable() &#123;</div><div class="line">    @Override</div><div class="line">    public void run() &#123;</div><div class="line">        String threadName = Thread.currentThread().getName();</div><div class="line">        Log.v(&quot;zxy&quot;, &quot;线程：&quot; + threadName + &quot;,正在执行&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;,1,2,TimeUnit.SECONDS);123456789</div></pre></td></tr></table></figure>
<p>实际上这个和上面的没什么太大区别，只不过是线程池内线程数量的不同，效果为：<br><img src="http://img.blog.csdn.net/20151116194526184" alt="这里写图片描述"><br>每隔2秒就会执行一次该任务</p>
<h3 id="自定义线程池ThreadPoolExecutor"><a href="#自定义线程池ThreadPoolExecutor" class="headerlink" title="自定义线程池ThreadPoolExecutor"></a><strong>自定义线程池ThreadPoolExecutor</strong></h3><p>Java内置只为我们提供了五种常用的线程池，一般来说这足够用了，不过有时候我们也可以根据需求来自定义我们自己的线程池，而要自定义不同功能的线程池，上面我们也说了线程池功能的不同归根到底还是内部的BlockingQueue实现不同，所以，我们要实现我们自己相要的线程池，就必须从BlockingQueue的实现上做手脚，而上面也说了BlockingQueue的实现类有多个，那么这次我们就选用PriorityBlockingQueue来实现一个功能是按任务的优先级来处理的线程池。</p>
<h4 id="1、首先我们创建一个基于PriorityBlockingQueue实现的线程池，为了测试方便，我这里把核心线程数量设置为3，如下："><a href="#1、首先我们创建一个基于PriorityBlockingQueue实现的线程池，为了测试方便，我这里把核心线程数量设置为3，如下：" class="headerlink" title="1、首先我们创建一个基于PriorityBlockingQueue实现的线程池，为了测试方便，我这里把核心线程数量设置为3，如下："></a><strong>1、首先我们创建一个基于PriorityBlockingQueue实现的线程池，为了测试方便，我这里把核心线程数量设置为3，如下：</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ExecutorService priorityThreadPool = new ThreadPoolExecutor(3,3,0L,TimeUnit.SECONDS,new PriorityBlockingQueue&lt;Runnable&gt;());1</div></pre></td></tr></table></figure>
<h4 id="2、然后创建一个实现Runnable接口的类，并向外提供一个抽象方法供我们实现自定义功能，并实现Comparable接口，实现这个接口主要就是进行优先级的比较，代码如下："><a href="#2、然后创建一个实现Runnable接口的类，并向外提供一个抽象方法供我们实现自定义功能，并实现Comparable接口，实现这个接口主要就是进行优先级的比较，代码如下：" class="headerlink" title="2、然后创建一个实现Runnable接口的类，并向外提供一个抽象方法供我们实现自定义功能，并实现Comparable接口，实现这个接口主要就是进行优先级的比较，代码如下："></a><strong>2、然后创建一个实现Runnable接口的类，并向外提供一个抽象方法供我们实现自定义功能，并实现Comparable接口，实现这个接口主要就是进行优先级的比较，代码如下：</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">public abstract class PriorityRunnable implements Runnable, Comparable&lt;PriorityRunnable&gt; &#123;</div><div class="line">    private int priority;</div><div class="line"></div><div class="line">    public PriorityRunnable(int priority) &#123;</div><div class="line">        if (priority &lt; 0)</div><div class="line">            throw new IllegalArgumentException();</div><div class="line">        this.priority = priority;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public int compareTo(PriorityRunnable another) &#123;</div><div class="line">        int my = this.getPriority();</div><div class="line">        int other = another.getPriority();</div><div class="line">        return my &lt; other ? 1 : my &gt; other ? -1 : 0;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void run() &#123;</div><div class="line">        doSth();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public abstract void doSth();</div><div class="line"></div><div class="line">    public int getPriority() &#123;</div><div class="line">        return priority;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="3、使用我们自己的PriorityRunnable提交任务，整体代码如下："><a href="#3、使用我们自己的PriorityRunnable提交任务，整体代码如下：" class="headerlink" title="3、使用我们自己的PriorityRunnable提交任务，整体代码如下："></a><strong>3、使用我们自己的PriorityRunnable提交任务，整体代码如下：</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">ExecutorService priorityThreadPool = new ThreadPoolExecutor(3, 3, 0L, TimeUnit.SECONDS, new PriorityBlockingQueue&lt;Runnable&gt;());</div><div class="line">for (int i = 1; i &lt;= 10; i++) &#123;</div><div class="line">    final int priority = i;</div><div class="line">    priorityThreadPool.execute(new PriorityRunnable(priority) &#123;</div><div class="line">        @Override</div><div class="line">        public void doSth() &#123;</div><div class="line">            String threadName = Thread.currentThread().getName();</div><div class="line">            Log.v(&quot;zxy&quot;, &quot;线程：&quot; + threadName + &quot;,正在执行优先级为：&quot; + priority + &quot;的任务&quot;);</div><div class="line">            try &#123;</div><div class="line">                Thread.sleep(2000);</div><div class="line">            &#125; catch (InterruptedException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="测试效果"><a href="#测试效果" class="headerlink" title="测试效果"></a><strong>测试效果</strong></h4><p>我们看下刚刚自定义的线程池是否达到了我们想要的功能，即根据任务的优先级进行优先处理任务，效果如下：<br><img src="http://img.blog.csdn.net/20151116212159326" alt="这里写图片描述"></p>
<p>可以从执行结果中看出，由于核心线程数设置为3，刚开始时，系统有3个空闲线程，所以无须使用任务队列，而是直接运行前三个任务，而后面再提交任务时由于当前没有空闲线程所以加入任务队列中进行等待，此时，由于我们的任务队列实现是由PriorityBlockingQueue实现的，所以进行等待的任务会经过优先级判断，优先级高的放在队列前面先处理。从效果图中也可以看到后面的任务是先执行优先级高的任务，然后依次递减。</p>
<h4 id="优先级线程池的优点"><a href="#优先级线程池的优点" class="headerlink" title="优先级线程池的优点"></a><strong>优先级线程池的优点</strong></h4><p>从上面我们可以得知，创建一个优先级线程池非常有用，它可以在线程池中线程数量不足或系统资源紧张时，优先处理我们想要先处理的任务，而优先级低的则放到后面再处理，这极大改善了系统默认线程池以FIFO方式处理任务的不灵活</p>
<h3 id="扩展线程池ThreadPoolExecutor"><a href="#扩展线程池ThreadPoolExecutor" class="headerlink" title="扩展线程池ThreadPoolExecutor"></a><strong>扩展线程池ThreadPoolExecutor</strong></h3><p>除了内置的功能外，ThreadPoolExecutor也向外提供了三个接口供我们自己扩展满足我们需求的线程池，这三个接口分别是：</p>
<blockquote>
<p>beforeExecute() - 任务执行前执行的方法<br>afterExecute() -任务执行结束后执行的方法<br>terminated() -线程池关闭后执行的方法</p>
</blockquote>
<p>这三个方法在ThreadPoolExecutor内部都没有实现</p>
<p>前面两个方法我们可以在ThreadPoolExecutor内部的runWorker()方法中找到，而runWorker()是ThreadPoolExecutor的内部类Worker实现的方法，Worker它实现了Runnable接口，也正是线程池内处理任务的工作线程，而Worker.runWorker()方法则是处理我们所提交的任务的方法，它会同时被多个线程访问，所以我们看runWorker()方法的实现，由于涉及到多个线程的异步调用，必然是需要使用锁来处理，而这里使用的是Lock来实现的，我们来看看runWorker()方法内主要实现：<br><img src="http://img.blog.csdn.net/20151117141139792" alt="这里写图片描述"></p>
<p>可以看到在task.run()之前和之后分别调用了beforeExecute和afterExecute方法，并传入了我们的任务Runnable对象</p>
<p>而terminated()则是在关闭线程池的方法中调用，而关闭线程池有两个方法，我贴其中一个：<br><img src="http://img.blog.csdn.net/20151117141553421" alt="这里写图片描述"></p>
<p>所以，我们要扩展线程池，只需要重写这三个方法，并实现我们自己的功能即可，这三个方法分别都会在任务执行前调用、任务执行完成后调用、线程池关闭后调用。<br>这里我验证一下，继承自ThreadPoolExecutor 并实现那三个方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">public class MyThreadPoolExecutor extends ThreadPoolExecutor &#123;</div><div class="line">    public MyThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue) &#123;</div><div class="line">        super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void beforeExecute(Thread t, Runnable r) &#123;</div><div class="line">        super.beforeExecute(t, r);</div><div class="line">        String threadName = t.getName();</div><div class="line">        Log.v(&quot;zxy&quot;, &quot;线程：&quot; + threadName + &quot;准备执行任务！&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void afterExecute(Runnable r, Throwable t) &#123;</div><div class="line">        super.afterExecute(r, t);</div><div class="line">        String threadName = Thread.currentThread().getName();</div><div class="line">        Log.v(&quot;zxy&quot;, &quot;线程：&quot; + threadName + &quot;任务执行结束！&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void terminated() &#123;</div><div class="line">        super.terminated();</div><div class="line">        Log.v(&quot;zxy&quot;, &quot;线程池结束！&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>而运行后的结果则是，这正符合刚刚说的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">11-17 05:47:51.184 1602-1619/? V/zxy: 线程：pool-6-thread-1准备执行任务！</div><div class="line">11-17 05:47:51.184 1602-1619/? V/zxy: 线程：pool-6-thread-1正在执行任务！</div><div class="line">11-17 05:47:53.184 1602-1619/? V/zxy: 线程：pool-6-thread-1任务执行结束！</div><div class="line">11-17 05:47:58.896 1602-1619/? V/zxy: 线程池结束！1234</div></pre></td></tr></table></figure>
<p>所以，在上面我们的优先级线程池的代码上，我们再扩展一个具有暂停功能的优先级线程池，代码如下：<br>具有暂时功能的线程池：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">public class PausableThreadPoolExecutor extends ThreadPoolExecutor &#123;</div><div class="line">    private boolean isPaused;</div><div class="line">    private ReentrantLock pauseLock = new ReentrantLock();</div><div class="line">    private Condition unpaused = pauseLock.newCondition();</div><div class="line"></div><div class="line">    public PausableThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue) &#123;</div><div class="line">        super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void beforeExecute(Thread t, Runnable r) &#123;</div><div class="line">        super.beforeExecute(t, r);</div><div class="line">        pauseLock.lock();</div><div class="line">        try &#123;</div><div class="line">            while (isPaused) unpaused.await();</div><div class="line">        &#125; catch (InterruptedException ie) &#123;</div><div class="line">            t.interrupt();</div><div class="line">        &#125; finally &#123;</div><div class="line">            pauseLock.unlock();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void pause() &#123;</div><div class="line">        pauseLock.lock();</div><div class="line">        try &#123;</div><div class="line">            isPaused = true;</div><div class="line">        &#125; finally &#123;</div><div class="line">            pauseLock.unlock();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void resume() &#123;</div><div class="line">        pauseLock.lock();</div><div class="line">        try &#123;</div><div class="line">            isPaused = false;</div><div class="line">            unpaused.signalAll();</div><div class="line">        &#125; finally &#123;</div><div class="line">            pauseLock.unlock();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后结合上面的优先级线程池的实现，创建具有暂停功能的优先级线程池：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">PausableThreadPoolExecutor pausableThreadPoolExecutor = new PausableThreadPoolExecutor(1, 1, 0L, TimeUnit.SECONDS, new PriorityBlockingQueue&lt;Runnable&gt;());</div><div class="line">for (int i = 1; i &lt;= 100; i++) &#123;</div><div class="line">    final int priority = i;</div><div class="line">    pausableThreadPoolExecutor.execute(new PriorityRunnable(priority) &#123;</div><div class="line">        @Override</div><div class="line">        public void doSth() &#123;</div><div class="line">            runOnUiThread(new Runnable() &#123;</div><div class="line">                @Override</div><div class="line">                public void run() &#123;</div><div class="line">                    textView.setText(priority + &quot;&quot;);</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">            try &#123;</div><div class="line">                Thread.sleep(1000);</div><div class="line">            &#125; catch (InterruptedException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里我为了演示效果，把这个线程池设为只有一个线程，然后直接在TextView中显示当前执行的任务的优先级，然后设置个开关，控制线程池的暂停与开始：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">if (isPause) &#123;</div><div class="line">    pausableThreadPoolExecutor.resume();</div><div class="line">    isPause = false;</div><div class="line">&#125; else &#123;</div><div class="line">    pausableThreadPoolExecutor.pause();</div><div class="line">    isPause = true;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>效果为：<br><img src="http://img.blog.csdn.net/20151117144914201" alt="这里写图片描述"></p>
<p>从效果上来看，该线程池和优先级线程一样，而且还多了一个暂停与开始的功能</p>
<h3 id="优化线程池ThreadPoolExecutor"><a href="#优化线程池ThreadPoolExecutor" class="headerlink" title="优化线程池ThreadPoolExecutor"></a><strong>优化线程池ThreadPoolExecutor</strong></h3><p>虽说线程池极大改善了系统的性能，不过创建线程池也是需要资源的，所以线程池内线程数量的大小也会影响系统的性能，大了反而浪费资源，小了反而影响系统的吞吐量，所以我们创建线程池需要把握一个度才能合理的发挥它的优点，通常来说我们要考虑的因素有CPU的数量、内存的大小、并发请求的数量等因素，按需调整。</p>
<p>通常核心线程数可以设为CPU数量+1，而最大线程数可以设为CPU的数量*2+1。</p>
<p>获取CPU数量的方法为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Runtime.getRuntime().availableProcessors();1</div></pre></td></tr></table></figure>
<h3 id="shutdown-和shutdownNow-的区别"><a href="#shutdown-和shutdownNow-的区别" class="headerlink" title="shutdown()和shutdownNow()的区别"></a><strong>shutdown()和shutdownNow()的区别</strong></h3><p>关于线程池的停止，ExecutorService为我们提供了两个方法：shutdown和shutdownNow，这两个方法各有不同，可以根据实际需求方便的运用，如下：</p>
<blockquote>
<p>1、shutdown()方法在终止前允许执行以前提交的任务。<br>2、shutdownNow()方法则是阻止正在任务队列中等待任务的启动并试图停止当前正在执行的任务。</p>
</blockquote>
<h3 id="关于AsyncTask的实现"><a href="#关于AsyncTask的实现" class="headerlink" title="关于AsyncTask的实现"></a><strong>关于AsyncTask的实现</strong></h3><p>大家都知道AsyncTask内部实现其实就是Thread+Handler。其中Handler是为了处理线程之间的通信，而这个Thread到底是指什么呢？通过AsyncTask源码可以得知，其实这个Thread是线程池，AsyncTask内部实现了两个线程池，分别是：串行线程池和固定线程数量的线程池。而这个固定线程数量则是通过CPU的数量决定的。</p>
<p>在默认情况下，我们大都通过AsyncTask::execute()来执行任务的，<br>，而execute()内部则是调用executeOnExecutor(sDefaultExecutor, params)方法执行的，第一个参数就是指定处理该任务的线程池，而默认情况下AsyncTask是传入串行线程池（在这里不讲版本的变化），也就是任务只能单个的按顺序执行，而我们要是想让AsyncTask并行的处理任务，大家都知道调用AsyncTask::executeOnExecutor(sDefaultExecutor, params)方法传入这个参数即可：AsyncTask.THREAD_POOL_EXECUTOR。<br>而这个参数的意义在于为任务指定了一个固定线程数量的线程池去处理，从而达到了并行处理的功能，我们可以在源码中看到AsyncTask.THREAD_POOL_EXECUTOR这个参数就是一个固定线程数量的线程池：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public static final Executor THREAD_POOL_EXECUTOR</div><div class="line">        = new ThreadPoolExecutor(CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE,</div><div class="line">                TimeUnit.SECONDS, sPoolWorkQueue, sThreadFactory);</div></pre></td></tr></table></figure>
<h4 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h4><p>1）什么是 Executor 框架？</p>
<p>Executor框架在Java 5中被引入，Executor 框架是一个根据一组执行策略调用、调度、执行和控制的异步任务的框架。</p>
<p>无限制的创建线程会引起应用程序内存溢出，所以创建一个线程池是个更好的的解决方案，因为可以限制线程的数量并且可以回收再利用这些线程。利用 Executor 框架可以非常方便的创建一个线程池。</p>
<p>2）Executors 类是什么？</p>
<p>Executors为Executor、ExecutorService、ScheduledExecutorService、ThreadFactory 和 Callable 类提供了一些工具方法。Executors 可以用于方便的创建线程池。</p>
<hr>
<p>未经许可不得转载，转载请注明zilianliuxue的blog,本人保留所有版权。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;线程池：基本思想还是一种对象池的思想，开辟一块内存空间，里面存放了众多(未死亡)的线程，池中线程执行调度由池管理器来处理。当有线程任务时，从池中取一个，执行完成后线程对象归池，这样可以避免反复创建线程对象所带来的性能开销，节省了系统的资源。&lt;/p&gt;
&lt;h1 id=&quot;Exec
    
    </summary>
    
      <category term="java" scheme="http://zilianliuxue.github.io/categories/java/"/>
    
    
      <category term="线程池" scheme="http://zilianliuxue.github.io/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>Java-Android并发编程引气入门篇</title>
    <link href="http://zilianliuxue.github.io/2016/08/25/Java-Android%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%BC%95%E6%B0%94%E5%85%A5%E9%97%A8%E7%AF%87/"/>
    <id>http://zilianliuxue.github.io/2016/08/25/Java-Android并发编程引气入门篇/</id>
    <published>2016-08-25T08:04:00.000Z</published>
    <updated>2016-08-25T13:34:31.158Z</updated>
    
    <content type="html"><![CDATA[<p>转自<a href="http://abner-nimengbo.cn/" target="_blank" rel="external">Abner_泥阿布</a></p>
<p>Android的并发编程，即多线程开发，而Android的多线程开发模型也是源于Java中的多线程模型。<br>所以本篇也会先讲一些Java中的多线程理念，再讲解具体涉及的类，最后深入Android中的并发场景和实践。</p>
<h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><h3 id="什么是并发"><a href="#什么是并发" class="headerlink" title="什么是并发"></a>什么是并发</h3><p>举个很简单的栗子，当你一边在撸撸撸，一边在看小视频，同时在做两件事，这就是并发。</p>
<p>咳，年轻人节制啊。</p>
<p>并发的好处</p>
<p>提高资源利用率</p>
<p>当一个任务并没有完全占用系统资源，就可以利用并发来提高资源利用率，同时也能更快地完成任务。</p>
<p>当你的右手在干些什么的时候，左手是不是在没事做呢？那就也用起来呗。<br>(某次聚会，一名骑马的汉子说自己左右互搏(lu)特厉害）。</p>
<p>在程序任务上更加精简</p>
<p>就拿上一个栗子来说，左手做什么，右手做什么，任务明确分配好，又能同时进行，既提高了效率，逻辑又清晰。</p>
<p>更好的响应程序</p>
<p>这个拿Android客户端举个栗子，上传图片时，当前界面还是正常运转没有卡死，图片也正常上传，既保证了界面被响应，又保证图片可以上传。</p>
<h3 id="并发的风险"><a href="#并发的风险" class="headerlink" title="并发的风险"></a>并发的风险</h3><p>###　并发的代价</p>
<p>需要占用更多的资源。<br>设计好一个并发程序并不容易。<br>并发的资源交互问题复杂。<br>并发的隐患</p>
<p>滥用资源导致系统不稳定<br>结果与预期不符<br>出现BUG难以排查</p>
<h3 id="线程篇"><a href="#线程篇" class="headerlink" title="线程篇"></a>线程篇</h3><h3 id="进程是什么"><a href="#进程是什么" class="headerlink" title="进程是什么"></a>进程是什么</h3><p>就拿Android中的App来说，一般来说一个app就是一个进程，（除了特殊的手段开启了多个进程，这里不深入这个话题，就是一个一对多的关系）。</p>
<p>线程是什么</p>
<p>进程只是一个程序、任务的统称，但是却不能执行任务，真正执行任务的是线程，所以线程是由进程创建的，一个进程可以创建多个线程。</p>
<p>线程可以调度资源等等，在这里只需要了解大致的概念就好，如果要深入可以学习一下操作系统。</p>
<h3 id="进程与线程的关系"><a href="#进程与线程的关系" class="headerlink" title="进程与线程的关系"></a>进程与线程的关系</h3><p>人脑就相当于是CPU，想做一件事的时候，这个任务就是一个进程了，需要运用手脚等器官去完成这个任务，而手脚器官就可以理解成一个个线程，去做了不同的事，从而完成任务。</p>
<h3 id="单线程"><a href="#单线程" class="headerlink" title="单线程"></a>单线程</h3><p>还是用Android举栗子，当你在手机上操作的时候，这个被称之为UI线程（之后会详解）。而一个最基本的app，不需要复杂的功能时，就只有一个UI线程和我们交互，那么这个app就是个单线程的。一般的程序面向用户的线程就是UI线程，也称之为主线程，单线程程序，其实就是只有一个主线程的程序。</p>
<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><p>多个进程可以算是并发，但是我们所说的并发场景，大部分是在一个进程中的，而并发就是由线程完成的，多个线程同时执行任务，就称之为并发。</p>
<p>以下为多线程工作示意图：</p>
<p><img src="http://abner-nimengbo.cn/images/%E5%A4%9A%E7%BA%BF%E7%A8%8B.png" alt=""></p>
<h2 id="多线程并发过程中会遇到的问题"><a href="#多线程并发过程中会遇到的问题" class="headerlink" title="多线程并发过程中会遇到的问题"></a>多线程并发过程中会遇到的问题</h2><ol>
<li>资源共享</li>
</ol>
<p>A线程要写文件C，B线程也要写文件C，这个时候就好像你拿着两只笔同时往纸上写东西，写出来的是什么自己也不知道。</p>
<p>这个时候我们需要一个类似于锁的东西，当C被A在写的时候，B不能写，B要等A写完了才能继续写。</p>
<p>至于这个锁到底是什么会在后面继续讲到。</p>
<ol>
<li>死锁问题</li>
</ol>
<p>死锁的四个条件是：</p>
<ul>
<li>禁止抢占：no preemption</li>
</ul>
<ul>
<li>持有和等待：hold and wait</li>
</ul>
<ul>
<li>互斥：mutual exclusion</li>
</ul>
<ul>
<li>循环等待：circular waiting</li>
</ul>
<p>预防死锁就是至少破坏这四个条件其中一项，即破坏“禁止抢占”、破坏“持有等待”、破坏“资源互斥”和破坏“循环等待”。</p>
<p>举个例子：</p>
<p>A在B那边割包皮，B把A割坏了，A占着B的床位，要B赔钱，B要A让出床位才给钱。双方僵持不下。</p>
<h3 id="线程如何去用"><a href="#线程如何去用" class="headerlink" title="线程如何去用"></a>线程如何去用</h3><p>在Java中，线程通常就是指Thread这个类，或者实现了Runnable的类，其实Thread这个类也是实现了Runnable接口的，可以看一下Runnable接口的代码：</p>
<p><img src="http://abner-nimengbo.cn/images/runnable.png" alt=""></p>
<p>里面就是一个run方法需要被实现。</p>
<p>再看一下Thread类的声明：</p>
<p><img src="http://abner-nimengbo.cn/images/Thread.png" alt=""></p>
<p>确实是一个实现了Runnable的类。</p>
<p>那么Thread类中拥有start()方法，和run()方法，下面用run()方法直接调用<br>得到信息：</p>
<p><img src="http://abner-nimengbo.cn/images/threadRun.png" alt=""></p>
<p>发现其实和外面的线程是在同一个线程上。</p>
<p>而调用start()方法得到的信息是：</p>
<p><img src="http://abner-nimengbo.cn/images/threadStart.png" alt=""></p>
<p>发现线程名不一样了，用start会开启一个新的线程，而run还是在当前线程执行。</p>
<p>另外在Java1.5之后，还有Callable、Future和FutureTask，在这里就不详细介绍，还有线程的wait、<br>yield、sleep等在下一章会一起详细介绍。</p>
<h3 id="线程的优先级"><a href="#线程的优先级" class="headerlink" title="线程的优先级"></a>线程的优先级</h3><p>在Java中，线程的优先级有1~10，而默认的是5。1最低，10最高。在Thread类中有三个常量：</p>
<ul>
<li>MIN_PRIORITY = 1</li>
</ul>
<ul>
<li>NORM_PRIORITY = 5</li>
</ul>
<ul>
<li>MAX_PRIORITY = 10</li>
</ul>
<p>在同一个线程池中的线程优先级是相同的。</p>
<p>JVM会根据线程的优先级去抢先调度，然而线程的优先级只能保证抢占资源的概率较大，并不能保障线程的执行顺序，所以不能过于依赖设置线程的优先级。</p>
<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>频繁地创建和销毁线程会导致性能大幅度降低，这肯定不是你希望的。</p>
<p>线程池的出现，就是为了解决这个问题，根据java中提供不同的线程池机制，有效地提高资源利用率。</p>
<p>直接在代码中创建Thread、Runnable去start或者run容易出现不可预测的问题，在java1.5开始，引入了java.util.concurrent包，其中有个并发的框架：Executor，使用ExecutorService替代直接操作线程类，而Executors是用来创建线程池的，内部提供了很多静态方法去创建你想要的线程池，不需要你再手动去创建实现。<br>看一下关于Executor中的类和接口的大致的成员与关系：</p>
<p><img src="http://abner-nimengbo.cn/images/concurrent.png" alt=""></p>
<p>关于这些类如何使用，以及有什么特性，下一章会作介绍。</p>
<h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>在java中提到队列肯定会想起Queue,而线程队列用的是BlockingQueue,这是个接口，在concurrent包中有好几个类实现了这个接口。</p>
<p><img src="http://abner-nimengbo.cn/images/BlockingQueue.png" alt=""></p>
<p>介绍一下BlockingQueue常用的方法</p>
<p><img src="http://i.imgur.com/txrnQN4.png" alt=""></p>
<h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><p>在前面讲过死锁，死锁是由于使用不当引起的一种现象，而这里的锁是人工干预的，让并发按照你的意思走。</p>
<p>在java中的锁有synchonrized、Lock。锁的出现主要是为了解决线程安全问题。</p>
<p>关于线程的状态会在下一章讲锁的机制时候再讲，因为线程的状态会影响到锁。</p>
<p>线程安全的集合</p>
<p>因为多线程访问资源可能会造成数据不一致或者数据污染，而某些集合会用一些锁或者同步机制做了处理。</p>
<p>线程安全的集合有：HashTable、SynchronizedCollection、ConcurrentHashMap、Vector等。</p>
<p>线程安不安全的首要前提是在多线程访问同一个对象的情况下。</p>
<h3 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h3><blockquote>
<p>《Java并发编程实践》</p>
<p>《Thinking in Java》</p>
<p>baoyongzhang(鲍老师)</p>
<hr>
<p>未经许可不得转载，转载请注明zilianliuxue的blog,本人保留所有版权。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转自&lt;a href=&quot;http://abner-nimengbo.cn/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Abner_泥阿布&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Android的并发编程，即多线程开发，而Android的多线程开发模型也是源于Java中的多
    
    </summary>
    
      <category term="java" scheme="http://zilianliuxue.github.io/categories/java/"/>
    
    
      <category term="线程池" scheme="http://zilianliuxue.github.io/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>view事件机制21问21答</title>
    <link href="http://zilianliuxue.github.io/2016/08/23/View%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B621%E9%97%AE21%E7%AD%94/"/>
    <id>http://zilianliuxue.github.io/2016/08/23/View事件机制21问21答/</id>
    <published>2016-08-23T11:48:00.000Z</published>
    <updated>2016-08-25T12:43:53.720Z</updated>
    
    <content type="html"><![CDATA[<p>本文为转载的，作者希尔瓦娜斯女神</p>
<h1 id="Android-View事件机制"><a href="#Android-View事件机制" class="headerlink" title="Android View事件机制"></a>Android View事件机制</h1><p><strong>1.View的坐标参数 主要有哪些？分别有什么注意的要点？</strong></p>
<p>答：Left，Right，top,Bottom 注意这4个值其实就是 view 和 他的父控件的 相对坐标值。 并非是距离屏幕左上角的绝对值，这点要注意。</p>
<p>　此外，X和Y 其实也是相对于父控件的坐标值。 TranslationX,TranslationY 这2个值 默认都为0，是相对于父控件的左上角的偏移量。</p>
<p>　换算关系：</p>
<blockquote>
<p>　x=left+tranX,y=top+tranY.</p>
</blockquote>
<p>  很多人不理解，为什么事这样，其实就是View 如果有移动的话，比如平移这种，你们就要注意了，top和left 这种值 是不会变化的。</p>
<p>   无论你把view怎么拖动，但是 x,y,tranX,tranY 的值是随着拖动平移 而变化的。想明白这点 就行了。</p>
<p><strong>2.onTouchEvent和GestureDetector 在什么时候用哪个比较好？</strong></p>
<p>答：只有滑动需求的时候 就用前者，如果有双击等这种行为的时候 就用后者。</p>
<p><strong>3.Scroller 用来解决什么问题？</strong></p>
<p>答：view的scrollTo和scrollBy 滑动效果太差了，是瞬间完成。而scroller可以配合view的computeScroll 来完成 渐变的滑动效果。体验更好。</p>
<p><strong>4.ScrollTo和ScrollBy 有什么需要注意的？</strong></p>
<p>答：前者是绝对滑动，后者是相对滑动。滑动的是view的内容 而不是view本身。这很重要。比如textview 调用这2个方法  滑动的就是显示出来的字的内容。</p>
<p>一般而言 我们用scrollBy会比较多一些。传值的话 其实 记住几个法则就可以了。 右-左 x为正 否则x为负  上-下 y为负，否则y为正。</p>
<p>可以稍微看一下 这2个的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scrollTo</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (mScrollX != x || mScrollY != y) &#123;</div><div class="line"></div><div class="line">            <span class="keyword">int</span> oldX = mScrollX;</div><div class="line"></div><div class="line">            <span class="keyword">int</span> oldY = mScrollY;</div><div class="line"></div><div class="line">            mScrollX = x;</div><div class="line"></div><div class="line">            mScrollY = y;</div><div class="line"></div><div class="line">            invalidateParentCaches();</div><div class="line"></div><div class="line">            onScrollChanged(mScrollX, mScrollY, oldX, oldY);</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (!awakenScrollBars()) &#123;</div><div class="line"></div><div class="line">                postInvalidateOnAnimation();</div><div class="line"></div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scrollBy</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</div><div class="line"></div><div class="line">        scrollTo(mScrollX + x, mScrollY + y);</div><div class="line"></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>看到里面有2个变量 mScrollX 和mScrollY 这2个东西没，这2个单位的 值是像素，前者代表 view的左边缘和view内容左边缘的距离。 后者代表 view上边缘和view内容上边缘的距离。</p>
<p><strong>5.使用动画来实现view的滑动 有什么后果？</strong></p>
<p>答：实际上view动画 是对view的表面ui 也就是给用户呈现出的视觉效果 来做的移动，动画本身并不能移动view的真正位置。属性动画除外。动画播放结束以后，view最终还是会回到自己的位置的，。当然了你可以设置fillafter 属性 来让动画播放结束以后 view表象停留在 变化以后的位置。所以这会带来一个很严重的后果。比如你的button在屏幕的左边，你现在用个动画 并且设置了fillafter属性让他去了右边。你会发现 点击右边的button 没有click事件触发，但是点击左边的 却可以触发，原因就是右边的button 只是view的表象，真正的button 还在左边没有动过。你一定要这么做的话 可以提前在右边button移动后的位置放一个新的button，当你动画执行结束以后  把右边的enable 左边的让他gone就可以了。</p>
<p>这么做就可以规避上述问题。</p>
<p><strong>6.让view滑动总共有几种方式，分别要注意什么？都适用于那些场景？</strong></p>
<p>答：总共有三种：</p>
<p>a：scrollto，scrollby。这种是最简单的，但是只能滑动view的内容 不可以滑动view本身。</p>
<p>b：动画。动画可以滑动view内容，但是注意非属性动画 就如我们问题5说的内容 会影响到交互，使用的时候要多注意。不过多数复杂的滑动效果都是属性动画来完成的，属于大杀器级别、</p>
<p>c：改变布局参数。这种最好理解了，无非是动态的通过java代码来修改 margin等view的参数罢了。不过用的比较少。我本人不怎么用这种方法。</p>
<p><strong>7.Scroller是干嘛的？原理是什么？</strong></p>
<p>答：Scroller就是用于 让view有滑动渐变效果的。用法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.example.administrator.motioneventtest;</div><div class="line"></div><div class="line"><span class="keyword">import</span> android.content.Context;</div><div class="line"></div><div class="line"><span class="keyword">import</span> android.util.AttributeSet;</div><div class="line"></div><div class="line"><span class="keyword">import</span> android.widget.Scroller;</div><div class="line"></div><div class="line"><span class="keyword">import</span> android.widget.TextView;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"></div><div class="line"> * Created by Administrator on 2016/2/2.</div><div class="line"></div><div class="line"> */</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomTextView</span> <span class="keyword">extends</span> <span class="title">TextView</span></span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> Scroller mScroller;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomTextView</span><span class="params">(Context context)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">super</span>(context);</div><div class="line"></div><div class="line">        mScroller=<span class="keyword">new</span> Scroller(context);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomTextView</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">super</span>(context, attrs);</div><div class="line"></div><div class="line">        mScroller=<span class="keyword">new</span> Scroller(context);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomTextView</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyleAttr)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">super</span>(context, attrs, defStyleAttr);</div><div class="line"></div><div class="line">        mScroller=<span class="keyword">new</span> Scroller(context);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//调用此方法滚动到目标位置</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">smoothScrollTo</span><span class="params">(<span class="keyword">int</span> fx, <span class="keyword">int</span> fy)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> dx = fx - mScroller.getFinalX();</div><div class="line"></div><div class="line">        <span class="keyword">int</span> dy = fy - mScroller.getFinalY();</div><div class="line"></div><div class="line">        smoothScrollBy(dx, dy);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//调用此方法设置滚动的相对偏移</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">smoothScrollBy</span><span class="params">(<span class="keyword">int</span> dx, <span class="keyword">int</span> dy)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="comment">//设置mScroller的滚动偏移量</span></div><div class="line"></div><div class="line">        mScroller.startScroll(mScroller.getFinalX(), mScroller.getFinalY(), dx, dy,<span class="number">4000</span>);</div><div class="line"></div><div class="line">        invalidate();<span class="comment">//这里必须调用invalidate()才能保证computeScroll()会被调用，否则不一定会刷新界面，看不到滚动效果</span></div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//使用scroller最重要不要遗漏这个方法</span></div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">computeScroll</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (mScroller.computeScrollOffset())</div><div class="line"></div><div class="line">        &#123;</div><div class="line"></div><div class="line">            scrollTo(mScroller.getCurrX(),mScroller.getCurrY());</div><div class="line"></div><div class="line">            <span class="comment">//这个方法不要忘记调用。</span></div><div class="line"></div><div class="line">            postInvalidate();</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">super</span>.computeScroll();</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其实上述代码 很多人应该都能搜到。我们这里主要讲一下 他的原理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//参数很好理解 前面滑动起始点 中间滑动距离 最后一个是 渐变时间</span></div><div class="line"></div><div class="line"><span class="comment">//而且我们看到startScroll 这个方法就是设置了一下参数 并没有什么滑动的代码在</span></div><div class="line"></div><div class="line"><span class="comment">//回到前面的demo能看到我们通常调用完这个方法以后 都会马上调用invalidate()方法</span></div><div class="line"></div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startScroll</span><span class="params">(<span class="keyword">int</span> startX, <span class="keyword">int</span> startY, <span class="keyword">int</span> dx, <span class="keyword">int</span> dy, <span class="keyword">int</span> duration)</span> </span>&#123;</div><div class="line"></div><div class="line">        mMode = SCROLL_MODE;</div><div class="line"></div><div class="line">        mFinished = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">        mDuration = duration;</div><div class="line"></div><div class="line">        mStartTime = AnimationUtils.currentAnimationTimeMillis();</div><div class="line"></div><div class="line">        mStartX = startX;</div><div class="line"></div><div class="line">        mStartY = startY;</div><div class="line"></div><div class="line">        mFinalX = startX + dx;</div><div class="line"></div><div class="line">        mFinalY = startY + dy;</div><div class="line"></div><div class="line">        mDeltaX = dx;</div><div class="line"></div><div class="line">        mDeltaY = dy;</div><div class="line"></div><div class="line">        mDurationReciprocal = <span class="number">1.0f</span> / (<span class="keyword">float</span>) mDuration;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line"><span class="comment">//我们都知道invalidate 会触发view的 draw方法 </span></div><div class="line"></div><div class="line"><span class="comment">//我们跟进去看 会发现draw方法里 会调用下面的代码：</span></div><div class="line"></div><div class="line"><span class="comment">//也就是说会调用    computeScroll方法 而view本身这个方法</span></div><div class="line"></div><div class="line"><span class="comment">//是空的所以会留给我们自己实现</span></div><div class="line"></div><div class="line"> <span class="keyword">int</span> sx = <span class="number">0</span>;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> sy = <span class="number">0</span>;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (!drawingWithRenderNode) &#123;</div><div class="line"></div><div class="line">            computeScroll();</div><div class="line"></div><div class="line">            sx = mScrollX;</div><div class="line"></div><div class="line">            sy = mScrollY;</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line"><span class="comment">//然后回到我们的customtextview 可以看到我们实现的    computeScroll方法如下：</span></div><div class="line"></div><div class="line"><span class="comment">//你看在这个方法里 我们调用了scrollTo方法 来实现滑动，滑动结束以后再次触发view的重绘</span></div><div class="line"></div><div class="line"><span class="comment">//然后又会再次触发computeScroll 实现一个循环。</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">computeScroll</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (mScroller.computeScrollOffset())</div><div class="line"></div><div class="line">        &#123;</div><div class="line"></div><div class="line">            scrollTo(mScroller.getCurrX(),mScroller.getCurrY());</div><div class="line"></div><div class="line">            <span class="comment">//这个方法不要忘记调用。</span></div><div class="line"></div><div class="line">            postInvalidate();</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">super</span>.computeScroll();</div><div class="line"></div><div class="line">    &#125; </div><div class="line"></div><div class="line"><span class="comment">//返回true就代表滑动还没结束 false就是结束了</span></div><div class="line"></div><div class="line"><span class="comment">//其实这个方法 就跟属性动画里的插值器一样 你在使用startScroll方法的时候 会传一个事件的值，</span></div><div class="line"></div><div class="line"><span class="comment">//这个方法就是根据这个事件的值来计算你每一次scrollx和scrolly的值</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">computeScrollOffset</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (mFinished) &#123;</div><div class="line"></div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> timePassed = (<span class="keyword">int</span>)(AnimationUtils.currentAnimationTimeMillis() - mStartTime);</div><div class="line"></div><div class="line">    </div><div class="line"></div><div class="line">        <span class="keyword">if</span> (timePassed &lt; mDuration) &#123;</div><div class="line"></div><div class="line">            <span class="keyword">switch</span> (mMode) &#123;</div><div class="line"></div><div class="line">            <span class="keyword">case</span> SCROLL_MODE:</div><div class="line"></div><div class="line">                <span class="keyword">final</span> <span class="keyword">float</span> x = mInterpolator.getInterpolation(timePassed * mDurationReciprocal);</div><div class="line"></div><div class="line">                mCurrX = mStartX + Math.round(x * mDeltaX);</div><div class="line"></div><div class="line">                mCurrY = mStartY + Math.round(x * mDeltaY);</div><div class="line"></div><div class="line">                <span class="keyword">break</span>;</div><div class="line"></div><div class="line">            <span class="keyword">case</span> FLING_MODE:</div><div class="line"></div><div class="line">                <span class="keyword">final</span> <span class="keyword">float</span> t = (<span class="keyword">float</span>) timePassed / mDuration;</div><div class="line"></div><div class="line">                <span class="keyword">final</span> <span class="keyword">int</span> index = (<span class="keyword">int</span>) (NB_SAMPLES * t);</div><div class="line"></div><div class="line">                <span class="keyword">float</span> distanceCoef = <span class="number">1</span>.f;</div><div class="line"></div><div class="line">                <span class="keyword">float</span> velocityCoef = <span class="number">0</span>.f;</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (index &lt; NB_SAMPLES) &#123;</div><div class="line"></div><div class="line">                    <span class="keyword">final</span> <span class="keyword">float</span> t_inf = (<span class="keyword">float</span>) index / NB_SAMPLES;</div><div class="line"></div><div class="line">                    <span class="keyword">final</span> <span class="keyword">float</span> t_sup = (<span class="keyword">float</span>) (index + <span class="number">1</span>) / NB_SAMPLES;</div><div class="line"></div><div class="line">                    <span class="keyword">final</span> <span class="keyword">float</span> d_inf = SPLINE_POSITION[index];</div><div class="line"></div><div class="line">                    <span class="keyword">final</span> <span class="keyword">float</span> d_sup = SPLINE_POSITION[index + <span class="number">1</span>];</div><div class="line"></div><div class="line">                    velocityCoef = (d_sup - d_inf) / (t_sup - t_inf);</div><div class="line"></div><div class="line">                    distanceCoef = d_inf + (t - t_inf) * velocityCoef;</div><div class="line"></div><div class="line">                &#125;</div><div class="line"></div><div class="line">                mCurrVelocity = velocityCoef * mDistance / mDuration * <span class="number">1000.0f</span>;</div><div class="line"></div><div class="line">                </div><div class="line"></div><div class="line">                mCurrX = mStartX + Math.round(distanceCoef * (mFinalX - mStartX));</div><div class="line"></div><div class="line">                <span class="comment">// Pin to mMinX &lt;= mCurrX &lt;= mMaxX</span></div><div class="line"></div><div class="line">                mCurrX = Math.min(mCurrX, mMaxX);</div><div class="line"></div><div class="line">                mCurrX = Math.max(mCurrX, mMinX);</div><div class="line"></div><div class="line">                </div><div class="line"></div><div class="line">                mCurrY = mStartY + Math.round(distanceCoef * (mFinalY - mStartY));</div><div class="line"></div><div class="line">                <span class="comment">// Pin to mMinY &lt;= mCurrY &lt;= mMaxY</span></div><div class="line"></div><div class="line">                mCurrY = Math.min(mCurrY, mMaxY);</div><div class="line"></div><div class="line">                mCurrY = Math.max(mCurrY, mMinY);</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (mCurrX == mFinalX &amp;&amp; mCurrY == mFinalY) &#123;</div><div class="line"></div><div class="line">                    mFinished = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="keyword">break</span>;</div><div class="line"></div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line"></div><div class="line">            mCurrX = mFinalX;</div><div class="line"></div><div class="line">            mCurrY = mFinalY;</div><div class="line"></div><div class="line">            mFinished = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line"></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p><strong>8.view的滑动渐变效果总共有几种方法？</strong></p>
<p>答：三种，第一种是scroller 也是使用最多的。问题7里有解释。还有一种就是动画，动画我就不多说了，不属于本文范畴。最后一种也是我们经常使用的就是用handler ，每隔一个时间间隔 来更新view的状态。</p>
<p>代码不写了很简单。 自行体会。</p>
<p><strong>9.view的事件传递机制 如何用伪代码来表示？</strong></p>
<p>答：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"></div><div class="line">     * 对于一个root viewgroup来说，如果接受了一个点击事件，那么首先会调用他的dispatchTouchEvent方法。</div><div class="line"></div><div class="line">     * 如果这个viewgroup的onInterceptTouchEvent 返回true，那就代表要拦截这个事件。接下来这个事件就</div><div class="line"></div><div class="line">     * 给viewgroup自己处理了，从而viewgroup的onTouchEvent方法就会被调用。如果如果这个viewgroup的onInterceptTouchEvent</div><div class="line"></div><div class="line">     * 返回false就代表我不拦截这个事件，然后就把这个事件传递给自己的子元素，然后子元素的dispatchTouchEvent</div><div class="line"></div><div class="line">     * 就会被调用，就是这样一个循环直到 事件被处理。</div><div class="line"></div><div class="line">     *</div><div class="line"></div><div class="line">     */</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span>　<span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span></span></div><div class="line"></div><div class="line">&#123;</div><div class="line"></div><div class="line">    <span class="keyword">boolean</span> consume=<span class="keyword">false</span>;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (onInterceptTouchEvent(ev)) &#123;</div><div class="line"></div><div class="line">        consume=onTouchEvent(ev);</div><div class="line"></div><div class="line">    &#125;<span class="keyword">else</span></div><div class="line"></div><div class="line">    &#123;</div><div class="line"></div><div class="line">        consume=child.dispatchTouchEvent(ev);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> consume;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>10.view的onTouchEvent，OnClickListerner和OnTouchListener的onTouch方法 三者优先级如何？</strong></p>
<p>答：onTouchListener优先级最高，如果onTouch方法返回 false ，那onTouchEvent就被调用了，返回true 就不会被调用。至于onClick 优先级最低。</p>
<p><strong>11.点击事件的传递顺序如何？</strong></p>
<p>答：Activity-Window-View。从上到下依次传递，当然了如果你最低的那个view onTouchEvent返回false 那就说明他不想处理 那就再往上抛，都不处理的话</p>
<p>最终就还是让Activity自己处理了。举个例子，pm下发一个任务给leader，leader自己不做 给架构师a，小a也不做 给程序员b，b如果做了那就结束了这个任务。</p>
<p>b如果发现自己搞不定，那就找a做，a要是也搞不定 就会不断向上发起请求，最终可能还是pm做。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//activity的dispatchTouchEvent 方法 一开始就是交给window去处理的</span></div><div class="line"></div><div class="line"><span class="comment">//win的superDispatchTouchEvent 返回true 那就直接结束了 这个函数了。返回false就意味</span></div><div class="line"></div><div class="line"><span class="comment">//这事件没人处理，最终还是给activity的onTouchEvent 自己处理 这里的getwindow 其实就是phonewindow</span></div><div class="line"></div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (ev.getAction() == MotionEvent.ACTION_DOWN) &#123;</div><div class="line"></div><div class="line">            onUserInteraction();</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (getWindow().superDispatchTouchEvent(ev)) &#123;</div><div class="line"></div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> onTouchEvent(ev);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line"><span class="comment">//来看phonewindow的这个函数 直接把事件传递给了mDecor</span></div><div class="line"></div><div class="line"> <span class="meta">@Override</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">superDispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> mDecor.superDispatchTouchEvent(event);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line"><span class="comment">//devorview就是 我们的rootview了 就是那个framelayout 我们的setContentView里面传递的那个layout</span></div><div class="line"></div><div class="line"><span class="comment">//就是这个decorview的 子view了</span></div><div class="line"></div><div class="line">     <span class="meta">@Override</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> View <span class="title">getDecorView</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (mDecor == <span class="keyword">null</span>) &#123;</div><div class="line"></div><div class="line">            installDecor();</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> mDecor;</div><div class="line"></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p><strong>12.事件分为几个步骤？</strong></p>
<p>答：down事件开头，up事件结尾，中间可能会有数目不定的move事件。</p>
<p><strong>13.ViewGroup如何对点击事件分发？</strong></p>
<p>答：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">viewgroup就是在actionMasked == MotionEvent.ACTION_DOWN 和 mFirstTouchTarget != <span class="keyword">null</span> 这两种情况来判断是否会进入拦截事件的流程</div><div class="line"></div><div class="line">看代码可以知道 如果是ACTION_DOWN事件  那就肯定进入 是否要拦截事件的流程</div><div class="line"></div><div class="line">如果不是ACTION_DOWN事件 那就要看mFirstTouchTarget != <span class="keyword">null</span> 这个条件是否成立</div><div class="line"></div><div class="line">这个地方有点绕但是也好理解，其实就是 对于一个事件序列来说 down是事件的开头 所以肯定进入了这个事件是否拦截的流程 也就是<span class="keyword">if</span> 括号内。</div><div class="line"></div><div class="line">mFirstTouchTarget其实是一个单链表结构他指向的是 成功处理事件的子元素。</div><div class="line"></div><div class="line">也就是说 如果有子元素成功处理了 事件，那这个值就不为NULL。反过来说</div><div class="line"></div><div class="line">只要viewgroup拦截了事件，mFirstTouchTarget就不为NULL，所以括号内就不会执行，也就侧面说明了一个结论：</div><div class="line"></div><div class="line">某个view 一旦决定拦截事件，那么这个事件所属的事件序列 都只能由他来执行。并且onInterceptTouchEvent 这个方法不会被调用了</div><div class="line"></div><div class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> intercepted;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN</div><div class="line"></div><div class="line">                    || mFirstTouchTarget != <span class="keyword">null</span>) &#123;</div><div class="line"></div><div class="line">                <span class="keyword">final</span> <span class="keyword">boolean</span> disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != <span class="number">0</span>;</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (!disallowIntercept) &#123;</div><div class="line"></div><div class="line">                    intercepted = onInterceptTouchEvent(ev);</div><div class="line"></div><div class="line">                    ev.setAction(action); <span class="comment">// restore action in case it was changed</span></div><div class="line"></div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line"></div><div class="line">                    intercepted = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">                &#125;</div><div class="line"></div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line"></div><div class="line">                <span class="comment">// There are no touch targets and this action is not an initial down</span></div><div class="line"></div><div class="line">                <span class="comment">// so this view group continues to intercept touches.</span></div><div class="line"></div><div class="line">                intercepted = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">            &#125;</div></pre></td></tr></table></figure>
<p><strong>14.如果某个view 处理事件的时候 没有消耗down事件 会有什么结果？</strong></p>
<p>答：假如一个view，在down事件来的时候 他的onTouchEvent返回false， 那么这个down事件 所属的事件序列 就是他后续的move 和up 都不会给他处理了，全部都给他的父view处理。</p>
<p><strong>15.如果view 不消耗move或者up事件 会有什么结果？</strong></p>
<p>答：那这个事件所属的事件序列就消失了，父view也不会处理的，最终都给activity 去处理了。</p>
<p><strong>16.ViewGroup 默认拦截事件吗？</strong></p>
<p>答：默认不拦截任何事件，onInterceptTouchEvent返回的是false。</p>
<p><strong>17.一旦有事件传递给view，view的onTouchEvent一定会被调用吗？</strong></p>
<p>答：是的，因为view 本身没有onInterceptTouchEvent方法，所以只要事件来到view这里 就一定会走onTouchEvent方法。</p>
<p>并且默认都是消耗掉，返回true的。除非这个view是不可点击的，所谓不可点击就是clickable和longgclikable同时为fale</p>
<p>Button的clickable就是true 但是textview是false。</p>
<p><strong>18.enable是否影响view的onTouchEvent返回值？</strong></p>
<p>答：不影响，只要clickable和longClickable有一个为真，那么onTouchEvent就返回true。</p>
<p><strong>19.requestDisallowInterceptTouchEvent 可以在子元素中干扰父元素的事件分发吗？如果可以，是全部都可以干扰吗？</strong></p>
<p>答：肯定可以，但是down事件干扰不了。</p>
<p><strong>20.dispatchTouchEvent每次都会被调用吗？</strong></p>
<p>答：是的，onInterceptTouchEvent则不会。</p>
<p><strong>21.滑动冲突问题如何解决 思路是什么？</strong></p>
<p>答。要解决滑动冲突 其实最主要的就是有一个核心思想。你到底想在一个事件序列中，让哪个view 来响应你的滑动？比如 从上到下滑，是哪个view来处理这个事件，从左到右呢？</p>
<p>用业务需求 来想明白以后 剩下的 其实就很好做了。核心的方法 就是2个 外部拦截也就是父亲拦截，另外就是内部拦截，也就是子view拦截法。 学会这2种 基本上所有的滑动冲突</p>
<p>都是这2种的变种，而且核心代码思想都一样。</p>
<p>外部拦截法：思路就是重写父容器的onInterceptTouchEvent即可。子元素一般不需要管。可以很容易理解，因为这和android自身的事件处理机制 逻辑是一模一样的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onInterceptTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">boolean</span> intercepted = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> x = (<span class="keyword">int</span>) ev.getX();</div><div class="line"></div><div class="line">        <span class="keyword">int</span> y = (<span class="keyword">int</span>) ev.getY();</div><div class="line"></div><div class="line">        <span class="keyword">switch</span> (ev.getAction()) &#123;</div><div class="line"></div><div class="line">            <span class="comment">//down事件肯定不能拦截 拦截了后面的就收不到了</span></div><div class="line"></div><div class="line">            <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</div><div class="line"></div><div class="line">                intercepted = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">                <span class="keyword">break</span>;</div><div class="line"></div><div class="line">            <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (你的业务需求) &#123;</div><div class="line"></div><div class="line">                    <span class="comment">//如果确定拦截了 就去自己的onTouchEvent里 处理拦截之后的操作和效果 即可了</span></div><div class="line"></div><div class="line">                    intercepted = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line"></div><div class="line">                    intercepted = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="keyword">break</span>;</div><div class="line"></div><div class="line">            <span class="keyword">case</span> MotionEvent.ACTION_UP:</div><div class="line"></div><div class="line">                <span class="comment">//up事件 我们一般都是返回false的 一般父容器都不会拦截他。 因为up是事件的最后一步。这里返回true也没啥意义</span></div><div class="line"></div><div class="line">                <span class="comment">//唯一的意义就是因为 父元素 up被拦截。导致子元素 收不到up事件，那子元素 就肯定没有onClick事件触发了，这里的</span></div><div class="line"></div><div class="line">                <span class="comment">//小细节 要想明白</span></div><div class="line"></div><div class="line">                intercepted = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">                <span class="keyword">break</span>;</div><div class="line"></div><div class="line">            <span class="keyword">default</span>:</div><div class="line"></div><div class="line">                <span class="keyword">break</span>;</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> intercepted;</div><div class="line"></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>内部拦截法：内部拦截法稍微复杂一点，就是事件到来的时候，父容器不管，让子元素自己来决定是否处理。如果消耗了 就最好，没消耗 自然就转给父容器处理了。</p>
<p>子元素代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> x = (<span class="keyword">int</span>) event.getX();</div><div class="line"></div><div class="line">        <span class="keyword">int</span> y = (<span class="keyword">int</span>) event.getY();</div><div class="line"></div><div class="line">        <span class="keyword">switch</span> (event.getAction()) &#123;</div><div class="line"></div><div class="line">            <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</div><div class="line"></div><div class="line">                getParent().requestDisallowInterceptTouchEvent(<span class="keyword">true</span>);</div><div class="line"></div><div class="line">                <span class="keyword">break</span>;</div><div class="line"></div><div class="line">            <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (如果父容器需要这个点击事件) &#123;</div><div class="line"></div><div class="line">                    getParent().requestDisallowInterceptTouchEvent(<span class="keyword">false</span>);</div><div class="line"></div><div class="line">                &#125;<span class="comment">//否则的话 就交给自己本身view的onTouchEvent自动处理了</span></div><div class="line"></div><div class="line">                <span class="keyword">break</span>;</div><div class="line"></div><div class="line">            <span class="keyword">case</span> MotionEvent.ACTION_UP:</div><div class="line"></div><div class="line">                <span class="keyword">break</span>;</div><div class="line"></div><div class="line">            <span class="keyword">default</span>:</div><div class="line"></div><div class="line">                <span class="keyword">break</span>;</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.dispatchTouchEvent(event);</div><div class="line"></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>父亲容器代码也要修改一下，其实就是保证父亲别拦截down：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onInterceptTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (ev.getAction() == MotionEvent.ACTION_DOWN) &#123;</div><div class="line"></div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line"></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<hr>
<p>未经许可不得转载，转载请注明zilianliuxue的blog,本人保留所有版权。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为转载的，作者希尔瓦娜斯女神&lt;/p&gt;
&lt;h1 id=&quot;Android-View事件机制&quot;&gt;&lt;a href=&quot;#Android-View事件机制&quot; class=&quot;headerlink&quot; title=&quot;Android View事件机制&quot;&gt;&lt;/a&gt;Android View事件
    
    </summary>
    
      <category term="android" scheme="http://zilianliuxue.github.io/categories/android/"/>
    
    
      <category term="view事件机制" scheme="http://zilianliuxue.github.io/tags/view%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>git命令使用大全</title>
    <link href="http://zilianliuxue.github.io/2016/08/20/git%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8%E5%A4%A7%E5%85%A8/"/>
    <id>http://zilianliuxue.github.io/2016/08/20/git命令使用大全/</id>
    <published>2016-08-19T22:48:00.000Z</published>
    <updated>2016-08-19T23:21:00.740Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ADD-AND-COMMIT"><a href="#ADD-AND-COMMIT" class="headerlink" title="ADD AND COMMIT"></a>ADD AND COMMIT</h2><pre><code>1. git init    
</code></pre><p>初始化一个 Git 仓库（repository），即把当前所在目录变成 Git 可以管理的仓库。</p>
<pre><code>2. git add 文件
</code></pre><p>把文件添加到 暂存区（stage），可被 track 追踪纪录下来。可多次使用来添加多个文件。</p>
<pre><code>3. git add * 
</code></pre><p>添加所有修改到暂存区，效果同 git add all，待验证。</p>
<pre><code>4. git add -A
</code></pre><p>暂存所有的文件，包括新增加的、修改的和删除的文件。</p>
<pre><code>5. git add .
</code></pre><p>暂存新增加的和修改的文件，不包括已删除的文件。即当前目录下所有文件。</p>
<pre><code>6. git add -u
</code></pre><p>暂存修改的和删除的文件，不包括新增加的文件。</p>
<pre><code>7. git add -i
</code></pre><p>交互式添加文件到暂存区。</p>
<pre><code>8. git add -p
</code></pre><p>暂存文件的一部分。</p>
<pre><code>9. git commit -m &quot;本次提交说明&quot;
</code></pre><p>一次性把暂存区所有文件修改提交到仓库的当前分支。注意：提交信息可为中文也可为英文，若为英文则通常用一般现在时。如果不加参数 -m 则会跳转到编辑器强制填写提交说明信息。</p>
<pre><code>10. git commit -am &quot;本次提交说明&quot;
</code></pre><p>使用该命令，Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 git add 步骤，参数 -am 也可写成 -a -m。“在 oh-my-zsh 下，直接用 gcam “message” 就搞定了”，—魔都三帅语。</p>
<pre><code>11. git commit --amend
</code></pre><p>重新提交，最终只会有一个提交，第二次提交将代替第一次提交的结果。尤其适用于提交完了才发现漏掉了几个文件没有添加，或者提交信息写错了的情况。</p>
<pre><code>12. git commit --amend --reset-author
</code></pre><p>在上一次 commit 之后想重新更新一下时间。amend 实际上修改了上一个 commit。所以如果已经 push 了上一个 commit，请尽量不要 amend。如果一定要 amend 已经 push 了的 commit，请确保这个 commit 所在的 branch 只有你一个人使用（否则会给其他人带来灾难），然后在 amend 之后使用 git push –force。只要多加小心，该命令貌似没什么卵用。</p>
<pre><code>13. git commit -p
</code></pre><p>commit 文件的一部分，适合工作量比较大的情况。之后，Git 会对每块修改弹出一个提示，询问你是否 stage，按 y/n 来选择是否 commit 这块修改，? 可以查看其他操作的说明。</p>
<h2 id="DIFF-AND-SHOW"><a href="#DIFF-AND-SHOW" class="headerlink" title="DIFF AND SHOW"></a>DIFF AND SHOW</h2><pre><code>1. git status
</code></pre><p>显示当前仓库的最新状态。提交之后，工作区就是“干净的”，即没有新的修改；有未提交文件时，最上面显示的是在 staging area，即将被 commit 的文件；中间显示没有 stage 的修改了的文件，最下面是新的还没有被 Git track 的文件。“在 oh-my-zsh 下，输入 gst 就出来了，谁用谁知道，装逼利器，效率杠杠的”，—魔都三帅语。</p>
<pre><code>2. git status -s 或 git status --short
</code></pre><p>状态简览。输入此命令后，有如下几种情况（总共5种情况）：新添加的未跟踪文件前面有 ?? 标记，新添加到暂你可能注意到了 M 有两个可以出现的位置，出现在右边的 M 表示该文件被修改了但是还没放入暂存区，出现在靠左边的 M 表示该文件被修改了并放入了暂存区。</p>
<pre><code>3. git diff
</code></pre><p>查看工作区中的修改。</p>
<pre><code>4. git diff --staged 或 git diff --cached
</code></pre><p>查看暂存区中的修改。</p>
<pre><code>5. git diff &lt;commit id1&gt; &lt;commit id2&gt;
</code></pre><p>比较两次 commit 之间的差异。</p>
<pre><code>6. git diff &lt;branch1&gt; &lt;branch2&gt;
</code></pre><p>在两个 branch 之间比较。</p>
<pre><code>7. git diff 文件
</code></pre><p>查看指定文件具体修改了哪些内容。</p>
<pre><code>8. git diff HEAD -- 文件
</code></pre><p>查看版本库最新版本和工作区之间的区别，貌似没什么卵用。</p>
<pre><code>9. git difftool --tool-help
</code></pre><p>查看系统支持哪些 Git Diff 插件，貌似没什么卵用。</p>
<pre><code>10. git show
</code></pre><p>查看最后一个 commit 的修改。</p>
<pre><code>11. git show HEAD~3
</code></pre><p>查看倒数第四个 commit 的修改，HEAD~3 就是向前数三个的 commit，即倒数第四个 commit。</p>
<pre><code>12. git show deadbeef
</code></pre><p>查看 hash 为 deadbeef 的 commit 的修改。</p>
<pre><code>13. git blame 文件
</code></pre><p>查看谁什么时间改了哪些文件。</p>
<h2 id="LOG-AND-RESET"><a href="#LOG-AND-RESET" class="headerlink" title="LOG AND RESET"></a>LOG AND RESET</h2><pre><code>1. git log
</code></pre><p>显示从最近到最远的提交日志，包括每个提交的 SHA-1 校验和、作者的名字和电子邮件地址、提交时间以及提交说明等基本信息。</p>
<pre><code>2. git log -p -2
</code></pre><p>除显示基本信息之外，还显示每次提交的内容差异，-2 意思是仅显示最近两次提交。特别适用于进行代码审查，或者快速浏览某个搭档提交的 commit 所带来的变化。</p>
<pre><code>3. git log --start
</code></pre><p>显示每次提交的简略的统计信息，貌似不太好用。</p>
<pre><code>4. git log --graph
</code></pre><p>查看分支合并图。</p>
<pre><code>5. git log --pretty=oneline
</code></pre><p>简化日志信息，将每个提交放在一行显示，查看的提交数很大时非常有用，也可带有 –graph 参数，效果同 git config format.pretty oneline。</p>
<pre><code>6. git log --graph --pretty=oneline --abbrev-commit
</code></pre><p>查看分支的合并情况，包括分支合并图、一行显示、提交校验码缩略显示。</p>
<pre><code>7. git log --oneline --decorate
</code></pre><p>查看各个分支当前所指的提交对象（commit object）。Git 仓库中有五个对象：三个 blob 对象（保存着文件快照）、一个树对象（记录着目录结构和 blob 对象索引）以及一个提交对象（包含着指向前述树对象的指针和所有提交信息）。</p>
<pre><code>8. git log --oneline --decorate --graph --all
</code></pre><p>查看分叉历史，包括：提交历史、各个分支的指向以及项目的分支分叉情况。</p>
<pre><code>9. git reset --hard HEAD^
</code></pre><p>回退到上一个版本。同理，回退到上上个版本为：HEAD^ ^， 回退到上100个版本为：HEAD-100，貌似波浪号 ~ 也可以，变成倒数第101个。</p>
<pre><code>10. git reflog
</code></pre><p>纪录每一次命令，可用于查找某一提交版本的 commit id。</p>
<pre><code>11. git reset --hard &lt;commit id&gt;
</code></pre><p>回退到某一提交过的版本，如果已经 push，则回退的意义不大了。恢复一个彻底删掉的 commit，见链接：<a href="https://github.com/xhacker/GitProTips/blob/master/zh_CN.md#别人-push-了修改我无法-push-了怎么办。" target="_blank" rel="external">https://github.com/xhacker/GitProTips/blob/master/zh_CN.md#别人-push-了修改我无法-push-了怎么办。</a></p>
<h2 id="WORKING-AREA-AND-REPO-AREA"><a href="#WORKING-AREA-AND-REPO-AREA" class="headerlink" title="WORKING AREA AND REPO AREA"></a>WORKING AREA AND REPO AREA</h2><pre><code>1. 工作区（Working Directory）
</code></pre><p>项目所在的文件目录。</p>
<pre><code>2. 版本库（Repository）
</code></pre><p>工作区有一个隐藏目录文件 .git（可通过命令 ls -ah 查看隐藏文件），这就是 Git 的版本库。版本库里主要有称为 stage 的暂存区、Git 自动创建的 master 分支，以及指向 master 的一个指针 HEAD，表示版本库的最新版本。</p>
<h2 id="RESET-AND-REVERT"><a href="#RESET-AND-REVERT" class="headerlink" title="RESET AND REVERT"></a>RESET AND REVERT</h2><pre><code>1. git checkout -- 文件
</code></pre><p>丢弃工作区的修改，包括修改后还没有放到暂存区和添加到暂存区后又作了修改两种情况。总之，让该文件回到最近一次 git commit 或 git add 之后的状态。注意：没有 – ，就变成了切换分支的命令了。郭神的书 P195 没有 – 符号，可能是笔误。</p>
<pre><code>2. git reset HEAD 文件
</code></pre><p>把暂存区的修改撤销（unstage），回退到工作区。注意：在 Git 中任何已提交的东西几乎总是可以恢复的。甚至那些被删除的分支中的提交或使用 –amend 选项覆盖的提交也可以恢复。然而，任何未提交的东西丢失后很可能再也找不到了。</p>
<pre><code>3. git reset --hard
</code></pre><p>重置所有文件到未修改的状态。</p>
<pre><code>4. git reset &lt;commit SHA&gt;
</code></pre><p>重置到某个 commit。</p>
<pre><code>5. git reset HEAD~1
</code></pre><p>将当前 branch 重置为倒数第二个 commit（即丢弃最后一个 commit）。git reset 有三个参数可以选择，–soft、–mixed 和 –hard。</p>
<pre><code>6. git reset --soft
</code></pre><p>修改最后一个 commit。貌似没什么卵用。</p>
<pre><code>7. git revert &lt;commit id&gt;
</code></pre><p>还原某个 commit。还原（revert）的实质是产生一个新的 commit，内容和要还原的 commit 完全相反。比如，A commit 在 main.c 中增加了三行，revert A 产生的 commit 就会删除这三行。如果我们非常确定之前的某个 commit 产生了 bug，最好的办法就是 revert 它。git revert 后 git 会提示写一些 commit message，此处最好简单描述为什么要还原；而重置（reset）会修改历史，常用于还没有 push 的本地 commits。</p>
<pre><code>8. git revert HEAD
</code></pre><p>还原到上次 commit。</p>
<h2 id="REMOVE"><a href="#REMOVE" class="headerlink" title="REMOVE"></a>REMOVE</h2><pre><code>1. git rm 文件
</code></pre><p>把文件从版本库中删除，不会再追踪到。</p>
<pre><code>2. git rm -f 文件
</code></pre><p>强制删除版本库中有修改的文件。</p>
<pre><code>3. git rm --cached 文件
</code></pre><p>把文件从版本库中删除，但让文件保留在工作区且不被 Git 继续追踪（track），通常适用于在 rm 之后把文件添加到 .gitignore 中的情况。</p>
<pre><code>4. git rm log/\*.log
</code></pre><p>删除 log/ 目录下扩展名为 .log 的所有文件。</p>
<pre><code>5. git rm \*~
</code></pre><p>删除以 ~ 结尾的所有文件。</p>
<h2 id="REMOTE-REPO"><a href="#REMOTE-REPO" class="headerlink" title="REMOTE REPO"></a>REMOTE REPO</h2><h2 id="REMOTE-AND-PUSH"><a href="#REMOTE-AND-PUSH" class="headerlink" title="REMOTE AND PUSH"></a>REMOTE AND PUSH</h2><pre><code>1. git remote
</code></pre><p>查看已经配置的远程仓库服务器，效果同 git remote show。</p>
<pre><code>2. git remote -v
</code></pre><p>显示需要读写远程仓库使用的 Git 保存的简写与其对应的 URL。</p>
<pre><code>3. git ls-remote &lt;remote-name&gt;
</code></pre><p>显示获得远程引用的完整列表。</p>
<pre><code>4. git remote show &lt;remote-name&gt;
</code></pre><p>参数 remote-name 通常都是缩写名 origin，可以得到远程分支更为详细的信息以及 pull 和 push 相关提示信息。</p>
<pre><code>5. git remote add &lt;shortname&gt; &lt;url&gt;
</code></pre><p>添加并关联一个远程库。其中，shortname 一般是 origin，也可以是其他字符串，用来代替整个 url。</p>
<pre><code>6. git push
</code></pre><p>推送本地修改到 origin。</p>
<pre><code>7. git push -u origin master
</code></pre><p>关联后，使用该命令第一次推送 master 分支的所有内容，后续再推送的时候就可以省略后面三个参数了，其中参数 u 代表上游（upstream）的意思。</p>
<pre><code>8. git push origin 远程分支（通常是 master）
</code></pre><p>推送最新修改。注意：多人协作时，除了 merge 可能会发生冲突之外，推送时也有可能发生冲突。在他人推送之后是不能立即推送自己的修改的，想想也是，因为可能会覆盖他人的工作，所以必须先拉取（pull）别人的修改合并（merge）之后才能推送。如果不是第一次推送，后面的参数可省略。</p>
<pre><code>9. git push &lt;remote-name&gt; &lt;commit SHA&gt;:&lt;remote-branch_name&gt;
</code></pre><p>push 一部分 commit。例如：git push origin 9790eff:master 即为 push 9790eff 之前的所有 commit 到 master。</p>
<pre><code>10. git remote rename old_name new_name
</code></pre><p>重命名一个远程仓库的简写名。</p>
<pre><code>11. git remote rm &lt;remote-name&gt;
</code></pre><p>移除一个远程仓库。</p>
<pre><code>12. git remote add origin http://github.com/username/&lt;repo name&gt;.git
</code></pre><p>Create a remote repo named origin pointing at your Github repo (after you’ve already created the repo on Github) (used if you git init since the repo you created locally isn’t linked to a remote repo yet).</p>
<pre><code>13. git remote add origin git@github.com:username/&lt;repo name&gt;.git
</code></pre><p>Create a remote repo named origin pointing at your Github repo (using SSH url instead of HTTP url).</p>
<h2 id="CLONE"><a href="#CLONE" class="headerlink" title="CLONE"></a>CLONE</h2><pre><code>1. git clone git@github.com:username/&lt;repo name&gt;.git
</code></pre><p>从远程库（origin）克隆一份到本地，仓库名同远程仓库名。</p>
<pre><code>2. git clone https://github.com/username/repo name.git
</code></pre><p>作用同上。但不建议使用 https 协议，原因有二：一是速度慢；二是每次推送必须输入口令，麻烦。但在某些只开放 http 端口的公司内部就无法使用原生的 ssh 协议而只能用 https，仓库名同远程仓库名。</p>
<pre><code>3. git clone &lt;repo url&gt; &lt;folder name&gt;
</code></pre><p>克隆一个仓库到指定文件夹。</p>
<pre><code>4. git clone &lt;repo url&gt; .
</code></pre><p>克隆一个仓库到当前文件夹（应该是空的）。</p>
<h2 id="BRANCH"><a href="#BRANCH" class="headerlink" title="BRANCH"></a>BRANCH</h2><h2 id="BRANCH-AND-MERGE"><a href="#BRANCH-AND-MERGE" class="headerlink" title="BRANCH AND MERGE"></a>BRANCH AND MERGE</h2><pre><code>1. git branch
</code></pre><p>列出本地当前所有分支，方便查看。当前分支前面会标有一个 * 号。</p>
<pre><code>2. git branch -r
</code></pre><p>查看远程分支列表。</p>
<pre><code>3. git branch -a
</code></pre><p>显示所有分支，包括本地和远程。</p>
<pre><code>4. git branch -v
</code></pre><p>查看每一次分支的最后一次提交。</p>
<pre><code>5. git branch -vv
</code></pre><p>查看设置的所有跟踪分支。将所有的本地分支列出来并且包含更多的信息，如每一个分支正在跟踪哪个远程分支与本地分支是否是领先、落后或是都有。</p>
<pre><code>6. git branch --merged
</code></pre><p>查看所有已经被 merge 的 branch。</p>
<pre><code>7. git branch --no-merged
</code></pre><p>查看所有还没被 merge 的 branch。</p>
<pre><code>8. git branch --merged | xargs git branch -d
</code></pre><p>删除所有已经被 merge 的 branch。</p>
<pre><code>9. git checkout -b 分支
</code></pre><p>创建并切换到新的分支，相当于下面两条命令：git branch 分支 + git checkout 分支。</p>
<pre><code>10. git checkout -
</code></pre><p>切换到上一个 branch。</p>
<pre><code>11. git cherry-pick &lt;commit id&gt;
</code></pre><p>假如我们在某个 branch 做了一大堆 commit，而当前 branch 想应用其中的一个，可以使用该命令。</p>
<pre><code>12. git merge 分支
</code></pre><p>合并指定分支到当前所在的分支。</p>
<pre><code>13. git merge --no-ff -m &quot;提交说明信息&quot; 分支
</code></pre><p>参数 –no-ff 表示禁用 Fast forward 快进模式，用普通模式合并，这样合并后的历史有分支，能看出来曾经做过合并，而 fast forwad 合并就看不出来曾经做过合并。</p>
<pre><code>14. git branch -d 分支
</code></pre><p>普通删除分支（相对强制删除而言）。一般情况下，先合并完分支，然后再删除，否则会删除失败，除非使用 -D 参数强制删除。注意：因为创建、合并和删除分支非常快，所以 Git 鼓励使用分支完成某个任务，合并后再删除分支，这个直接在 master 分支上工作效果是一样的，但过程更安全。</p>
<pre><code>15. git branch -D 分支
</code></pre><p>强行删除分支，尤其适用分支内容有了新的修改但还没有被合并的情况。</p>
<pre><code>16. git push origin --delete 远程分支 或 git push origin:远程分支
</code></pre><p>删除一个远程分支。基本上这个命令做的只是从服务器上移除这个指针。 Git 服务器通常会保留数据一段时间直到垃圾回收运行，所以如果不小心删除掉了，通常是很容易恢复的。</p>
<pre><code>17. git push origin -delete 分支
</code></pre><p>在本地和远程同步删除分支。</p>
<pre><code>18. git rebase 目标分支（通常是 master）
</code></pre><p>在本地 master 上进行变基操作。注意：merge 与 rebase 都是整合来自不同分支的修改。</p>
<p>merge 会把两个分支的最新快照以及二者最近的共同祖先进行三方合并，合并的结果是生成一个新的快照（并提交）。<br>rebase 会把提交到某一分支（当前分支）上的所有修改都转移至另一分支（目标分支）上，就好像“重新播放”一样。<br>变基是将一系列提交按照原有次序依次应用到另一分支上，而合并是把最终结果合在一起。简言之：这两种整合方法的最终结果没有任何区别，但是变基使得提交历史更加整洁。<br>采用变基操作后，项目的最终维护者就不再需要进行整合工作，只需要快进合并便可。</p>
<pre><code>git rebase –ongo
</code></pre><p>目标分支 第一分支 第二分支：选中在第二分支里但不在第一分支里的修改，将它们在目标分支（通常是 master）上重演。<br>变基有风险，需要遵守的准则是：不要对在你的仓库外有副本的分支执行变基。否则，会导致混乱。总的原则是，只对尚未推送或分享给别人的本地修改执行变基操作清理历史，从不对已推送至别处的提交执行变基操作，这样才能享受到两种方式带来的便利。<br>还可以有这样的命令：</p>
<pre><code>git rebase -i master，git rebase -i 22e21f2，git rebase -i HEAD~3。
</code></pre><p>STASH</p>
<ol>
<li><p>git stash<br>把当前分支的工作现场储存起来，等以后恢复现场后继续工作。一般适用于还没有 commit 的分支代码。</p>
</li>
<li><p>git stash list<br>查看储存的工作现场纪录列表。</p>
</li>
<li><p>git stash apply + git stash drop<br>用 git stash apply 命令恢复最近 stash 过的工作现场，但是恢复后，stash 内容并不删除，用 git stash drop 命令来删除。apply 和 drop 后面都可以加上某一指定的 stash_id。</p>
</li>
<li><p>git stash pop<br>相当于上面两条命令，恢复回到工作现场的同时把 stash 内容也删除了。</p>
</li>
<li><p>git stash clear<br>清空所有暂存区的 stash 纪录。drop 是只删除一条，当然后面可以跟 stash_id 参数来删除指定的某条纪录，不跟参数就是删除最近的。</p>
</li>
<li><p>git stash apply stash@{0}<br>上面命令中大括号中的数字不是固定的，因为可以多次 stash，恢复的时候，先用 git stash list 命令查看，然后恢复指定的 stash。</p>
</li>
<li><p>git biselect<br>发现了一个 bug，用该命令知道是哪个 commit 导致的，貌似不太好用。</p>
</li>
</ol>
<p>PULL AND PUSH</p>
<ol>
<li><p>git push origin 分支<br>把该分支上的所有本地提交推送到远程库对应的远程分支上。</p>
</li>
<li><p>git checkout 分支 origin/分支<br>如果远程有某一个分支而本地没有，怎用该命令把远程的这个分支迁到本地。</p>
</li>
<li><p>git checkout -b 分支 origin/分支<br>把远程分支迁到本地顺便切换到该分支。</p>
</li>
<li><p>git pull<br>抓取远程库最新提交，拉取并合并。</p>
</li>
<li><p>git fetch<br>没有 merge 的 pull。</p>
</li>
<li><p>git branch –set-upstream 分支 origin/分支<br>建立本地分支和远程分支的关联。</p>
</li>
<li><p>git submodule update –recursive<br>第三方依赖与远程同步，还可以在最后添加 -f 参数。</p>
</li>
</ol>
<h2 id="TAG"><a href="#TAG" class="headerlink" title="TAG"></a>TAG</h2><h2 id="INIT-TAG"><a href="#INIT-TAG" class="headerlink" title="INIT TAG"></a>INIT TAG</h2><pre><code>1. git tag
</code></pre><p>查看所有标签。注意：标签不是按照时间列出，而是按照字母排序，但这并不重要。</p>
<pre><code>2. git show &lt;tag-name&gt;
</code></pre><p>查看标签信息。</p>
<pre><code>3. git tag -l &apos;tag-name&apos;
</code></pre><p>使用特定的模式查找标签。</p>
<pre><code>4. git checkout &lt;tag-name&gt;
</code></pre><p>切换 tag。</p>
<pre><code>5. git tag &lt;tag name&gt; &lt;commit id&gt;
</code></pre><p>在需要打标签的分支上创建一个轻量标签（lightweight），默认为 HEAD，也可以指定一个 commit id。</p>
<pre><code>6. git tag -a &lt;tag-name&gt; -m &quot;标签说明文字&quot; &lt;commit id&gt;
</code></pre><p>创建附注标签（annotated），用 -a 指定标签名，-m 指定说明文字，也可以指定一个 commit id。</p>
<pre><code>7. git tag -a &lt;tag-name&gt; 提交的校验和或部分校验和
</code></pre><p>后期打标签，即对过去的提交打标签。校验和（checksum）：长度为 40位的16进制数的 SHA-1 值字符串。然而，只要没有冲突，通常可以用一个比较短的前缀来表示一个 commit。</p>
<pre><code>8. git tag -s &lt;tag-name&gt; -m &quot;标签说明文字&quot; &lt;commit id&gt;
</code></pre><p>通过 -s 用私钥签名一个标签。签名采用 GPG 签名，因此，必须首先按照 pgp（GnuPG），如果没有找到 gpg，或者没有 gpg 秘钥对，就会报错。如果报错，请参考 GnuPG 帮助文档配置 Key。</p>
<h2 id="MANIPULATE-TAG"><a href="#MANIPULATE-TAG" class="headerlink" title="MANIPULATE TAG"></a>MANIPULATE TAG</h2><pre><code>1. git tag -d &lt;tag-name&gt;
</code></pre><p>删除一个本地标签。因为创建的标签都只存储在本地，不会自动推送到远程。所以，打错的标签可以在本地安全删除。</p>
<pre><code>2. git push origin &lt;tag-name&gt;
</code></pre><p>推送本地某个标签到远程，默认情况下，git push 命令并不会推送标签到远程，必须显示推送。</p>
<pre><code>3. git push origin --tags
</code></pre><p>参数 –tags 表示一次性推送全部未推送到远程的本地标签，当其他人从仓库中克隆或拉取，他们也能得到那些标签。</p>
<pre><code>4. git push origin :refs/tags/&lt;tag-name&gt;
</code></pre><p>删除一个远程标签，先从本地删除，再用该命令从远程删除。</p>
<pre><code>5. git checkout -b &lt;branch-name&gt; &lt;tag-name&gt;
</code></pre><p>在特定的标签上创建一个新分支，貌似没什么卵用。</p>
<h2 id="CUSTOM-GIT"><a href="#CUSTOM-GIT" class="headerlink" title="CUSTOM GIT"></a>CUSTOM GIT</h2><h2 id="IGNORE"><a href="#IGNORE" class="headerlink" title="IGNORE"></a>IGNORE</h2><pre><code>1. git add -f 文件
</code></pre><p>使用 -f 参数，强制添加被 .gitignore 忽略的文件到 Git。</p>
<pre><code>2. git check-ignore -v 文件
</code></pre><p>可能是 .gitignore 写得有问题，使用该命令找出到底哪个命令写错了。</p>
<pre><code>3. https://github.com/github/gitignore
</code></pre><p>GitHub 上的一个十分详细的针对数十种项目及语言的 .gitignore 文件列表。</p>
<p>注意：</p>
<p>忽略某些文件时，需要编写 .gitignore 文件；<br>.gitignore 文件本身要放到版本库里，并且可以对 .gitignore 做版本管理。<br>ALIAS</p>
<pre><code>1. git config --global alias.st status
</code></pre><p>使用 git st 代替 git status 命令。</p>
<pre><code>2. git config --global alias.co checkout
</code></pre><p>使用 git co 代替 git checkout 命令。</p>
<pre><code>3. git config --global alias.cm commit
</code></pre><p>使用 git cm 代替 git commit 命令。</p>
<pre><code>4. git config --global alias.br branch
</code></pre><p>使用 git br 代替 git branch 命令。</p>
<pre><code>5. git config --global alias.unstage &apos;reset HEAD --&apos;
</code></pre><p>使用 git unstage 文件 命令代替 git reset HEAD – 文件 命令。</p>
<pre><code>6. git config --global alias.last &apos;log -1&apos;
</code></pre><p>配置一个 git last 命令，让其显示最近一次的提交信息。</p>
<pre><code>`7. git config --global alias.lg &quot;log --color --graph --`pretty=format:&apos;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&apos; --abbrev-commit&quot;
</code></pre><p>丧心病狂地配置 git lg 命令，让显示 log 更加优雅，逼格更高。</p>
<ol>
<li>git config –global alias.visual ‘!gitk’<br>Git 只是简单地将别名替换为对应的命令。，如果想要执行外部命令而不是一个 Git 子命令，可以在命令前面加入 ! 符号。 如果自己要写一些与 Git 仓库协作的工具的话，那会很有用。貌似没什么卵用。</li>
</ol>
<h2 id="HELP"><a href="#HELP" class="headerlink" title="HELP"></a>HELP</h2><blockquote>
<ol>
<li>git help <key></key></li>
<li>git <key> –help</key></li>
<li>man git-<key> </key></li>
<li>git –help<h2 id="OTHERS"><a href="#OTHERS" class="headerlink" title="OTHERS"></a>OTHERS</h2></li>
</ol>
</blockquote>
<pre><code>1. git config -l 或 git config --list
</code></pre><p>列举所有 Git 能找到的配置，如果有重复的变量名，Git 会使用它找到的每一个变量的最后一个配置。</p>
<pre><code>2. git config &lt;key&gt;
</code></pre><p>检查 Git 的某一项配置。</p>
<pre><code>3. git config --glabal core.editor &lt;vim/emacs/...&gt;
</code></pre><p>配置默认文本编辑器。</p>
<pre><code>4. git config --global color.ui true 
</code></pre><p>让 Git 显示颜色，使命令输出看起来更醒目。</p>
<pre><code>5. git config core.ignorecase false
</code></pre><p>Git 是大小写不敏感的，如果要大小写敏感需要执行此命令。</p>
<pre><code>6. git config --global core.quotepath false
</code></pre><p>设置显示中文文件名。</p>
<pre><code>7. it config --global credential.helper cache
</code></pre><p>如果正在使用 HTTPS URL 来推送，Git 服务器会询问用户名与密码。 默认情况下它会在终端中提示服务器是否允许你进行推送。如果不想在每一次推送时都输入用户名与密码，可以设置一个 “credential cache”。 最简单的方式就是将其保存在内存中几分钟，使用该命令即可，貌似没什么卵用。</p>
<pre><code>8. git config --global user.name &quot;your name&quot;
   git config --global user.email &quot;your email&quot;
</code></pre><p>设置 commit 中的姓名和 email，去掉 –global 参数则为针对每个 repo 单独设定姓名和邮箱。</p>
<pre><code>9. git commit --author &quot;your name &lt;your email&gt;&quot;
</code></pre><p>以其他身份 commit。</p>
<pre><code>10. git mv old_filename new_filename
</code></pre><p>重命名文件。相当于下面三条命令：</p>
<ul>
<li>mv old_filename new_filename</li>
<li>git rm old_filename<ul>
<li>git add new_filename</li>
</ul>
</li>
</ul>
<hr>
<pre><code>11. git log 常用选项
</code></pre><ul>
<li><p>-p — 按补丁格式显示每个更新之间的差异。</p>
</li>
<li><p>-stat — 显示每次更新的文件修改统计信息。</p>
</li>
<li><p>-shortstat — 只显示 –stat 中最后的行数修改添加移除统计。</p>
</li>
<li><p>-name-only — 仅在提交信息后显示已修改的文件清单。</p>
</li>
<li><p>-name-status – 显示新增、修改、删除的文件清单。</p>
</li>
<li><p>-abbrev-commit — 仅显示 SHA-1 的前几个字符，而非所有的 40 个字符。</p>
</li>
<li><p>-relative-date — 使用较短的相对时间显示（比如，“2 weeks ago”）。</p>
</li>
<li><p>-graph — 显示 ASCII 图形表示的分支合并历史。</p>
</li>
<li><p>-pretty — 使用其他格式显示历史提交信息。可用的选项包括 oneline，short，full，fuller 和 format（后跟指定格式）。</p>
</li>
</ul>
<hr>
<pre><code>12. git log --pretty=format：&quot;%h - %an, %ar : %s&quot;
</code></pre><p>自定义 log 显示样式，也可带有 –graph 参数。常用的格式占位符写法及其代表的意义：</p>
<ul>
<li><p>%H — 提交对象（commit）的完整哈希字串</p>
</li>
<li><p>%h — 提交对象的简短哈希字串</p>
</li>
<li><p>%T — 树对象（tree）的完整哈希字串</p>
</li>
<li><p>%t — 树对象的简短哈希字串</p>
</li>
<li><p>%P — 父对象（parent）的完整哈希字串</p>
</li>
<li><p>%p — 父对象的简短哈希字串</p>
</li>
<li><p>%an — 作者（author）的名字</p>
</li>
<li><p>%ae — 作者的电子邮件地址</p>
</li>
<li><p>%ad — 作者修订日期（可以用 –date= 选项定制格式）</p>
</li>
<li><p>%ar — 作者修订日期，按多久以前的方式显示</p>
</li>
<li><p>%cn — 提交者(committer)的名字</p>
</li>
<li><p>%ce — 提交者的电子邮件地址</p>
</li>
<li><p>%cd — 提交日期</p>
</li>
<li><p>%cr — 提交日期，按多久以前的方式显示</p>
</li>
<li><p>%s — 提交说明</p>
</li>
</ul>
<hr>
<pre><code>13. git log --since=2.weeks
</code></pre><p>显示按照时间限制的 log 信息，这个时间格式可以是：“2008-01-15” 或 “2 years 1 day 3 minutes ago” 等。可用的参数还有：–until，–author，–grep(提交说明中的关键字)等。注意：如果要得到同时满足这两个选项搜索条件的提交，就必须用 –all-match 选项。否则，满足任意一个条件的提交都会被匹配出来。</p>
<pre><code>14. git log -Sfunction_name
</code></pre><p>显示添加或移除某一个特定函数的引用（字符串）的提交。</p>
<pre><code>15. 限制 git log 输出的选项
</code></pre><ul>
<li><p>-(n) — 仅显示最近的 n 条提交</p>
</li>
<li><p>–since, –after — 仅显示指定时间之后的提交。</p>
</li>
<li><p>–until, –before — 仅显示指定时间之前的提交。</p>
</li>
<li><p>–author — 仅显示指定作者相关的提交。</p>
</li>
<li><p>–committer — 仅显示指定提交者相关的提交。</p>
</li>
<li><p>–grep — 仅显示含指定关键字的提交</p>
</li>
<li><p>-S — 仅显示添加或移除了某个关键字的提交</p>
</li>
</ul>
<p>For example，git log –pretty=”%h - %s” –author=gitster –since=”2008-10-01” \ –before=”2008-11-01” –no-merges – t/，即为：查看 Git 仓库中，2008 年 10 月期间，作者提交的但未合并的测试文件。</p>
<h1 id="git"><a href="#git" class="headerlink" title="git"></a>git</h1><hr>
<p>未经许可不得转载，转载请注明zilianliuxue的blog,本人保留所有版权。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;ADD-AND-COMMIT&quot;&gt;&lt;a href=&quot;#ADD-AND-COMMIT&quot; class=&quot;headerlink&quot; title=&quot;ADD AND COMMIT&quot;&gt;&lt;/a&gt;ADD AND COMMIT&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;1. git init   
    
    </summary>
    
      <category term="git" scheme="http://zilianliuxue.github.io/categories/git/"/>
    
    
      <category term="git" scheme="http://zilianliuxue.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>安卓实战开发之JNI再深入了解</title>
    <link href="http://zilianliuxue.github.io/2016/08/06/%E5%AE%89%E5%8D%93%E5%AE%9E%E6%88%98%E5%BC%80%E5%8F%91%E4%B9%8BJNI%E5%86%8D%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3/"/>
    <id>http://zilianliuxue.github.io/2016/08/06/安卓实战开发之JNI再深入了解/</id>
    <published>2016-08-06T04:22:00.000Z</published>
    <updated>2016-08-06T04:22:52.891Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JNI重新认识"><a href="#JNI重新认识" class="headerlink" title="JNI重新认识"></a>JNI重新认识</h2><h3 id="头文件："><a href="#头文件：" class="headerlink" title="头文件："></a>头文件：</h3><p>1.头文件中存放的是对某个库中所定义的函数、宏(define)、类型、全局变量等进行声明，它类似于一份仓库清单。若用户程序中需要使用某个库中的函数，则只需要将该库所对应的头文件include到程序中即可。</p>
<p>2.头文件中定义的是库中所有函数的函数原型。而函数的具体实现则是在库文件中。</p>
<p>3.在连接器连接程序时，会依据用户程序中导入的头文件，将对应的库函数导入到程序中。头文件以.h为后缀名。 </p>
<p>头文件是给编译器用的，库文件是给连接器用的</p>
<p>###　函数库：</p>
<p>1.动态库：在编译用户程序时不会将用户程序内使用的库函数连接到用户程序的目标代码中，只有在运行时，且用户程序执行到相关函数时才会调用该函数库里的相应函数，因此动态函数库所产生的可执行文件比较小。</p>
<p>2.静态库：在编译用户程序时会将其内使用的库函数连接到目标代码中，程序运行时不再需要静态库。使用静态库生成可执行文件比较大。</p>
<p>为什么要进行交互?</p>
<p>首先，java语言提供的类库无法满足要求,且在数学运算,实时渲染的游戏上,音视频处理等方面上与c/c++相比效率稍低。然后，java语言无法直接操作硬件，c/c++代码不仅能操作硬件而且还能发挥硬件最佳性能。接着，使用java调用本地的c/c++代码所写的库，省去了重复开发的麻烦，并且可以利用很多开源的库提高程序效率。</p>
<h3 id="java-call-c"><a href="#java-call-c" class="headerlink" title="java  call c"></a>java  call c</h3><p>Java调用C/C++大概有这样几个步骤</p>
<ol>
<li>编写带有native方法的Java类, 使用javac工具编译Java类</li>
<li>使用javah来生成与native方法对应的头文件</li>
<li>实现相应的头文件, 并编译为动态链接库</li>
</ol>
<p>我们对这个还是很清楚的，看代码：</p>
<p>c代码：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line">//</div><div class="line">// Created by Administrator on 2016/8/1.</div><div class="line">//</div><div class="line">#include "JNIUtils.h"</div><div class="line">#include &lt;string.h&gt;</div><div class="line">#include&lt;stdio.h&gt;</div><div class="line">#include&lt;stdlib.h&gt;</div><div class="line">#include &lt;android/log.h&gt;</div><div class="line">/**</div><div class="line"> * 把一个jstring转换成一个c语言的char* 类型.</div><div class="line"> */</div><div class="line">char* _JString2CStr(JNIEnv* env, jstring jstr) &#123;</div><div class="line">char* rtn = NULL;</div><div class="line">jclass clsstring = (*env)-&gt;FindClass(env, "java/lang/String");</div><div class="line">jstring strencode = (*env)-&gt;NewStringUTF(env,"GB2312");</div><div class="line">jmethodID mid = (*env)-&gt;GetMethodID(env, clsstring, "getBytes", "(Ljava/lang/String;)[B");</div><div class="line">jbyteArray barr = (jbyteArray)(*env)-&gt;CallObjectMethod(env, jstr, mid, strencode); // String .getByte("GB2312");</div><div class="line">jsize alen = (*env)-&gt;GetArrayLength(env, barr);</div><div class="line">jbyte* ba = (*env)-&gt;GetByteArrayElements(env, barr, JNI_FALSE);</div><div class="line">if(alen &gt; 0) &#123;</div><div class="line">rtn = (char*)malloc(alen+1); //"\0"</div><div class="line">memcpy(rtn, ba, alen);</div><div class="line">rtn[alen]=0;</div><div class="line">&#125;</div><div class="line">(*env)-&gt;ReleaseByteArrayElements(env, barr, ba,0);</div><div class="line">return rtn;</div><div class="line">&#125;</div><div class="line"></div><div class="line">JNIEXPORT jint JNICALL Java_com_losileeya_jnimaster_JNIUtils_intMethod</div><div class="line">                         (JNIEnv *env, jclass jobj,jint num)&#123;</div><div class="line">            return num*num;</div><div class="line">   &#125;</div><div class="line">JNIEXPORT jboolean JNICALL Java_com_losileeya_jnimaster_JNIUtils_booleanMethod</div><div class="line">                             (JNIEnv * env, jclass jobj,jboolean boolean)&#123;</div><div class="line">            return !boolean;</div><div class="line">     &#125;</div><div class="line">JNIEXPORT jstring JNICALL Java_com_losileeya_jnimaster_JNIUtils_stringMethod</div><div class="line">                            (JNIEnv * env, jclass jobj,jstring jstr)&#123;</div><div class="line">//jstring jstr--&gt;char*</div><div class="line">char* fromJava = _JString2CStr(env,jstr);</div><div class="line">char* fromC = "add I am from C!! ";</div><div class="line">//字符串的拼接函数，会把拼接后的结果放在第一个参数里面</div><div class="line">strcat(fromJava,fromC);</div><div class="line"></div><div class="line">return (*env)-&gt;NewStringUTF(env,fromJava);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">JNIEXPORT jint JNICALL Java_com_losileeya_jnimaster_JNIUtils_intArrayMethod</div><div class="line">      (JNIEnv * env, jclass jobj,jintArray array)&#123;</div><div class="line">int i, sum = 0;</div><div class="line">jsize len = (*env)-&gt;GetArrayLength(env, array);</div><div class="line">jint *body = (*env)-&gt;GetIntArrayElements(env, array, 0);</div><div class="line"></div><div class="line">for (i = 0; i &lt; len; ++i)</div><div class="line">&#123;</div><div class="line">sum += body[i];</div><div class="line">&#125;</div><div class="line">(*env)-&gt;ReleaseIntArrayElements(env, array, body, 0);</div><div class="line">return sum;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>c++代码：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">/</div><div class="line">// Created by Administrator on 2016/8/1.</div><div class="line">//</div><div class="line">#include "JNIUtils.h"</div><div class="line">#include &lt;string.h&gt;</div><div class="line">#include&lt;stdlib.h&gt;</div><div class="line">#include&lt;stdio.h&gt;</div><div class="line">#include &lt;android/log.h&gt;</div><div class="line">/**</div><div class="line"> * 把一个jstring转换成一个c++语言的char* 类型.</div><div class="line"> */</div><div class="line">char* _JString2CStr(JNIEnv* env, jstring jstr) &#123;</div><div class="line">char* rtn = NULL;</div><div class="line">jclass clsstring = env-&gt;FindClass( "java/lang/String");</div><div class="line">jstring strencode = env-&gt;NewStringUTF("GB2312");</div><div class="line">jmethodID mid = env-&gt;GetMethodID( clsstring, "getBytes", "(Ljava/lang/String;)[B");</div><div class="line">jbyteArray barr = (jbyteArray)env-&gt;CallObjectMethod(jstr, mid, strencode); // String .getByte("GB2312");</div><div class="line">jsize alen = env-&gt;GetArrayLength( barr);</div><div class="line">jbyte* ba = env-&gt;GetByteArrayElements( barr, JNI_FALSE);</div><div class="line">if(alen &gt; 0) &#123;</div><div class="line">rtn = (char*)malloc(alen+1); //"\0"</div><div class="line">memcpy(rtn, ba, alen);</div><div class="line">rtn[alen]=0;</div><div class="line">&#125;</div><div class="line">env-&gt;ReleaseByteArrayElements(barr, ba,0);</div><div class="line">return rtn;</div><div class="line">&#125;</div><div class="line"></div><div class="line">JNIEXPORT jint JNICALL Java_com_losileeya_jnimaster_JNIUtils_intMethod(JNIEnv * env, jclass jobj,jint num)&#123;</div><div class="line">return num *num;</div><div class="line">&#125;</div><div class="line">JNIEXPORT jboolean JNICALL Java_com_losileeya_jnimaster_JNIUtils_booleanMethod(JNIEnv * env, jclass jobj,jboolean boolean)&#123;</div><div class="line">return !boolean;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">JNIEXPORT jstring JNICALL Java_com_losileeya_jnimaster_JNIUtils_stringMethod</div><div class="line">        (JNIEnv *env , jclass jobj, jstring jstr)&#123;</div><div class="line">//jstring jstr--&gt;char*</div><div class="line">char* fromJava = _JString2CStr(env,jstr);</div><div class="line">char* fromC = "add I am from C!! ";</div><div class="line">//字符串的拼接函数，会把拼接后的结果放在第一个参数里面</div><div class="line">strcat(fromJava,fromC);</div><div class="line">return env-&gt;NewStringUTF(fromJava);</div><div class="line">&#125;</div><div class="line">JNIEXPORT jint JNICALL Java_com_losileeya_jnimaster_JNIUtils_intArrayMethod(JNIEnv * env, jclass jobj,jintArray array)&#123;</div><div class="line">int sum = 0;</div><div class="line">jsize len = env-&gt;GetArrayLength(array);</div><div class="line">jint *arr = env-&gt;GetIntArrayElements(array, 0);</div><div class="line">for(int i = 0;i&lt;len; i++)&#123;</div><div class="line">sum+=arr[i];</div><div class="line">&#125;</div><div class="line">env-&gt;ReleaseIntArrayElements(array, arr,0);</div><div class="line">return sum;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从上面Native函数的命名上我们可以了解到JNI函数的命名规则： Java代码中的函数声明需要添加native 关键 字；Native的对应函数名要以“Java”开头，后面依次跟上Java的“package名”、“class名”、“函数名”，中间以下划线“” 分割，在package名中的“.”也要改为“_”。此外，关于函数的参数和返回值也有相应的规则。对于Java中的基本类型如int 、double 、char 等，在Native端都有相对应的类型来表示，如jint 、jdouble 、jchar 等；其他的对象类型则统统由jobject 来表示（String 是个例外，由于其使用广泛，故在Native代码中有jstring 这个类型来表示，正如在上例中返回值String 对应到Native代码中的返回值jstring ）。而对于Java中的数组，在Native中由jarray 对应，具体到基本类型和一般对象类型的数组则有jintArray 等和jobjectArray 分别对应（String 数组在这里没有例外，同样用jobjectArray 表示）。还有一点需要注意的是，在JNI的Native函数中，其前两个参数JNIEnv 和jobject<em> 是必需的——前者是一个JNIEnv 结构体的指针，这个结构体中定义了很多JNI的接口函数指针，使开发者可以使用JNI所定义的接口功能；后者指代的是调用这个JNI函数的Java对象，有点类似于C++中的this 指针。在上述两个参数之后，还需要根据Java端的函数声明依次对应添加参数。在上例中，Java中声明的JNI函数没有参数，则Native的对应函数只有类型为JNIEnv 和jobject</em> 的两个参数。</p>
<p>效果图：</p>
<p><img src="http://img.blog.csdn.net/20160806111333746" alt="这里写图片描述"></p>
<h3 id="c-call-java"><a href="#c-call-java" class="headerlink" title="c call java"></a>c call java</h3><p>一般来说，要在Native代码中访问Java对象，有如下几个步骤：</p>
<ol>
<li><p>得到该Java对象的类定义。JNI定义了jclass 这个类型来表示Java的类的定义，并提供了FindClass接口，根据类的完整的包路径即可得到其jclass 。</p>
</li>
<li><p>根据jclass 创建相应的对象实体，即jobject 。在Java中，创建一个新对象只需要使用new 关键字即可，但在Native代码中创建一个对象则需要两步：首先通过JNI接口GetMethodID得到该类的构造函数，然后利用NewObject接口构造出该类的一个实例对象。</p>
</li>
<li><p>访问jobject 中的成员变量或方法。访问对象的方法是先得到方法的Method ID，然后使用Call<type>Method 接口调用，这里Type对应相应方法的返回值——返回值为基本类型的都有相对应的接口，如CallIntMethod；其他的返回值（包括String） 则为CallObjectMethod。可以看出，创建对象实质上是调用对象的一个特殊方法，即构造函数。访问成员变量的步骤一样：首先 GetFieldID得到成员变量的ID，然后Get/Set<type>Field读/写变量值。</type></type></p>
</li>
</ol>
<p>寻找class对象, 并实例化</p>
<p>JVM在Java中都是自己启动的, 在C/C++中只能自己来启动了, 启动完之后的事情就和在Java中一样了, 不过要使用C/C++的语法.</p>
<p>获取class对象比较简单, FindClass(env, className).</p>
<pre><code>cls = (*env)-&gt;FindClass(env, &quot;xxxx&quot;);  
</code></pre><p>在Java中的类名格式是java.lang.String, 但是className的格式有点不同, 不是使用’.’作为分割, 而是’/‘, 即java/lang/String.</p>
<p>我们知道Java中构造函数有两种, 一种是默认的没有参数的, 一种是自定义的带有参数的. 对应的在C/C++中, 有两种调用构造函数的方法.</p>
<p>调用默认构造函数</p>
<pre><code>// 调用默认构造函数  obj = (*env)-&gt;AllocObjdect(env, cls);   
</code></pre><p>构造函数也是方法, 类似调用方法的方式.</p>
<pre><code>// 调用指定的构造函数, 构造函数的名字叫做&lt;init&gt;  mid = (*env)-&gt;GetMethodID(env, cls, &quot;&lt;init&gt;&quot;, &quot;()V&quot;);  obj = (*env)-&gt;NewObject(env, cls, mid);  
</code></pre><p>调用方法和修改属性</p>
<p>关于方法和属性是有两个ID与之对应, 这两个ID用来标识方法和属性.</p>
<pre><code>jmethodID mid;  jfieldID fid; 
</code></pre><p>方法分为静态和非静态的, 所以对应的有</p>
<pre><code>mid = (*env)-&gt;GetStaticMethodID(env, cls, &quot;sayHello&quot;, &quot;(Ljava/lang/String;)Ljava/lang/String;&quot;);     mid = (*env)-&gt;GetMethodID(env, cls, &quot;sayHello&quot;, &quot;()Ljava/lang/String;&quot;);   
</code></pre><p>上面两个方法是同名的, 都叫sayHello, 但是签名不同, 所以可以区分两个方法.</p>
<p>JNI的函数都是有一定规律的, Static就表示是静态, 没有表示非静态.</p>
<p>方法的调用如下</p>
<pre><code>jstring result = (jstring)(*env)-&gt;CallStaticObjectMethod(env, cls, mid, arg);     jstring result = (jstring)(*env)-&gt;CallObjectMethod(env, obj, mid);   
</code></pre><p>我们可以看到静态方法是只需要class对象, 不需要实例的, 而非静态方法需要使用我们之前实例化的对象.</p>
<p>属性也有静态和非静态, 示例中只有非静态的.</p>
<p>获取属性ID</p>
<pre><code>fid = (*env)-&gt;GetFieldID(env, cls, &quot;name&quot;, &quot;Ljava/lang/String;&quot;);   
</code></pre><p>改属性的值</p>
<pre><code>(*env)-&gt;SetObjectField(env, obj, fid, arg); // 修改属性  
</code></pre><p>关于jstring的说明</p>
<p>java的String都是使用了unicode, 是双字节的字符, 而C/C++中使用的单字节的字符。</p>
<p>从C转换为java的字符, 使用NewStringUTF方法</p>
<pre><code>jstring arg = (*env)-&gt;NewStringUTF(env, name);  
</code></pre><p>从java转换为C的字符, 使用GetStringUTFChars</p>
<pre><code>const char* str = (*env)-&gt;GetStringUTFChars(env, result, 0); 
</code></pre><p>下面我们来看代码：</p>
<p>c代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * Class:     com_losileeya_jnimaster_JNIUtils</div><div class="line"> * Method:    ccallJava_helloFromJava</div><div class="line"> * Signature: ()V</div><div class="line"> */</div><div class="line"><span class="function">JNIEXPORT <span class="keyword">void</span> JNICALL <span class="title">Java_com_losileeya_jnimaster_JNIUtils_ccallJava_1helloFromJava</span></span></div><div class="line">  <span class="params">(JNIEnv *env, jobject jobj)</span>&#123;</div><div class="line">    jclass jclazz=(*env)-&gt;FindClass(env,<span class="string">"com/losileeya/jnimaster/JNIUtils"</span>);</div><div class="line">    jmethodID jmethodid=(*env)-&gt;GetMethodID(env,jclazz,<span class="string">"helloFromJava"</span>,<span class="string">"()V"</span>);</div><div class="line">    jobject jobjs=(*env)-&gt;AllocObject(env,jclazz);</div><div class="line">    (*env)-&gt;CallVoidMethod(env,jobjs,jmethodid);</div><div class="line">  &#125;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"> * Class:     com_losileeya_jnimaster_JNIUtils</div><div class="line"> * Method:    ccallJava_add</div><div class="line"> * Signature: ()V</div><div class="line"> */</div><div class="line"><span class="function">JNIEXPORT <span class="keyword">void</span> JNICALL <span class="title">Java_com_losileeya_jnimaster_JNIUtils_ccallJava_1add</span></span></div><div class="line">  <span class="params">(JNIEnv *env, jobject jobj)</span>&#123;</div><div class="line"><span class="comment">//1.得到类对应的字节码</span></div><div class="line">    <span class="comment">//全类名，把.改成/</span></div><div class="line">    <span class="comment">//jclass      (*FindClass)(JNIEnv*, const char*);</span></div><div class="line">    jclass jclazz = (*env)-&gt;FindClass(env, <span class="string">"com/losileeya/jnimaster/JNIUtils"</span>);</div><div class="line"></div><div class="line">    <span class="comment">//2.得到要调用的方法名</span></div><div class="line">    <span class="comment">//第三个参数：方法名</span></div><div class="line">    <span class="comment">//第四个但是：方法签名</span></div><div class="line">    <span class="comment">//jmethodID   (*GetMethodID)(JNIEnv*, jclass, const char*, const char*);</span></div><div class="line">    jmethodID jmethodid = (*env)-&gt;GetMethodID(env, jclazz, <span class="string">"add"</span>,</div><div class="line">            <span class="string">"(II)I"</span>);</div><div class="line"></div><div class="line">    <span class="comment">//3.得到要调用的方法对应的类的实例</span></div><div class="line">    <span class="comment">// jobject     (*AllocObject)(JNIEnv*, jclass);</span></div><div class="line">    jobject jobjs = (*env)-&gt;AllocObject(env, jclazz);</div><div class="line">    <span class="comment">//4.调用方法</span></div><div class="line">    <span class="comment">// jint        (*CallIntMethod)(JNIEnv*, jobject, jmethodID, ...);</span></div><div class="line">      <span class="keyword">int</span> reuslt =  (*env)-&gt;CallIntMethod(env,jobjs,jmethodid,<span class="number">99</span>,<span class="number">1</span>);</div><div class="line"></div><div class="line"></div><div class="line">  &#125;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"> * Class:     com_losileeya_jnimaster_JNIUtils</div><div class="line"> * Method:    ccallJava_printString</div><div class="line"> * Signature: ()V</div><div class="line"> */</div><div class="line"><span class="function">JNIEXPORT <span class="keyword">void</span> JNICALL <span class="title">Java_com_losileeya_jnimaster_JNIUtils_ccallJava_1printString</span></span></div><div class="line">  <span class="params">(JNIEnv *env, jobject jobj)</span>&#123;</div><div class="line"> <span class="comment">//1.得到类对应的字节码</span></div><div class="line">        <span class="comment">//全类名，把.改成/</span></div><div class="line">        <span class="comment">//jclass      (*FindClass)(JNIEnv*, const char*);</span></div><div class="line">        jclass jclazz = (*env)-&gt;FindClass(env, <span class="string">"com/losileeya/jnimaster/JNIUtils"</span>);</div><div class="line"></div><div class="line">        <span class="comment">//2.得到要调用的方法名</span></div><div class="line">        <span class="comment">//第三个参数：方法名</span></div><div class="line">        <span class="comment">//第四个但是：方法签名</span></div><div class="line">        <span class="comment">//jmethodID   (*GetMethodID)(JNIEnv*, jclass, const char*, const char*);</span></div><div class="line">        jmethodID jmethodid = (*env)-&gt;GetMethodID(env, jclazz, <span class="string">"printString"</span>,</div><div class="line">                <span class="string">"(Ljava/lang/String;)V"</span>);</div><div class="line"></div><div class="line">        <span class="comment">//3.得到要调用的方法对应的类的实例</span></div><div class="line">        <span class="comment">// jobject     (*AllocObject)(JNIEnv*, jclass);</span></div><div class="line">        jobject jobjs = (*env)-&gt;AllocObject(env, jclazz);</div><div class="line">        <span class="comment">//4.调用方法</span></div><div class="line">        <span class="comment">// void        (*CallVoidMethod)(JNIEnv*, jobject, jmethodID, ...);</span></div><div class="line">        jstring text = (*env)-&gt;NewStringUTF(env,<span class="string">"I am from C!!"</span>);</div><div class="line">        (*env)-&gt;CallVoidMethod(env, jobjs, jmethodid,text); <span class="comment">//成功调用了Java中JNI里面的printString(String s);</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"> * Class:     com_losileeya_jnimaster_JNIUtils</div><div class="line"> * Method:    ccallJava_sayHello</div><div class="line"> * Signature: ()V</div><div class="line"> */</div><div class="line"><span class="function">JNIEXPORT <span class="keyword">void</span> JNICALL <span class="title">Java_com_losileeya_jnimaster_JNIUtils_ccallJava_1sayHello</span></span></div><div class="line">  <span class="params">(JNIEnv * env, jobject jobj)</span>&#123;</div><div class="line">     <span class="comment">//1.得到字节码</span></div><div class="line">     jclass jclazz = (*env)-&gt;FindClass(env,<span class="string">"com/losileeya/jnimaster/JNIUtils"</span>);</div><div class="line">     <span class="comment">//2.得到方法</span></div><div class="line">     jmethodID  jmethodid = (*env)-&gt;GetStaticMethodID(env,jclazz,<span class="string">"sayHello"</span>,<span class="string">"(Ljava/lang/String;)V"</span>);</div><div class="line"></div><div class="line">     <span class="comment">//3.调用</span></div><div class="line">     <span class="comment">//void        (*CallStaticVoidMethod)(JNIEnv*, jclass, jmethodID, ...);</span></div><div class="line">        jstring text = (*env)-&gt;NewStringUTF(env,<span class="string">"I am from C!! I am static method !!!"</span>);</div><div class="line">     (*env)-&gt;CallStaticVoidMethod(env,jclazz,jmethodid,text);<span class="comment">//成功调用了Java中JNI类的静态方法sayHello(String text)</span></div><div class="line"></div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>c++代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * Class:     com_losileeya_jnimaster_JNIUtils</div><div class="line"> * Method:    ccallJava_helloFromJava</div><div class="line"> * Signature: ()V</div><div class="line"> */</div><div class="line"><span class="function">JNIEXPORT <span class="keyword">void</span> JNICALL <span class="title">Java_com_losileeya_jnimaster_JNIUtils_ccallJava_1helloFromJava</span><span class="params">(JNIEnv*env,jobject jobj)</span></span>&#123;</div><div class="line">jclass jclazz = env-&gt;FindClass(<span class="string">"com/losileeya/jnimaster/JNIUtils"</span>);</div><div class="line">jmethodID jmethodid = env-&gt;GetMethodID(jclazz, <span class="string">"helloFromJava"</span>, <span class="string">"()V"</span>);</div><div class="line">jobject jobjs = env-&gt;AllocObject(jclazz);</div><div class="line">env-&gt;CallVoidMethod(jobjs, jmethodid);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"> * Class:     com_losileeya_jnimaster_JNIUtils</div><div class="line"> * Method:    ccallJava_add</div><div class="line"> * Signature: ()V</div><div class="line"> */</div><div class="line"><span class="function">JNIEXPORT <span class="keyword">void</span> JNICALL <span class="title">Java_com_losileeya_jnimaster_JNIUtils_ccallJava_1add</span><span class="params">(JNIEnv*env,jobject jobj)</span></span>&#123;</div><div class="line"><span class="comment">//1.得到类对应的字节码</span></div><div class="line"><span class="comment">//全类名，把.改成/</span></div><div class="line"><span class="comment">//jclass      (*FindClass)(JNIEnv*, const char*);</span></div><div class="line">jclass jclazz = env-&gt;FindClass( <span class="string">"com/losileeya/jnimaster/JNIUtils"</span>);</div><div class="line"></div><div class="line"><span class="comment">//2.得到要调用的方法名</span></div><div class="line"><span class="comment">//第三个参数：方法名</span></div><div class="line"><span class="comment">//第四个但是：方法签名</span></div><div class="line"><span class="comment">//jmethodID   (*GetMethodID)(JNIEnv*, jclass, const char*, const char*);</span></div><div class="line">jmethodID jmethodid = env-&gt;GetMethodID(jclazz, <span class="string">"add"</span>,</div><div class="line">                                          <span class="string">"(II)I"</span>);</div><div class="line"></div><div class="line"><span class="comment">//3.得到要调用的方法对应的类的实例</span></div><div class="line"><span class="comment">// jobject     (*AllocObject)(JNIEnv*, jclass);</span></div><div class="line">jobject jobjs = env-&gt;AllocObject(jclazz);</div><div class="line"><span class="comment">//4.调用方法</span></div><div class="line"><span class="comment">// jint        (*CallIntMethod)(JNIEnv*, jobject, jmethodID, ...);</span></div><div class="line"><span class="keyword">int</span> reusle =  env-&gt;CallIntMethod(jobjs,jmethodid,<span class="number">99</span>,<span class="number">1</span>);</div><div class="line"></div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"> * Class:     com_losileeya_jnimaster_JNIUtils</div><div class="line"> * Method:    ccallJava_printString</div><div class="line"> * Signature: ()V</div><div class="line"> */</div><div class="line"><span class="function">JNIEXPORT <span class="keyword">void</span> JNICALL <span class="title">Java_com_losileeya_jnimaster_JNIUtils_ccallJava_1printString</span><span class="params">(JNIEnv*env,jobject jobj)</span></span>&#123;</div><div class="line"><span class="comment">//1.得到类对应的字节码</span></div><div class="line"><span class="comment">//全类名，把.改成/</span></div><div class="line"><span class="comment">//jclass      (*FindClass)(JNIEnv*, const char*);</span></div><div class="line">jclass jclazz = env-&gt;FindClass( <span class="string">"com/losileeya/jnimaster/JNIUtils"</span>);</div><div class="line"></div><div class="line"><span class="comment">//2.得到要调用的方法名</span></div><div class="line"><span class="comment">//第三个参数：方法名</span></div><div class="line"><span class="comment">//第四个但是：方法签名</span></div><div class="line"><span class="comment">//jmethodID   (*GetMethodID)(JNIEnv*, jclass, const char*, const char*);</span></div><div class="line">jmethodID jmethodid = env-&gt;GetMethodID( jclazz, <span class="string">"printString"</span>,</div><div class="line">                                          <span class="string">"(Ljava/lang/String;)V"</span>);</div><div class="line"></div><div class="line"><span class="comment">//3.得到要调用的方法对应的类的实例</span></div><div class="line"><span class="comment">// jobject     (*AllocObject)(JNIEnv*, jclass);</span></div><div class="line">jobject jobjs = env-&gt;AllocObject(jclazz);</div><div class="line"><span class="comment">//4.调用方法</span></div><div class="line"><span class="comment">// void        (*CallVoidMethod)(JNIEnv*, jobject, jmethodID, ...);</span></div><div class="line">jstring text = env-&gt;NewStringUTF(<span class="string">"I am from C!!"</span>);</div><div class="line">env-&gt;CallVoidMethod( jobjs, jmethodid,text); <span class="comment">//成功调用了Java中JNI里面的printString(String s);</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"> * Class:     com_losileeya_jnimaster_JNIUtils</div><div class="line"> * Method:    ccallJava_sayHello</div><div class="line"> * Signature: ()V</div><div class="line"> */</div><div class="line"><span class="function">JNIEXPORT <span class="keyword">void</span> JNICALL <span class="title">Java_com_losileeya_jnimaster_JNIUtils_ccallJava_1sayHello</span><span class="params">(JNIEnv*env,jobject jobj)</span></span>&#123;</div><div class="line"><span class="comment">//1.得到字节码</span></div><div class="line">jclass jclazz = env-&gt;FindClass(<span class="string">"com/losileeya/jnimaster/JNIUtils"</span>);</div><div class="line"><span class="comment">//2.得到方法</span></div><div class="line">jmethodID  jmethodid = env-&gt;GetStaticMethodID(jclazz,<span class="string">"sayHello"</span>,<span class="string">"(Ljava/lang/String;)V"</span>);</div><div class="line"></div><div class="line"><span class="comment">//3.调用</span></div><div class="line"><span class="comment">//void        (*CallStaticVoidMethod)(JNIEnv*, jclass, jmethodID, ...);</span></div><div class="line">jstring text = env-&gt;NewStringUTF(<span class="string">"I am from C!! I am static method !!!"</span>);</div><div class="line">env-&gt;CallStaticVoidMethod(jclazz,jmethodid,text);<span class="comment">//成功调用了Java中JNI类的静态方法sayHello(String text)</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，上述代码和前面讲到的步骤完全相符。这里提一下编程时要注意的要点：1、FindClass要写明Java类的完整包路径，并将 “.”以“/”替换；2、GetMethodID的第三个参数是方法名（对于构造函数一律用“<init>”表示），第四个参数是方法的“签 名”，需要用一个字符串序列表示方法的参数（依声明顺序）和返回值信息。由于篇幅所限，这里不再具体说明如何根据方法的声明构造相应的“签名”，请参考 JNI的相关文档。</init></p>
<p>关于上面谈到的步骤再补充说明一下：在JNI规范中，如上这种使用NewObject创建的对象实例被称为“Local Reference”，它仅在创建它的Native代码作用域内有效，因此应避免在作用域外使用该实例及任何指向它的指针。如果希望创建的对象实例在作用 域外也能使用，则需要使用NewGlobalRef接口将其提升为“Global Reference”——需要注意的是，当Global Reference不再使用后，需要显式的释放，以便通知JVM进行垃圾收集。</p>
<p>顺便看下截图：<br><img src="http://i.imgur.com/vaS8Rb2.png" alt=""></p>
<h3 id="JNI-更新UI"><a href="#JNI-更新UI" class="headerlink" title="JNI 更新UI"></a>JNI 更新UI</h3><p>在Android使用Jni时，为了能够使UI线程即主线程与工作线程分开，经常要创建工作线程，然后在工作线程中调用C/C++函数.为了在C/C++ 函数中更新Android的UI，又时常使用回调。jni更新ui的话，我们就要注重jobject的使用了。</p>
<p>看代码：(使用)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> &#123;</div><div class="line">       System.loadLibrary(<span class="string">"CCallJavaForUI"</span>);</div><div class="line">   &#125;</div><div class="line">   <span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">       <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">       setContentView(R.layout.activity_main);</div><div class="line">   &#125;</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">CCallJavaForUI</span><span class="params">(View view)</span></span>&#123;</div><div class="line">       <span class="keyword">this</span>.callShowToast();</div><div class="line"></div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showToast</span><span class="params">()</span></span>&#123;</div><div class="line">       <span class="comment">//this - Activity的实例</span></div><div class="line">       <span class="comment">//startActitity();--&gt;</span></div><div class="line">       <span class="comment">//new MainActivity();</span></div><div class="line">       System.out.println(<span class="string">"showToast()----------"</span>);</div><div class="line">       Toast.makeText(<span class="keyword">this</span>, <span class="string">"showToast()---------"</span>, Toast.LENGTH_LONG).show();</div><div class="line">   &#125;</div><div class="line"></div><div class="line"></div><div class="line">   <span class="comment">/**</span></div><div class="line">    * 调用MainActivity中的showToast()方法</div><div class="line">    */</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">callShowToast</span><span class="params">()</span></span>;</div></pre></td></tr></table></figure>
<p>c代码 ：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">//</div><div class="line">// Created by Administrator on 2016/8/6.</div><div class="line">//</div><div class="line">#include "JNIUtils.h"</div><div class="line">#include&lt;stdio.h&gt;</div><div class="line">#include&lt;stdlib.h&gt;</div><div class="line">/**</div><div class="line"> * 调用java 中MainActivity中的showToast()方法</div><div class="line"> * jobject jobj:谁调用就是谁的实例，当前是JNI.this---&gt;MainActivity.this</div><div class="line"> */</div><div class="line">JNIEXPORT void JNICALL Java_com_losileeya_jniupdateui_MainActivity_callShowToast</div><div class="line">(JNIEnv * env, jobject jobj)&#123;</div><div class="line"></div><div class="line">//1.得到字节码</div><div class="line">jclass   jclazz = (*env)-&gt;FindClass(env,"com/losileeya/jniupdateui/MainActivity");</div><div class="line">//2.得到方法</div><div class="line">//jmethodID   (*GetMethodID)(JNIEnv*, jclass, const char*, const char*);</div><div class="line">jmethodID jmethodid = (*env)-&gt;GetMethodID(env,jclazz,"showToast","()V");</div><div class="line">//3.得到对象</div><div class="line">//      jobject jobjs = (*env)-&gt;AllocObject(env,jclazz);</div><div class="line">//4.调用方法</div><div class="line">//void        (*CallVoidMethod)(JNIEnv*, jobject, jmethodID, ...);</div><div class="line">(*env)-&gt;CallVoidMethod(env,jobj,jmethodid);//成功调用了中MainActivity中的showToast()方法</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>c++代码：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">//</div><div class="line">// Created by Administrator on 2016/8/6.</div><div class="line">//</div><div class="line">#include "JNIUtils.h"</div><div class="line">#include&lt;stdio.h&gt;</div><div class="line">#include&lt;stdlib.h&gt;</div><div class="line">/**</div><div class="line"> * 调用java 中MainActivity中的showToast()方法</div><div class="line"> * jobject jobj:谁调用就是谁的实例，当前是JNI.this---&gt;MainActivity.this</div><div class="line"> */</div><div class="line">JNIEXPORT void JNICALL Java_com_losileeya_jniupdateui_MainActivity_callShowToast</div><div class="line">(JNIEnv * env, jobject jobj)&#123;</div><div class="line"></div><div class="line">//1.得到字节码</div><div class="line">jclass   jclazz = (*env)-&gt;FindClass(env,"com/losileeya/jniupdateui/MainActivity");</div><div class="line">//2.得到方法</div><div class="line">//jmethodID   (*GetMethodID)(JNIEnv*, jclass, const char*, const char*);</div><div class="line">jmethodID jmethodid = (*env)-&gt;GetMethodID(env,jclazz,"showToast","()V");</div><div class="line">//3.得到对象</div><div class="line">//      jobject jobjs = (*env)-&gt;AllocObject(env,jclazz);</div><div class="line">//4.调用方法</div><div class="line">//void        (*CallVoidMethod)(JNIEnv*, jobject, jmethodID, ...);</div><div class="line">(*env)-&gt;CallVoidMethod(env,jobj,jmethodid);//成功调用了中MainActivity中的showToast()方法</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>效果图：<br><img src="http://img.blog.csdn.net/20160806120606952" alt="这里写图片描述"></p>
<h3 id="C和C-函数时的JNI使用区别"><a href="#C和C-函数时的JNI使用区别" class="headerlink" title="C和C++函数时的JNI使用区别"></a>C和C++函数时的JNI使用区别</h3><p>Java调用C和C++函数时的JNI使用区别:</p>
<p>注意：jni.h头文件中对于<em>.c  &amp;  </em>.cpp采用不同的定义</p>
<p>在C的定义中,env是一个两级指针,而在C++的定义中,env是个一级指针</p>
<p>C形式需要对env指针进行双重deferencing，而且须将env作为第一个参数传给jni函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">jclass (JNICALL *GetObjectClass)   (JNIEnv *env, jobject obj);</div><div class="line"></div><div class="line"><span class="function">jclass <span class="title">GetObjectClass</span><span class="params">(jobject obj)</span> </span></div><div class="line"></div><div class="line">&#123;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> functions-&gt;GetObjectClass(<span class="keyword">this</span>,obj);</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对于*.c</p>
<p>1.jclass test_class = (*env)-&gt;GetObjectClass(env, obj);</p>
<p>2.jfieldID id_num = (*env)-&gt;GetFieldID(env, test_class, “num”, “I”);</p>
<p>对于 *.cpp</p>
<p>1.jclass test_class = env-&gt;GetObjectClass(obj); </p>
<p>2.jfieldID id_num = env-&gt;GetFieldID(test_class, “num”, “I”);</p>
<p>在 C 中，</p>
<p>JNI 函数调用由“(*env)-&gt;”作前缀，目的是为了取出函数指针所引用的值。</p>
<p>在 C++ 中，</p>
<p>JNIEnv 类拥有处理函数指针查找的内联成员函数。</p>
<p>下面将说明这个细微的差异，其中，这两行代码访问同一函数，但每种语言都有各自的语法。</p>
<p>C 语法：jsize len = (*env)-&gt;GetArrayLength(env,array);</p>
<p>C++ 语法：jsize len =env-&gt;GetArrayLength(array);</p>
<pre><code>1、jni 可以调用本地C函数。
2、jni 调用C++库时，首先要将C++库提供的功能封装成纯C格式的函数接口，然后jni里面调用这些C接口。

总结，没什么区别。一个是 jni调用c。另一个是jni调用c，c调用c++。
</code></pre><p> 传送门：<a href="http://download.csdn.net/detail/u013278099/9596655" target="_blank" rel="external">jnimaster</a></p>
<p>##总结</p>
<p>JNI使用c和cpp的基本使用和了解就讲的差不多了，更多的学习可以去看jni的使用安全手册。</p>
<hr>
<p>未经许可不得转载，转载请注明zilianliuxue的blog,本人保留所有版权。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;JNI重新认识&quot;&gt;&lt;a href=&quot;#JNI重新认识&quot; class=&quot;headerlink&quot; title=&quot;JNI重新认识&quot;&gt;&lt;/a&gt;JNI重新认识&lt;/h2&gt;&lt;h3 id=&quot;头文件：&quot;&gt;&lt;a href=&quot;#头文件：&quot; class=&quot;headerlink&quot; titl
    
    </summary>
    
      <category term="android" scheme="http://zilianliuxue.github.io/categories/android/"/>
    
    
      <category term="jni ndk" scheme="http://zilianliuxue.github.io/tags/jni-ndk/"/>
    
  </entry>
  
  <entry>
    <title>安卓实战之如何快速搭建app架构</title>
    <link href="http://zilianliuxue.github.io/2016/05/23/%E5%AE%89%E5%8D%93%E5%AE%9E%E6%88%98%E4%B9%8B%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BAapp%E6%9E%B6%E6%9E%84/"/>
    <id>http://zilianliuxue.github.io/2016/05/23/安卓实战之如何快速搭建app架构/</id>
    <published>2016-05-23T14:44:00.000Z</published>
    <updated>2016-07-30T02:33:03.267Z</updated>
    
    <content type="html"><![CDATA[<h2 id="如何选择app架构（MVC-MVP-MVVM）"><a href="#如何选择app架构（MVC-MVP-MVVM）" class="headerlink" title="如何选择app架构（MVC/MVP/MVVM）"></a>如何选择app架构（MVC/MVP/MVVM）</h2><p>最近越来越多的人开始谈论架构。我周围的同事和工程师也是如此。尽管我还不是特别深入理解MVP，但是还是觉得比较牛逼,然后呢也想在公司的项目中去使用它。</p>
<h3 id="项目时间紧迫：快速开发框架（迫不得已）"><a href="#项目时间紧迫：快速开发框架（迫不得已）" class="headerlink" title="项目时间紧迫：快速开发框架（迫不得已）"></a>项目时间紧迫：快速开发框架（迫不得已）</h3><p>目前网络上也有一些针对Android的快速开发框架，下面介绍3个主要的快速开发框架。针对这些快速开发框架，个人认为可以参考，但并不推荐使用，因为App整体依赖一个个人维护的框架风险实在太大，框架存在一些学习成本，本身也不一定完全符合App的需求，使用后可能存在代码的臃肿，还有就是架构限制。</p>
<ul>
<li><p>Afinal</p>
<p>GitHub项目地址：<a href="https://github.com/yangfuhai/afinal" target="_blank" rel="external">Afinal</a></p>
<p>Afinal是一个Android的IOC，ORM框架，内置了四大模块功能：FinalAcitivity, FinalBitmap, FinalDb, FinalHttp。通过FinalActivity，可以通过注解的方式进行绑定UI和事件。通过FinalBitmap，可以方便的加载Bitmap图片，而无需考虑OOM等问题。通过FinalDB模块，通过一行代码就可以对Android的SQlite数据库进行增删改查。通过FinalHttp模块，可以以Ajax形式请求Http数据。   </p>
<blockquote>
<p>然而项目从去年就没有人更新维护了，ioc框架很多人不太喜欢而且性能不好。</p>
</blockquote>
</li>
</ul>
<ul>
<li>xUtils3.0</li>
</ul>
<p>GitHub项目地址：<a href="https://github.com/wyouflf/xUtils3" target="_blank" rel="external">xUtils3.0</a></p>
<ol>
<li>xUtils 支持超大文件(超过2G)上传，更全面的http请求协议支持(11种谓词)，拥有更加灵活的ORM，更多的事件注解支持且不受混淆影响…</li>
<li>xUtils 最低兼容Android 4.0 (api level 14). (Android 2.3?)</li>
<li><p>xUtils3变化较多所以建立了新的项目不在旧版(github.com/wyouflf/xUtils)上继续维护, 相对于旧版本:</p>
<ul>
<li>HTTP实现替换HttpClient为UrlConnection, 自动解析回调泛型, 更安全的断点续传策略.</li>
<li>支持标准的Cookie策略, 区分domain, path…</li>
<li>事件注解去除不常用的功能, 提高性能.</li>
<li>数据库api简化提高性能, 达到和greenDao一致的性能.</li>
<li>图片绑定支持gif(受系统兼容性影响, 部分gif文件只能静态显示), webp; 支持圆角, 圆形, 方形等裁剪, 支持自动旋转…<blockquote>
<p>可以看出xUtils3对于快速开发是一个不错的选择。</p>
</blockquote>
</li>
</ul>
</li>
</ol>
<h3 id="自己从零开始搭建app架构"><a href="#自己从零开始搭建app架构" class="headerlink" title="自己从零开始搭建app架构"></a>自己从零开始搭建app架构</h3><h4 id="简单的看下这三个架构模式："><a href="#简单的看下这三个架构模式：" class="headerlink" title="简单的看下这三个架构模式："></a>简单的看下这三个架构模式：</h4><ul>
<li>MVC：Model-View-Controller，经典模式，很容易理解，主要缺点有两个：<br>View对Model的依赖，会导致View也包含了业务逻辑；<br>Controller会变得很厚很复杂。</li>
<li>MVP：Model-View-Presenter，MVC的一个演变模式，将Controller换成了Presenter，主要为了解决上述第一个缺点，将View和Model解耦，不过第二个缺点依然没有解决。</li>
<li>MVVM：Model-View-ViewModel，是对MVP的一个优化模式，采用了双向绑定：View的变动，自动反映在ViewModel，反之亦然。<h4 id="面对众多的架构模式你会选择哪个？"><a href="#面对众多的架构模式你会选择哪个？" class="headerlink" title="面对众多的架构模式你会选择哪个？"></a>面对众多的架构模式你会选择哪个？</h4><blockquote>
<p>MVC，MVP还是MVVM？</p>
<p>越高级的模式复杂性越高，实现起来也越难。然后搭建项目时也是看项目的需求，别人说好你也有要实用才好，高效的实现项目的功能才是最好的架构模式。</p>
</blockquote>
</li>
</ul>
<p>那么，哪一个才是最好的呢？</p>
<blockquote>
<p>个人觉得适合你的才是最好的，不要去盲目的跟风，大家说mvp好那你就使用咯，没有实践就没有话语权，所以说用哪种架构模式本人不发表任何意见：任何模式的动机都是一样的，那就是如何避免复杂混乱的代码，让执行单元测试变得容易，创造高质量应用程序，开发维护更高效。</p>
</blockquote>
<p>在实际项目中思考架构时，也不会想着要用哪种模式，我只思考现阶段，以现有的人力资源和时间资源，如何才能更快更好地完成需求，适当考虑下如何为后期扩展或重构做准备。</p>
<h3 id="我项目中的架构"><a href="#我项目中的架构" class="headerlink" title="我项目中的架构"></a>我项目中的架构</h3><p>这是我上一个项目的包架构：</p>
<p><img src="http://i.imgur.com/KuUakbm.png" alt=""></p>
<p>当然咯，是按功能分的包，项目的功能不一样然后分包也不一样，但是基本大同小异。<br>所以确定架构分包的时候那就按你的需求来咯。  </p>
<p>从上面可以看出：架构分包的时候我们包括逻辑功能和基础功能（通用功能）。  </p>
<h4 id="基础功能模块："><a href="#基础功能模块：" class="headerlink" title="基础功能模块："></a>基础功能模块：</h4><ul>
<li><p>日志管理系统（LogManager）</p>
<blockquote>
<p>不管哪个项目都需要自己的一套日志管理，一是为了生产调试时能更加高效的查看过滤日志，二是为了打包发布的时候用开关控制日志是否打印。  （我的日志用的是凯子哥的：<a href="https://github.com/ZhaoKaiQiang/KLog" target="_blank" rel="external">Klog</a>）</p>
</blockquote>
</li>
<li>异常处理(crashManager)<blockquote>
<p>作用：当程序遇见异常情况时我们能够自定义异常处理，二是程序对不同的机型有不同的反应，那么测试时候可能没有发现但是我们可以把捕获的crash上传到服务器，便于异常收集和bug修复。</p>
</blockquote>
</li>
<li><p>utils(工具类)</p>
<blockquote>
<p>根据你的项目需求来合理定制你的工具类，将会对你的项目开发速度有很大的提升（反馈，版本校验更新你肯定能够用到）</p>
</blockquote>
<p>看下我上个项目的工具类：  </p>
</li>
</ul>
<p><img src="http://i.imgur.com/paV4K5g.png" alt=""> </p>
<ul>
<li>permission(权限管理系统)<blockquote>
<p>这功能是绝对项目中需要的，别告诉我你的项目还没有适配安卓6.0，适配了就肯定会有权限管理，我这里用的是<a href="http://blog.csdn.net/u013278099/article/details/50612266" target="_blank" rel="external"> 安卓6.0权限处理在项目中的实践</a>,也还可以吧，反正github上的权限管理的开源东西比较多，觉得合适就ok。</p>
</blockquote>
</li>
</ul>
<p>哈哈，这样你的基础功能都搭建好了，然后就是一些逻辑功能的封装了。</p>
<h4 id="逻辑功能模块："><a href="#逻辑功能模块：" class="headerlink" title="逻辑功能模块："></a>逻辑功能模块：</h4><p> 1.封装自己的application和baseActivity类，最大可能的节省代码，加入mvp的思想来架构。</p>
<p> 2.选择自己喜欢的网络请求框架并且适当合理的进行封装，加快开发的效率。</p>
<p> 3.针对带有滚动控件嵌套有可能产生的滑动冲突，或者显示不全我们优先自定义一下viewpager,listview,gridview等。</p>
<p> 4.封装listView或者recyclerView打造万能的适配器，觉得翔哥的封装的不错<a href="https://github.com/hongyangAndroid/baseAdapter" target="_blank" rel="external"> 打造万能的适配器</a>。</p>
<p> 5.一般的网络数据格式是json(我们就逗：普通数据json,刷卡交易数据xml),所以呢我json格式的用gson封装一下,xml格式暂时用的是pull解析后bean对象封装。</p>
<p> 6.数据库的封装，对数据苦要求不高的话可以用原生的简单封装一下curd就好了，要求高点的话那就用第三方的好了。</p>
<h3 id="开发过程中第三方开源库的抉择"><a href="#开发过程中第三方开源库的抉择" class="headerlink" title="开发过程中第三方开源库的抉择"></a>开发过程中第三方开源库的抉择</h3><h4 id="图片加载库："><a href="#图片加载库：" class="headerlink" title="图片加载库："></a>图片加载库：</h4><ul>
<li><p>Glide:相比较UIL，glide可以支持gif和短视频,支持与activity，fragment，application生命周期的联动,支持 okhttp、Volley</p>
</li>
<li><p>Fresco:三级缓存牛逼，对多帧动画图片支持更好，如 Gif、WebP</p>
</li>
<li><p>UIL：老牌的虽然不再更新维护，但功能强大</p>
<blockquote>
<p>根据你的项目需求选择，熟悉UIL就用它，个人推荐Glide</p>
</blockquote>
</li>
</ul>
<h4 id="网络请求库："><a href="#网络请求库：" class="headerlink" title="网络请求库："></a>网络请求库：</h4><ul>
<li><p>okhttp:</p>
<blockquote>
<p>okhttp是高性能的http库，支持同步、异步，而且实现了spdy、http2、websocket协议，api很简洁易用，和volley一样实现了http协议的缓存。</p>
</blockquote>
</li>
<li><p>retrofit:</p>
<blockquote>
<p>简化了网络请求流程，同时自己内部对OkHtttp客户端做了封装，同时2.x把之前1.x版本的部分不恰当职责都转移给OkHttp了(例如Log，目前用OkHttp的Interceptor来实现)</p>
</blockquote>
</li>
<li><p>volley:</p>
<blockquote>
<p>volley是一个简单的异步http库，仅此而已。缺点是不支持同步，这点会限制开发模式；不能post大数据，所以不适合用来上传文件。</p>
</blockquote>
</li>
</ul>
<p>个人建议使用retrofit，volley的通用性不高（资料最多）。</p>
<h4 id="事件总线库："><a href="#事件总线库：" class="headerlink" title="事件总线库："></a>事件总线库：</h4><blockquote>
<p>主要用来消息/事件的传递，却能实现组建之间的解耦。</p>
</blockquote>
<p>eventBus3.0和otto都是使用注解的方式（@Subscribe、@Produce）来标注方法，Otto更多的使用场景是在主线程中，相对是轻量级的。</p>
<blockquote>
<p>如果你对是不是轻量级不关心的话，我觉得两个差不多，但是还是很多人推荐使用otto。</p>
</blockquote>
<h4 id="依赖注入库："><a href="#依赖注入库：" class="headerlink" title="依赖注入库："></a>依赖注入库：</h4><p>butterknife8.0： <a href="https://github.com/JakeWharton/butterknife" target="_blank" rel="external">https://github.com/JakeWharton/butterknife</a><br>在任何项目中使用butterknife都是正确且没有问题的. 非常轻量级的库，原因是性能高节省代码，而且不是你们所想的反射机制实现的。</p>
<p>Dagger2：它是不具有动态性的（使用时完全不使用反射）但是生成的代码的简洁性和性能都是与手写的代码同水准的。</p>
<blockquote>
<p>2个都是很棒的，你可以选择额。</p>
</blockquote>
<h4 id="数据库存储："><a href="#数据库存储：" class="headerlink" title="数据库存储："></a>数据库存储：</h4><ul>
<li><p>LitePal：LitePal是一款开源的Android数据库框架，它采用了对象关系映射(ORM)的模式，LitePal很“轻”，jar包只有100k不到，使用起来也比较简单，源码地址为<a href="https://github.com/LitePalFramework/LitePal" target="_blank" rel="external">LitePal</a>地址,郭神开发的就是牛。</p>
</li>
<li><p>greenDAO:greenDAO与LitePal不同，其原理不是根据反射进行数据库的各项操作，而是一开始就人工生成业务需要的Model和DAO文件，业务中可以直接调用相应的DAO文件进行数据库操作，从而避免了因反射带来的性能损耗和效率低下。但是由于需要人工生成model和DAO文件，所以greenDAO的配置就略显复杂。</p>
</li>
</ul>
<blockquote>
<p>greenDAO用起来繁琐但是效率高点，LitePal用起来简单，所以你自己选择吧，个人还是觉得LitePal好用点。  </p>
</blockquote>
<h4 id="简单缓存"><a href="#简单缓存" class="headerlink" title="简单缓存"></a>简单缓存</h4><p><a href="">ASimpleCache</a>:ASimpleCache 是一个为android制定的 轻量级的 开源缓存框架。轻量到只有一个java文件（由十几个类精简而来）。</p>
<ul>
<li>可缓存普通的字符串、JsonObject、JsonArray、Bitmap、Drawable、序列化的java对象，和 byte数据。普通的字符串、JsonObject、JsonArray、Bitmap、Drawable、序列化的java对象，和 byte数据。</li>
<li>替换SharePreference当做配置文件</li>
<li>可以缓存网络请求数据，比如oschina的android客户端可以缓存http请求的新闻内容，缓存时间假设为1个小时，超时后自动失效，让客户端重新请求新的数据，减少客户端流量，同时减少服务器并发量。    </li>
</ul>
<p>哈哈项目需要的基本架构需要的开源库都有了，你可以放心的开发了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong><em>其实架构并不是那么难，也不要别人说怎么好就怎么干，你要相信总有一个东西是适合你的，打个比喻app架构就是盖房子，砖少就盖矮点吗，但是必须保证得结实，就像 框架不一定要强大但是必须健壮具有扩展性。</em></strong></p>
<hr>
<p>未经许可不得转载，转载请注明zilianliuxue的blog,本人保留所有版权。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;如何选择app架构（MVC-MVP-MVVM）&quot;&gt;&lt;a href=&quot;#如何选择app架构（MVC-MVP-MVVM）&quot; class=&quot;headerlink&quot; title=&quot;如何选择app架构（MVC/MVP/MVVM）&quot;&gt;&lt;/a&gt;如何选择app架构（MVC/MVP
    
    </summary>
    
      <category term="android" scheme="http://zilianliuxue.github.io/categories/android/"/>
    
    
      <category term="快速开发" scheme="http://zilianliuxue.github.io/tags/%E5%BF%AB%E9%80%9F%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>EventBus3.0带你乐翻天</title>
    <link href="http://zilianliuxue.github.io/2016/04/13/EventBus3.0%E5%B8%A6%E4%BD%A0%E4%B9%90%E7%BF%BB%E5%A4%A9/"/>
    <id>http://zilianliuxue.github.io/2016/04/13/EventBus3.0带你乐翻天/</id>
    <published>2016-04-13T11:48:00.000Z</published>
    <updated>2016-07-29T12:18:09.703Z</updated>
    
    <content type="html"><![CDATA[<p>你还在为刷新ui伤透脑筋吗？你还在琢磨如何使用接口回调或者handle来实现吗？如果你想到了使用观察者模式，那么一个很屌的Android开源框架EventBus：主要功能是替代Intent、Handler、BroadCast在Fragment、Activity、Service、线程之间传递消息。他的最牛逼优点是开销小，代码简洁，解耦代码。  </p>
<blockquote>
<p>如果你没有使用过eventBus那么很遗憾你错过了很多，不过没有关系3.0的正式发布，使用没有什么大不一样只是性能更好。</p>
<p><strong><em>个人建议直接使用3.0.0的版本，也不要去使用2.4和3.0beta1的版本了</em></strong>。</p>
</blockquote>
<p><img src="http://img.blog.csdn.net/20160411122147724" alt="">  </p>
<p>看图说话：</p>
<p>EventBus是一款针对Android优化的发布/订阅（publish/subscribe）事件总线。</p>
<blockquote>
<p>EventBus作为一个消息总线，有三个主要的元素：</p>
<ul>
<li>Event：事件。可以是任意类型的对象</li>
</ul>
</blockquote>
<ul>
<li>Subscriber：事件订阅者，接收特定的事件。在EventBus中，使用约定来指定事件订阅者以简化使用。即所有事件订阅都都是以onEvent开头的函数，具体来说，函数的名字是onEvent，onEventMainThread，onEventBackgroundThread，onEventAsync这四个，这个和</li>
</ul>
<p>ThreadMode（下面讲）有关。</p>
<ul>
<li>Publisher：事件发布者，用于通知 Subscriber 有事件发生。可以在任意线程任意位置发送事件，直接调用eventBus.post(Object) 方法，可以自己实例化 EventBus </li>
</ul>
<p>对象，但一般使用默认的单例就好了：EventBus.getDefault()， 根据post函数参数的类型，会自动调用订阅相应类型事件的函数。</p>
<h3 id="EventBus使用详解"><a href="#EventBus使用详解" class="headerlink" title="EventBus使用详解"></a>EventBus使用详解</h3><h4 id="EventBus使用步骤"><a href="#EventBus使用步骤" class="headerlink" title="EventBus使用步骤"></a>EventBus使用步骤</h4><h5 id="1-引入EventBus"><a href="#1-引入EventBus" class="headerlink" title="(1)引入EventBus:"></a>(1)引入EventBus:</h5><ul>
<li>引入eventbus:2.4.0（回顾老版本）</li>
</ul>
<blockquote>
<p>compile ‘de.greenrobot:eventbus:2.4.0’  </p>
</blockquote>
<ul>
<li>引入eventbus:3.0.0-beta1</li>
</ul>
<blockquote>
<p>compile ‘de.greenrobot:eventbus:3.0.0-beta1’   </p>
</blockquote>
<ul>
<li>引入eventbus:3.0.0</li>
</ul>
<blockquote>
<p>compile ‘org.greenrobot:eventbus:3.0.0’ </p>
</blockquote>
<h5 id="2-定义一个消息类，该类可以不继承任何基类也不需要实现任何接口。如："><a href="#2-定义一个消息类，该类可以不继承任何基类也不需要实现任何接口。如：" class="headerlink" title="(2)定义一个消息类，该类可以不继承任何基类也不需要实现任何接口。如："></a>(2)定义一个消息类，该类可以不继承任何基类也不需要实现任何接口。如：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">public class MessageEvent &#123;</div><div class="line"></div><div class="line">    ......</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="3-在需要订阅事件的地方注册事件"><a href="#3-在需要订阅事件的地方注册事件" class="headerlink" title="(3)在需要订阅事件的地方注册事件"></a>(3)在需要订阅事件的地方注册事件</h5><blockquote>
<p>EventBus.getDefault().register(this);</p>
</blockquote>
<h5 id="4-发送事件-即发送消息"><a href="#4-发送事件-即发送消息" class="headerlink" title="(4)发送事件:即发送消息"></a>(4)发送事件:即发送消息</h5><blockquote>
<p>EventBus.getDefault().post(messageEvent);</p>
</blockquote>
<h5 id="5-处理消息"><a href="#5-处理消息" class="headerlink" title="(5)处理消息"></a>(5)处理消息</h5><blockquote>
<p>在3.0之前，EventBus还没有使用注解方式。消息处理的方法也只能限定于onEvent、onEventMainThread、onEventBackgroundThread和onEventAsync，分别代表四种线程模型。而在3.0之后，消息处理的方法可以随便取名，但是需要添加一个注解@Subscribe，并且要指定线程模型（beta1默认为PostThread,正式版默认为POSTING），四种线程模型，下面会讲到。 </p>
</blockquote>
<p>注意，事件处理函数的访问权限必须为public，否则会报异常。</p>
<h6 id="EventBus3-0与EventBus2-4的区别"><a href="#EventBus3-0与EventBus2-4的区别" class="headerlink" title="EventBus3.0与EventBus2.4的区别"></a>EventBus3.0与EventBus2.4的区别</h6><ul>
<li>EventBus 2.4在使用方式</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"> public void onEvent(MessageEvent event) &#123;</div><div class="line"></div><div class="line">// 事件在哪个线程发布出来的，onEvent就会在这个线程中运行，也就是说发布事件和接收事件线程在同一个线程。使用这个方法时，在onEvent方法中不能执行耗时操作，如果执行耗时操作容易导致事件分发延迟。</div><div class="line"></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"> public void onEventMainThread(MessageEvent event) &#123;</div><div class="line"></div><div class="line">// 不论事件是在哪个线程中发布出来的，onEventMainThread都会在UI线程中执行，接收事件就会在UI线程中运行，这个在Android中是非常有用的，因为在Android中只能在UI线程中跟新UI，所以在onEvnetMainThread方法中是不能执行耗时操作的。</div><div class="line"></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">public void onEventBackgroundThread(MessageEvent event)&#123;</div><div class="line"></div><div class="line">//那么如果事件是在UI线程中发布出来的，那么onEventBackground就会在子线程中运行，如果事件本来就是子线程中发布出来的，那么onEventBackground函数直接在该子线程中执行。</div><div class="line"></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">public void onEventAsync(MessageEvent event)&#123;</div><div class="line"></div><div class="line">//使用这个函数作为订阅函数，那么无论事件在哪个线程发布，都会创建新的子线程在执行onEventAsync.</div><div class="line"></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<ul>
<li>在EventBus 3.0.0的使用是这样的</li>
</ul>
<p>(1) beta1版的写法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">  @Subscribe(threadMode = ThreadMode.PostThread) //3.0.0-beta1</div><div class="line"></div><div class="line">    public void onMessageEventPost(UserEvent event) &#123;</div><div class="line"></div><div class="line">    //默认方式, 在发送线程执行</div><div class="line"></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"> @Subscribe(threadMode = ThreadMode.MainThread) </div><div class="line"></div><div class="line">    public void onMessageEventMain(UserEvent event) &#123;</div><div class="line"></div><div class="line">    //在ui线程执行</div><div class="line"></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">   @Subscribe(threadMode = ThreadMode.BackgroundThread)</div><div class="line"></div><div class="line">    public void onMessageEventBackground(UserEvent event) &#123;</div><div class="line"></div><div class="line">     //在后台线程执行</div><div class="line"></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"> @Subscribe(threadMode = ThreadMode.Async) </div><div class="line"></div><div class="line">    public void onMessageEventAsync(UserEvent event) &#123;</div><div class="line"></div><div class="line">    //强制在后台执行</div><div class="line"></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>(2) 正式版的写法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">  @Subscribe(threadMode = ThreadMode.POSTING) //3.0.0</div><div class="line"></div><div class="line">    public void onMessageEventPost(UserEvent event) &#123;</div><div class="line"></div><div class="line">    //默认方式, 在发送线程执行</div><div class="line"></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"> @Subscribe(threadMode = ThreadMode.MAIN) </div><div class="line"></div><div class="line">    public void onMessageEventMain(UserEvent event) &#123;</div><div class="line"></div><div class="line">    //在ui线程执行</div><div class="line"></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">   @Subscribe(threadMode = ThreadMode.BACKGROUND)</div><div class="line"></div><div class="line">    public void onMessageEventBackground(UserEvent event) &#123;</div><div class="line"></div><div class="line">     //在后台线程执行</div><div class="line"></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"> @Subscribe(threadMode = ThreadMode.ASYNC) </div><div class="line"></div><div class="line">    public void onMessageEventAsync(UserEvent event) &#123;</div><div class="line"></div><div class="line">    //强制在后台执行</div><div class="line"></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h5 id="6-取消消息订阅"><a href="#6-取消消息订阅" class="headerlink" title="(6)取消消息订阅"></a>(6)取消消息订阅</h5><blockquote>
<p>EventBus.getDefault().unregister(this);</p>
</blockquote>
<h5 id="7-代码混淆"><a href="#7-代码混淆" class="headerlink" title="(7)代码混淆"></a>(7)代码混淆</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">-keepclassmembers class ** &#123;</div><div class="line"></div><div class="line">    public void onEvent*(**);</div><div class="line"></div><div class="line">    void onEvent*(**);</div><div class="line"></div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>看下简单实现的效果(带妹子的手机桌面)：</p>
<p><img src="http://img.blog.csdn.net/20160414135852593" alt=""></p>
<p>看下具体的代码使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">package com.losileeya.eventbusapp;</div><div class="line"></div><div class="line">import android.content.Intent;</div><div class="line"></div><div class="line">import android.os.Bundle;</div><div class="line"></div><div class="line">import android.support.v7.app.AppCompatActivity;</div><div class="line"></div><div class="line">import android.util.Log;</div><div class="line"></div><div class="line">import android.view.View;</div><div class="line"></div><div class="line">import android.widget.Button;</div><div class="line"></div><div class="line">import android.widget.TextView;</div><div class="line"></div><div class="line">import android.widget.Toast;</div><div class="line"></div><div class="line">import com.losileeya.eventbusapp.event.EventBusEvents;</div><div class="line"></div><div class="line">import org.greenrobot.eventbus.EventBus;</div><div class="line"></div><div class="line">import org.greenrobot.eventbus.Subscribe;</div><div class="line"></div><div class="line">import org.greenrobot.eventbus.ThreadMode;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">public class MainActivity extends AppCompatActivity implements View.OnClickListener &#123;</div><div class="line"></div><div class="line">    private Button btn_first,btn_second,btn_third,btn_sticky;</div><div class="line"></div><div class="line">    private TextView tv_toast;</div><div class="line"></div><div class="line">    private TextView tv_default,tv_main,tv_background,tv_asy;</div><div class="line"></div><div class="line">    @Override</div><div class="line"></div><div class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line"></div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line"></div><div class="line">        setContentView(R.layout.activity_main);</div><div class="line"></div><div class="line">        EventBus.getDefault().register(this);</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">        btn_first = (Button) findViewById(R.id.btn_first);</div><div class="line"></div><div class="line">        btn_second = (Button) findViewById(R.id.btn_second);</div><div class="line"></div><div class="line">        btn_third = (Button) findViewById(R.id.btn_third);</div><div class="line"></div><div class="line">        btn_sticky= (Button) findViewById(R.id.btn_sticky);</div><div class="line"></div><div class="line">        tv_toast= (TextView) findViewById(R.id.tv_toast);</div><div class="line"></div><div class="line">        tv_default= (TextView) findViewById(R.id.tv_default);</div><div class="line"></div><div class="line">        tv_main= (TextView) findViewById(R.id.tv_main);</div><div class="line"></div><div class="line">        tv_background= (TextView) findViewById(R.id.tv_background);</div><div class="line"></div><div class="line">        tv_asy= (TextView) findViewById(R.id.tv_asy);</div><div class="line"></div><div class="line">        btn_first.setOnClickListener(this);</div><div class="line"></div><div class="line">        btn_second.setOnClickListener(this);</div><div class="line"></div><div class="line">        btn_third.setOnClickListener(this);</div><div class="line"></div><div class="line">        btn_sticky.setOnClickListener(this);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    @Override</div><div class="line"></div><div class="line">    public void onClick(View v) &#123;</div><div class="line"></div><div class="line">        Intent intent;</div><div class="line"></div><div class="line">        switch (v.getId())&#123;</div><div class="line"></div><div class="line">            case R.id.btn_first:</div><div class="line"></div><div class="line">                intent = new Intent(MainActivity.this,FirstActivity.class);</div><div class="line"></div><div class="line">                startActivity(intent);</div><div class="line"></div><div class="line">                break;</div><div class="line"></div><div class="line">            case R.id.btn_second:</div><div class="line"></div><div class="line">                intent = new Intent(MainActivity.this,SecondActivity.class);</div><div class="line"></div><div class="line">                startActivity(intent);</div><div class="line"></div><div class="line">                break;</div><div class="line"></div><div class="line">            case R.id.btn_third:</div><div class="line"></div><div class="line">                intent = new Intent(MainActivity.this,ThirdActivity.class);</div><div class="line"></div><div class="line">                startActivity(intent);</div><div class="line"></div><div class="line">                break;</div><div class="line"></div><div class="line">            case R.id.btn_sticky:</div><div class="line"></div><div class="line">                intent = new Intent(MainActivity.this,StickyActivity.class);</div><div class="line"></div><div class="line">                startActivity(intent);</div><div class="line"></div><div class="line">                break;</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Subscribe(threadMode = ThreadMode.MAIN,priority = 1)</div><div class="line"></div><div class="line">    public void onMessageMain(EventBusEvents.FirstEvent firstEvent)&#123;</div><div class="line"></div><div class="line">        tv_toast.setText(firstEvent.getValue());</div><div class="line"></div><div class="line">        Toast.makeText(this, firstEvent.getValue(),Toast.LENGTH_SHORT).show();</div><div class="line"></div><div class="line">        Log.e(&quot;zy&quot;, &quot;onEventMainThread--&gt;&quot; +&quot;priority = 1,&quot;+ Thread.currentThread().getId());</div><div class="line"></div><div class="line">        tv_main.setText(Thread.currentThread().getName()+&quot;----&gt;&quot;+Thread.currentThread().getId());</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line"></div><div class="line">     * 使用onEvent来接收事件，那么接收事件和分发事件在一个线程中执行</div><div class="line"></div><div class="line">     * param event</div><div class="line"></div><div class="line">     */</div><div class="line"></div><div class="line">    @Subscribe(threadMode = ThreadMode.POSTING,priority = 2)</div><div class="line"></div><div class="line">    public void onPost(EventBusEvents.FirstEvent firstEvent) &#123;</div><div class="line"></div><div class="line">        Log.e(&quot;zy&quot;, &quot;onEventPost--&gt;&quot; +&quot;priority = 2,&quot;+ Thread.currentThread().getId());</div><div class="line"></div><div class="line">        tv_default.setText(Thread.currentThread().getName()+&quot;----&gt;&quot;+Thread.currentThread().getId());</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    /**</div><div class="line"></div><div class="line">     * 使用onEventBackgroundThread来接收事件，如果分发事件在子线程运行，那么接收事件直接在同样线程</div><div class="line"></div><div class="line">     * 运行，如果分发事件在UI线程，那么会启动一个子线程运行接收事件</div><div class="line"></div><div class="line">     * param event</div><div class="line"></div><div class="line">     */</div><div class="line"></div><div class="line">    @Subscribe(threadMode = ThreadMode.BACKGROUND,priority = 3)</div><div class="line"></div><div class="line">    public void onBackgroundThread(EventBusEvents.FirstEvent firstEvent)</div><div class="line"></div><div class="line">    &#123;</div><div class="line"></div><div class="line">        Log.e(&quot;zy&quot;, &quot;onEventBackgroundThread--&gt;&quot; +&quot;priority = 3,&quot;+ Thread.currentThread().getId());</div><div class="line"></div><div class="line">        tv_background.setText(Thread.currentThread().getName()+&quot;----&gt;&quot;+Thread.currentThread().getId());</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line"></div><div class="line">     * 使用onEventAsync接收事件，无论分发事件在（UI或者子线程）哪个线程执行，接收都会在另外一个子线程执行</div><div class="line"></div><div class="line">     * param event</div><div class="line"></div><div class="line">     */</div><div class="line"></div><div class="line">    @Subscribe(threadMode = ThreadMode.ASYNC,priority = 4)</div><div class="line"></div><div class="line">    public void onAsync(EventBusEvents.FirstEvent firstEvent) &#123;</div><div class="line"></div><div class="line">        Log.e(&quot;zy&quot;, &quot;onEventAsync--&gt;&quot;+&quot;priority = 4,&quot; + Thread.currentThread().getId());</div><div class="line"></div><div class="line">        tv_asy.setText(Thread.currentThread().getName()+&quot;----&gt;&quot;+Thread.currentThread().getId());</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    @Override</div><div class="line"></div><div class="line">    protected void onDestroy() &#123;</div><div class="line"></div><div class="line">        super.onDestroy();</div><div class="line"></div><div class="line">        EventBus.getDefault().unregister(this);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">package com.losileeya.eventbusapp;</div><div class="line"></div><div class="line">import android.os.Bundle;</div><div class="line"></div><div class="line">import android.support.v7.app.AppCompatActivity;</div><div class="line"></div><div class="line">import android.view.View;</div><div class="line"></div><div class="line">import android.widget.Button;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">import com.losileeya.eventbusapp.event.EventBusEvents;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">import org.greenrobot.eventbus.EventBus;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">public class FirstActivity extends AppCompatActivity &#123;</div><div class="line"></div><div class="line">    private Button btn_showDownLoad;</div><div class="line"></div><div class="line">    @Override</div><div class="line"></div><div class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line"></div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line"></div><div class="line">        setContentView(R.layout.activity_first);</div><div class="line"></div><div class="line">        btn_showDownLoad = (Button) findViewById(R.id.btn_toast);</div><div class="line"></div><div class="line">        btn_showDownLoad.setOnClickListener(new View.OnClickListener() &#123;</div><div class="line"></div><div class="line">            @Override</div><div class="line"></div><div class="line">            public void onClick(View v) &#123;</div><div class="line"></div><div class="line">                new Thread(new Runnable() &#123;</div><div class="line"></div><div class="line">                    @Override</div><div class="line"></div><div class="line">                    public void run() &#123;</div><div class="line"></div><div class="line">                        try &#123;</div><div class="line"></div><div class="line">                            Thread.sleep(1000);</div><div class="line"></div><div class="line">                        &#125; catch (InterruptedException e) &#123;</div><div class="line"></div><div class="line">                            e.printStackTrace();</div><div class="line"></div><div class="line">                        &#125;</div><div class="line"></div><div class="line">                        EventBus.getDefault().post(new EventBusEvents.FirstEvent(&quot;我是从网络下载的文本&quot;));</div><div class="line"></div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                &#125;).start();</div><div class="line"></div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125;);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看出哪里需要发送消息，那么就必须使用：</p>
<blockquote>
<p> EventBus.getDefault().post(your event)  </p>
</blockquote>
<p>然后你只需要订阅就好了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">   @Subscribe(threadMode = ThreadMode.MAIN)</div><div class="line"></div><div class="line">    public void onMessageMain(EventBusEvents.FirstEvent firstEvent)&#123;</div><div class="line"></div><div class="line">        tv_toast.setText(firstEvent.getValue());</div><div class="line"></div><div class="line">        Toast.makeText(this, firstEvent.getValue(),Toast.LENGTH_SHORT).show();</div><div class="line"></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="事件的优先级处理"><a href="#事件的优先级处理" class="headerlink" title="事件的优先级处理"></a>事件的优先级处理</h3><blockquote>
<p>接收事件方法可以通过@Subscribe(priority = 1)</p>
<p>priority的值来决定接收事件的顺序,数值越高优先级越大,默认优先级为0.   </p>
</blockquote>
<p><strong><em>(注意这里优先级设置只有在同一个线程模型才有效)  </em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">   @Subscribe(threadMode = ThreadMode.ASYNC,priority = 4)</div><div class="line"></div><div class="line">    public void onAsync(EventBusEvents.FirstEvent firstEvent) &#123;</div><div class="line"></div><div class="line">        Log.e(&quot;zy&quot;, &quot;onEventAsync--&gt;&quot;+&quot;priority = 4,&quot; + Thread.currentThread().getId());</div><div class="line"></div><div class="line">        tv_asy.setText(Thread.currentThread().getName()+&quot;----&gt;&quot;+Thread.currentThread().getId());</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Subscribe(threadMode = ThreadMode.ASYNC,priority = 2)</div><div class="line"></div><div class="line">    public void onAsync1(EventBusEvents.FirstEvent firstEvent) &#123;</div><div class="line"></div><div class="line">        Log.e(&quot;zy&quot;, &quot;onEventAsync1--&gt;&quot;+&quot;priority = 2,&quot; + Thread.currentThread().getId());</div><div class="line"></div><div class="line">        tv_asy.setText(Thread.currentThread().getName()+&quot;----&gt;&quot;+Thread.currentThread().getId());</div><div class="line"></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>同一模式下优先级高的先执行，看图：  </p>
<p><img src="http://img.blog.csdn.net/20160414131606685" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">  @Subscribe(threadMode = ThreadMode.MAIN,priority = 1)</div><div class="line"></div><div class="line">    public void onMessageMain(EventBusEvents.FirstEvent firstEvent)&#123;</div><div class="line"></div><div class="line">        tv_toast.setText(firstEvent.getValue());</div><div class="line"></div><div class="line">        Toast.makeText(this, firstEvent.getValue(),Toast.LENGTH_SHORT).show();</div><div class="line"></div><div class="line">        Log.e(&quot;zy&quot;, &quot;onEventMainThread--&gt;&quot; +&quot;priority = 1,&quot;+ Thread.currentThread().getId());</div><div class="line"></div><div class="line">        tv_main.setText(Thread.currentThread().getName()+&quot;----&gt;&quot;+Thread.currentThread().getId());</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line"></div><div class="line">     * 使用onEvent来接收事件，那么接收事件和分发事件在一个线程中执行</div><div class="line"></div><div class="line">     * param event</div><div class="line"></div><div class="line">     */</div><div class="line"></div><div class="line">    @Subscribe(threadMode = ThreadMode.POSTING,priority = 2)</div><div class="line"></div><div class="line">    public void onPost(EventBusEvents.FirstEvent firstEvent) &#123;</div><div class="line"></div><div class="line">        Log.e(&quot;zy&quot;, &quot;onEventPost--&gt;&quot; +&quot;priority = 2,&quot;+ Thread.currentThread().getId());</div><div class="line"></div><div class="line">        tv_default.setText(Thread.currentThread().getName()+&quot;----&gt;&quot;+Thread.currentThread().getId());</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    /**</div><div class="line"></div><div class="line">     * 使用onEventBackgroundThread来接收事件，如果分发事件在子线程运行，那么接收事件直接在同样线程</div><div class="line"></div><div class="line">     * 运行，如果分发事件在UI线程，那么会启动一个子线程运行接收事件</div><div class="line"></div><div class="line">     * param event</div><div class="line"></div><div class="line">     */</div><div class="line"></div><div class="line">    @Subscribe(threadMode = ThreadMode.BACKGROUND,priority = 3)</div><div class="line"></div><div class="line">    public void onBackgroundThread(EventBusEvents.FirstEvent firstEvent)</div><div class="line"></div><div class="line">    &#123;</div><div class="line"></div><div class="line">        Log.e(&quot;zy&quot;, &quot;onEventBackgroundThread--&gt;&quot; +&quot;priority = 3,&quot;+ Thread.currentThread().getId());</div><div class="line"></div><div class="line">        tv_background.setText(Thread.currentThread().getName()+&quot;----&gt;&quot;+Thread.currentThread().getId());</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line"></div><div class="line">     * 使用onEventAsync接收事件，无论分发事件在（UI或者子线程）哪个线程执行，接收都会在另外一个子线程执行</div><div class="line"></div><div class="line">     * param event</div><div class="line"></div><div class="line">     */</div><div class="line"></div><div class="line">    @Subscribe(threadMode = ThreadMode.ASYNC,priority = 4)</div><div class="line"></div><div class="line">    public void onAsync(EventBusEvents.FirstEvent firstEvent) &#123;</div><div class="line"></div><div class="line">        Log.e(&quot;zy&quot;, &quot;onEventAsync--&gt;&quot;+&quot;priority = 4,&quot; + Thread.currentThread().getId());</div><div class="line"></div><div class="line">        tv_asy.setText(Thread.currentThread().getName()+&quot;----&gt;&quot;+Thread.currentThread().getId());</div><div class="line"></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>不同ThreadMode运行下结果看图：</p>
<p><img src="http://img.blog.csdn.net/20160414130827853" alt=""> </p>
<blockquote>
<p>事件优先级不影响不同线程模型订阅事件顺序.</p>
</blockquote>
<h3 id="EventBus粘性事件"><a href="#EventBus粘性事件" class="headerlink" title="EventBus粘性事件"></a>EventBus粘性事件</h3><p>除了上面讲的普通事件外，EventBus还支持发送黏性事件。简单讲，就是在发送事件之后再订阅该事件也能收到该事件.粘性事件能够收到订阅之前发送的消息。但是它只能收到最新的一次消息，比如说在未订阅之前已经发送了多条黏性消息了，然后再订阅只能收到最近的一条消息。</p>
<blockquote>
<p>注册和注销方法一样,发送事件和订阅事件有些区别   </p>
</blockquote>
<p>发送事件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">EventBus.getDefault().postSticky(you event);</div></pre></td></tr></table></figure>
<p>订阅粘性事件 默认sticky为false</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">@Subscribe(sticky = true)</div><div class="line"></div><div class="line">    public void onPostThread(Event.Message msg) &#123;</div><div class="line"></div><div class="line">        .....</div><div class="line"></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>看荔枝：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">package com.losileeya.eventbusapp;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">import android.os.Bundle;</div><div class="line"></div><div class="line">import android.support.v7.app.AppCompatActivity;</div><div class="line"></div><div class="line">import android.util.Log;</div><div class="line"></div><div class="line">import android.view.View;</div><div class="line"></div><div class="line">import android.widget.Button;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">import org.greenrobot.eventbus.EventBus;</div><div class="line"></div><div class="line">import org.greenrobot.eventbus.Subscribe;</div><div class="line"></div><div class="line">import org.greenrobot.eventbus.ThreadMode;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">/**</div><div class="line"></div><div class="line"> * Created  on 2016/4/14.</div><div class="line"></div><div class="line"> */</div><div class="line"></div><div class="line">public class StickyActivity extends AppCompatActivity &#123;</div><div class="line"></div><div class="line">    private int index = 0;</div><div class="line"></div><div class="line">    @Override</div><div class="line"></div><div class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line"></div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line"></div><div class="line">        setContentView(R.layout.activity_sticky);</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">        Button bt_send = (Button) findViewById(R.id.bt_send);</div><div class="line"></div><div class="line">        Button bt_regist = (Button) findViewById(R.id.bt_regist);</div><div class="line"></div><div class="line">        Button bt_unregist = (Button) findViewById(R.id.bt_unregist);</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">        bt_send.setOnClickListener(new View.OnClickListener() &#123;</div><div class="line"></div><div class="line">            @Override</div><div class="line"></div><div class="line">            public void onClick(View v) &#123;</div><div class="line"></div><div class="line">                Log.i(&quot;zy&quot;, &quot;POSTING----&gt;&quot; + index);</div><div class="line"></div><div class="line">                EventBus.getDefault().postSticky(&quot;zy----&gt;&quot; + index++);</div><div class="line"></div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125;);</div><div class="line"></div><div class="line">        bt_regist.setOnClickListener(new View.OnClickListener() &#123;</div><div class="line"></div><div class="line">            @Override</div><div class="line"></div><div class="line">            public void onClick(View v) &#123;</div><div class="line"></div><div class="line">                EventBus.getDefault().register(StickyActivity.this);</div><div class="line"></div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125;);</div><div class="line"></div><div class="line">        bt_unregist.setOnClickListener(new View.OnClickListener() &#123;</div><div class="line"></div><div class="line">            @Override</div><div class="line"></div><div class="line">            public void onClick(View v) &#123;</div><div class="line"></div><div class="line">                EventBus.getDefault().unregister(StickyActivity.this);</div><div class="line"></div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125;);</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    @Subscribe(threadMode = ThreadMode.POSTING,sticky = true)</div><div class="line"></div><div class="line">    public void onPostThread(String msg) &#123;</div><div class="line"></div><div class="line">        Log.i(&quot;zy&quot;, &quot;onEventPostThread----&gt;&quot; + msg);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    @Subscribe(threadMode = ThreadMode.MAIN,sticky = true)</div><div class="line"></div><div class="line">    public void onMainThread(String msg) &#123;</div><div class="line"></div><div class="line">        Log.i(&quot;zy&quot;, &quot;onEventMainThread----&gt;&quot; + msg);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    @Subscribe(threadMode = ThreadMode.BACKGROUND,sticky = true)</div><div class="line"></div><div class="line">    public void onBackgroundThread(String msg) &#123;</div><div class="line"></div><div class="line">        Log.i(&quot;zy&quot;, &quot;onEventBackgroundThread----&gt;&quot; + msg);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    @Subscribe(threadMode = ThreadMode.ASYNC,sticky = true)</div><div class="line"></div><div class="line">    public void onAsyncThread(String msg) &#123;</div><div class="line"></div><div class="line">        Log.i(&quot;zy&quot;, &quot;onEventAsyncThread----&gt;&quot; +msg);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>activity_sticky.xml</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line"></div><div class="line">&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line"></div><div class="line">    android:layout_width=&quot;match_parent&quot;</div><div class="line"></div><div class="line">    android:layout_height=&quot;match_parent&quot;</div><div class="line"></div><div class="line">    android:orientation=&quot;vertical&quot;</div><div class="line"></div><div class="line">    &gt;</div><div class="line"></div><div class="line">    &lt;Button</div><div class="line"></div><div class="line">        android:id=&quot;@+id/bt_send&quot;</div><div class="line"></div><div class="line">        android:layout_width=&quot;match_parent&quot;</div><div class="line"></div><div class="line">        android:layout_height=&quot;wrap_content&quot;</div><div class="line"></div><div class="line">        android:text=&quot;发送事件&quot; /&gt;</div><div class="line"></div><div class="line">    &lt;Button</div><div class="line"></div><div class="line">        android:id=&quot;@+id/bt_regist&quot;</div><div class="line"></div><div class="line">        android:layout_marginTop=&quot;10dp&quot;</div><div class="line"></div><div class="line">        android:layout_width=&quot;match_parent&quot;</div><div class="line"></div><div class="line">        android:layout_height=&quot;wrap_content&quot;</div><div class="line"></div><div class="line">        android:text=&quot;注册&quot; /&gt;</div><div class="line"></div><div class="line">    &lt;Button</div><div class="line"></div><div class="line">        android:id=&quot;@+id/bt_unregist&quot;</div><div class="line"></div><div class="line">        android:layout_marginTop=&quot;10dp&quot;</div><div class="line"></div><div class="line">        android:layout_width=&quot;match_parent&quot;</div><div class="line"></div><div class="line">        android:layout_height=&quot;wrap_content&quot;</div><div class="line"></div><div class="line">        android:text=&quot;注销&quot; /&gt;</div><div class="line"></div><div class="line">&lt;/LinearLayout&gt;</div></pre></td></tr></table></figure>
<p>看我的执行步骤：  </p>
<ul>
<li>首先在未订阅的情况下点击发送按钮发送一个黏性事件，然后点击订阅,打印如下: —&gt;  </li>
</ul>
<p><img src="http://img.blog.csdn.net/20160414132505136" alt="">   </p>
<ul>
<li>我们连续点击发送事件按钮发送黏性事件，然后再点击注册按钮订阅，打印结果如下：—&gt;    </li>
</ul>
<p><img src="http://img.blog.csdn.net/20160414132636204" alt=""></p>
<p>是不是接到了最后一个事件。</p>
<h3 id="取消订阅事件"><a href="#取消订阅事件" class="headerlink" title="取消订阅事件"></a>取消订阅事件</h3><p>你可以取消事件订阅通过调用cancelEventDelivery(Object event)方法,任何进一步的事件交付将被取消,后续用户不会接收到事件,但是该方法只有在ThreadMode.PostThread事件处理方法中调用才有效.</p>
<p>就讲到这里了》》》</p>
<h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h3><ol>
<li><p>@Subscribe 下的方法必须为public</p>
</li>
<li><p>postSticky()发送的粘性消息订阅时必须@Subscribe(sticky = true)否则接收不到</p>
</li>
<li><p>发送的event事件是object类</p>
</li>
<li><p>@Subscribe(priority = 1) 使用时优先级默认为0，然后只有统一模式下设置优先级才有效果，自己看着合理使用  </p>
</li>
</ol>
<p>demo传送门：<a href="http://download.csdn.net/detail/u013278099/9490921" target="_blank" rel="external">EventBusApp</a>  </p>
<p>觉得还不错的帮忙顶一下，大家相互学习一下，哈哈哈。</p>
<hr>
<p>未经许可不得转载，转载请注明zilianliuxue的blog,本人保留所有版权。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;你还在为刷新ui伤透脑筋吗？你还在琢磨如何使用接口回调或者handle来实现吗？如果你想到了使用观察者模式，那么一个很屌的Android开源框架EventBus：主要功能是替代Intent、Handler、BroadCast在Fragment、Activity、Servic
    
    </summary>
    
      <category term="android" scheme="http://zilianliuxue.github.io/categories/android/"/>
    
    
      <category term="EventBus3" scheme="http://zilianliuxue.github.io/tags/EventBus3/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://zilianliuxue.github.io/2016/03/21/hello-world/"/>
    <id>http://zilianliuxue.github.io/2016/03/21/hello-world/</id>
    <published>2016-03-21T08:04:09.000Z</published>
    <updated>2016-07-29T12:18:23.493Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
<hr>
<p>未经许可不得转载，转载请注明zilianliuxue的blog,本人保留所有版权。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
    
    </summary>
    
      <category term="hexo" scheme="http://zilianliuxue.github.io/categories/hexo/"/>
    
    
      <category term="jacman" scheme="http://zilianliuxue.github.io/tags/jacman/"/>
    
  </entry>
  
</feed>
