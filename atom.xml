<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>♀紫☆恋&amp;流★雪♂</title>
  <subtitle>编程中我们会遇到多少挫折？不放弃，沙漠尽头必是绿洲，不是天方夜谭</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://zilianliuxue.github.io/"/>
  <updated>2017-07-21T15:31:55.058Z</updated>
  <id>http://zilianliuxue.github.io/</id>
  
  <author>
    <name>Losileeya</name>
    <email>847457332@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SpringBoot初体验</title>
    <link href="http://zilianliuxue.github.io/2017/07/21/SpringBoot%E5%88%9D%E4%BD%93%E9%AA%8C/"/>
    <id>http://zilianliuxue.github.io/2017/07/21/SpringBoot初体验/</id>
    <published>2017-07-21T09:26:00.000Z</published>
    <updated>2017-07-21T15:31:55.058Z</updated>
    
    <content type="html"><![CDATA[<p>##前言</p>
<p>Spring一直是很火的一个开源框架，在过去的一段时间里，Spring Boot在社区中热度一直很高，所以决定花时间来了解和学习，为自己做技术储备。</p>
<p>###正文<br>首先声明，Spring Boot不是一门新技术，所以不用紧张。从本质上来说，Spring Boot就是Spring,它做了那些没有它你也会去做的Spring Bean配置。它使用“习惯优于配置”（项目中存在大量的配置，此外还内置了一个习惯性的配置，让你无需手动进行配置）的理念让你的项目快速运行起来。使用Spring Boot很容易创建一个独立运行（运行jar,内嵌Servlet容器）、准生产级别的基于Spring框架的项目，使用Spring Boot你可以不用或者只需要很少的Spring配置。</p>
<hr>
<p>未经许可不得转载，转载请注明zilianliuxue的blog,本人保留所有版权。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;##前言&lt;/p&gt;
&lt;p&gt;Spring一直是很火的一个开源框架，在过去的一段时间里，Spring Boot在社区中热度一直很高，所以决定花时间来了解和学习，为自己做技术储备。&lt;/p&gt;
&lt;p&gt;###正文&lt;br&gt;首先声明，Spring Boot不是一门新技术，所以不用紧张。从本质
    
    </summary>
    
      <category term="java" scheme="http://zilianliuxue.github.io/categories/java/"/>
    
    
      <category term="java" scheme="http://zilianliuxue.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>安卓开发实战之app之版本更新(DownloadManager和http下载)完整实现</title>
    <link href="http://zilianliuxue.github.io/2016/09/28/%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98%E4%B9%8Bapp%E4%B9%8B%E7%89%88%E6%9C%AC%E6%9B%B4%E6%96%B0(DownloadManager%E5%92%8Chttp%E4%B8%8B%E8%BD%BD)%E5%AE%8C%E6%95%B4%E5%AE%9E%E7%8E%B0/"/>
    <id>http://zilianliuxue.github.io/2016/09/28/安卓开发实战之app之版本更新(DownloadManager和http下载)完整实现/</id>
    <published>2016-09-28T09:26:00.000Z</published>
    <updated>2016-09-28T09:27:01.714Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h3><p>本文将讲解app的升级与更新。一般而言用户使用App的时候升级提醒有两种方式获得：</p>
<ul>
<li>一种是通过应用市场 获取</li>
<li>一种是打开应用之后提醒用户更新升级</li>
</ul>
<p>而更新操作一般是在用户点击了升级按钮之后开始执行的，这里的升级操作也分为两种形式：</p>
<ul>
<li>一般升级</li>
<li>强制升级</li>
</ul>
<p><strong>app升级操作：</strong></p>
<ul>
<li>应用市场的app升级</li>
</ul>
<p>在App Store中升级需要为App Store上传新版App，我们在新版本完成之后都会上传到App Store中，在审核完成之后就相当于完成了这个应用市场的发布了，也就是发布上线了。这时候如果用户安装了这个应用市场，那么就能看到我们的App有新版本的升级提醒了。</p>
<ul>
<li>应用内升级</li>
</ul>
<p>除了可以在应用市场升级，我们还可以在应用内升级，在应用内升级主要是通过调用服务器端接口获取应用的升级信息，然后通过获取的服务器升级应用信息与本地的App版本比对，若服务器下发的最新的App版本高于本地的版本号，则说明有新版本发布，那么我们就可以执行更新操作了，否则忽略掉即可。</p>
<blockquote>
<p>显然应用市场提醒的升级不是我们的重点，本篇主要是对于app升级的场景来进行不同角度的实现，便于以后开发过程中直接拿去用就ok了。</p>
</blockquote>
<h3 id="服务器端："><a href="#服务器端：" class="headerlink" title="服务器端："></a><strong>服务器端：</strong></h3><ul>
<li>服务端提供一个接口，或者网址，这里提供一个网址如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http:<span class="comment">//192.168.191.1:8081/update</span></div></pre></td></tr></table></figure>
<p>一般作为一个安卓程序员要测试还得写一个服务端（醉了），这里我就使用nodejs来搞一个本地的服务器来测试下app的版本更新检验。</p>
<ul>
<li>根据请求的结果，我这里就写一个简单的json</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&#123;<span class="string">"data"</span>:&#123;</div><div class="line">  <span class="string">"appname"</span>: <span class="string">"hoolay.apk"</span>,</div><div class="line">  <span class="string">"serverVersion"</span>: <span class="string">"1.0.2"</span>,</div><div class="line">  <span class="string">"serverFlag"</span>: <span class="string">"1"</span>,</div><div class="line">  <span class="string">"lastForce"</span> : <span class="string">"1"</span>,</div><div class="line">  <span class="string">"updateurl"</span>: <span class="string">"http://releases.b0.upaiyun.com/hoolay.apk"</span>,</div><div class="line">  <span class="string">"upgradeinfo"</span>: <span class="string">"V1.0.2版本更新，你想不想要试一下哈！！！"</span></div><div class="line">&#125;,</div><div class="line">  <span class="string">"error_code"</span>:<span class="string">"200"</span>,<span class="string">"error_msg"</span> :<span class="string">"蛋疼的认识"</span>&#125;</div></pre></td></tr></table></figure>
<p>然后我电脑上是装了webstrom的，没有装也没有关系但是必须有nodejs，现在都自带了express，表示并没有学过，所以简单的写个express_demo.js：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">var express = require(<span class="string">'express'</span>);</div><div class="line">var app = express();</div><div class="line">var fs = require(<span class="string">"fs"</span>);</div><div class="line"><span class="comment">//此处设置为get请求，app里面直接写 (本机ip:8081/update)</span></div><div class="line">app.get(<span class="string">'/update'</span>, function (req, res) &#123;<span class="comment">//http://127.0.0.1:8081/update</span></div><div class="line">    fs.readFile( __dirname + <span class="string">"/"</span> + <span class="string">"version.json"</span>, <span class="string">'utf8'</span>, function (err, data) &#123;<span class="comment">//读取相同目录下的version.json文件</span></div><div class="line">        console.log( data );<span class="comment">//打印json数据</span></div><div class="line">        res.end( data );<span class="comment">//把json数据response回去</span></div><div class="line">    &#125;);</div><div class="line">&#125;)</div><div class="line">var server = app.listen(<span class="number">8081</span>, function () &#123;<span class="comment">//端口我这里写的是8081</span></div><div class="line">    var host = server.address().address</div><div class="line">    var port = server.address().port</div><div class="line">    console.log(<span class="string">"应用实例，访问地址为 http://%s:%s"</span>, host, port)</div><div class="line"></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>有webstrom的直接选中文件run就ok了，没有直接  node express_demo.js，可以直接浏览器打开：<a href="http://127.0.0.1:8081/update" target="_blank" rel="external">http://127.0.0.1:8081/update</a></p>
<ul>
<li>效果如下：</li>
</ul>
<p><img src="http://img.blog.csdn.net/20160928143355881" alt="这里写图片描述"></p>
<p>上图为打开浏览器后的显示结果。</p>
<p><img src="http://img.blog.csdn.net/20160928143341506" alt="这里写图片描述"></p>
<p>上图为webstrom的终端显示结果。</p>
<h3 id="客户端需要实现："><a href="#客户端需要实现：" class="headerlink" title="客户端需要实现："></a><strong>客户端需要实现：</strong></h3><p>我们知道不同的需求有不同的操作方法和界面显示：</p>
<ol>
<li>从是否为app内部下载还是通知栏更新：</li>
</ol>
<ul>
<li><p>app内下载更新</p>
<p>这时我们必须等下载安装完全后才能进行操作，效果是这样的：</p>
<p><img src="http://img.blog.csdn.net/20160928143454907" alt="这里写图片描述"></p>
<p>​</p>
</li>
<li><p>通知栏下载更新</p>
<p>这种情况是不在应用内更新，放在通知栏并不会影响当前app的使用，效果是这样的：</p>
<p><img src="http://img.blog.csdn.net/20160928143411828" alt=""></p>
<p>​</p>
</li>
</ul>
<ol>
<li><p>app更新分3种：强制更新，推荐更新，无需更新</p>
<ul>
<li><p>强制更新</p>
<p><img src="http://img.blog.csdn.net/20160928145131556" alt="这里写图片描述"></p>
</li>
<li><p>推荐更新</p>
<p><img src="http://img.blog.csdn.net/20160928143440835" alt="这里写图片描述"></p>
</li>
<li><p>无需更新</p>
<p><img src="http://img.blog.csdn.net/20160928143428829" alt="这里写图片描述"></p>
<p>​</p>
</li>
</ul>
</li>
</ol>
<p>具体思路：</p>
<blockquote>
<ol>
<li>实现bean用于对接后端接口实现app的更新（不写网络请求模拟本地数据也需要这个模型）</li>
<li>使用retrofit来请求版本更新接口</li>
<li>下载apk我们分别使用DownloadManager和普通的httpurlconnection</li>
<li>通过BroadcastReceiver来监听是否下载完成</li>
</ol>
</blockquote>
<h4 id="准备bean"><a href="#准备bean" class="headerlink" title="准备bean"></a><strong>准备bean</strong></h4><p>首先我们要去解析服务端给的json，那么我们就要来创建一个bean类了,这里是严格根据json文件的格式来的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.losileeya.appupdate.bean;</div><div class="line"><span class="comment">/**</span></div><div class="line"> * User: Losileeya (847457332@qq.com)</div><div class="line"> * Date: 2016-09-27</div><div class="line"> * Time: 11:20</div><div class="line"> * 类描述：版本更新的实体与你服务器的字段相匹配</div><div class="line"> * <span class="doctag">@version</span> :</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UpdateAppInfo</span>  </span>&#123;</div><div class="line">    <span class="keyword">public</span> UpdateInfo data; <span class="comment">// 信息</span></div><div class="line">    <span class="keyword">public</span> Integer error_code; <span class="comment">// 错误代码</span></div><div class="line">    <span class="keyword">public</span> String error_msg; <span class="comment">// 错误信息</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">UpdateInfo</span></span>&#123;</div><div class="line">        <span class="comment">// app名字</span></div><div class="line">        <span class="keyword">public</span> String appname;</div><div class="line">        <span class="comment">//服务器版本</span></div><div class="line">        <span class="keyword">public</span> String serverVersion;</div><div class="line">        <span class="comment">//服务器标志</span></div><div class="line">        <span class="keyword">public</span> String serverFlag;</div><div class="line">        <span class="comment">//强制升级</span></div><div class="line">        <span class="keyword">public</span> String lastForce;</div><div class="line">        <span class="comment">//app最新版本地址</span></div><div class="line">        <span class="keyword">public</span> String updateurl;</div><div class="line">        <span class="comment">//升级信息</span></div><div class="line">        <span class="keyword">public</span> String upgradeinfo;</div><div class="line">        get...</div><div class="line">        set...</div><div class="line">    &#125;</div><div class="line">        get...</div><div class="line">        set...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="网络接口的实现"><a href="#网络接口的实现" class="headerlink" title="网络接口的实现"></a><strong>网络接口的实现</strong></h4><blockquote>
<p>这里使用retrofit和rxjava来练笔</p>
</blockquote>
<p>先加入 依赖</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">compile <span class="string">'io.reactivex:rxandroid:1.1.0'</span> <span class="comment">// RxAndroid</span></div><div class="line">compile <span class="string">'io.reactivex:rxjava:1.1.0'</span> <span class="comment">// 推荐同时加载RxJava</span></div><div class="line"></div><div class="line">compile <span class="string">'com.squareup.retrofit:retrofit:2.0.0-beta2'</span> <span class="comment">// Retrofit网络处理</span></div><div class="line">compile <span class="string">'com.squareup.retrofit:adapter-rxjava:2.0.0-beta2'</span> <span class="comment">// Retrofit的rx解析库</span></div><div class="line">compile <span class="string">'com.squareup.retrofit:converter-gson:2.0.0-beta2'</span> <span class="comment">// Retrofit的gson库</span></div></pre></td></tr></table></figure>
<p>接下来网络接口的定制：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ApiService</span> </span>&#123;</div><div class="line">    <span class="comment">//实际开发过程可能的接口方式</span></div><div class="line">     <span class="meta">@GET</span>(<span class="string">"update"</span>)</div><div class="line">    <span class="function">Observable&lt;UpdateAppInfo&gt; <span class="title">getUpdateInfo</span><span class="params">(@Query(<span class="string">"appname"</span>)</span> String   appname, @<span class="title">Query</span><span class="params">(<span class="string">"serverVersion"</span>)</span> String appVersion)</span>;</div><div class="line">    <span class="comment">//以下方便版本更新接口测试</span></div><div class="line">    <span class="meta">@GET</span>(<span class="string">"update"</span>)</div><div class="line">    <span class="function">Observable&lt;UpdateAppInfo&gt; <span class="title">getUpdateInfo</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过工厂模式来创建ApiService ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceFactory</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String BASEURL=<span class="string">"http://192.168.191.1:8081/"</span>;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">createServiceFrom</span><span class="params">(<span class="keyword">final</span> Class&lt;T&gt; serviceClass)</span> </span>&#123;</div><div class="line">        Retrofit adapter = <span class="keyword">new</span> Retrofit.Builder()</div><div class="line">                .baseUrl(BASEURL)</div><div class="line">             .addCallAdapterFactory(RxJavaCallAdapterFactory.create()) <span class="comment">// 添加Rx适配器</span></div><div class="line">                .addConverterFactory(GsonConverterFactory.create()) <span class="comment">// 添加Gson转换器</span></div><div class="line">                .build();</div><div class="line">        <span class="keyword">return</span> adapter.create(serviceClass);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>版本检测接口的使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">    * 检查更新</div><div class="line">    */</div><div class="line">   <span class="meta">@SuppressWarnings</span>(<span class="string">"unused"</span>)</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">checkUpdate</span><span class="params">(String appCode, String curVersion,<span class="keyword">final</span> CheckCallBack updateCallback)</span> </span>&#123;</div><div class="line">    ApiService apiService=   ServiceFactory.createServiceFrom(ApiService.class);</div><div class="line">       apiService.getUpdateInfo()<span class="comment">//测试使用</span></div><div class="line">               <span class="comment">//   .apiService.getUpdateInfo(appCode, curVersion)//开发过程中可能使用的</span></div><div class="line">               .subscribeOn(Schedulers.newThread())</div><div class="line">               .observeOn(AndroidSchedulers.mainThread())</div><div class="line">               .subscribe(<span class="keyword">new</span> Subscriber&lt;UpdateAppInfo&gt;() &#123;</div><div class="line">                   <span class="meta">@Override</span></div><div class="line">                   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</div><div class="line">                   &#125;</div><div class="line">                   <span class="meta">@Override</span></div><div class="line">                   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</div><div class="line">                   &#125;</div><div class="line">                   <span class="meta">@Override</span></div><div class="line">                   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(UpdateAppInfo updateAppInfo)</span> </span>&#123;</div><div class="line">                       <span class="keyword">if</span> (updateAppInfo.error_code == <span class="number">0</span> || updateAppInfo.data == <span class="keyword">null</span> ||</div><div class="line">                               updateAppInfo.data.updateurl == <span class="keyword">null</span>) &#123;</div><div class="line">                           updateCallback.onError(); <span class="comment">// 失败</span></div><div class="line">                       &#125; <span class="keyword">else</span> &#123;</div><div class="line">                           updateCallback.onSuccess(updateAppInfo);</div><div class="line">                       &#125;</div><div class="line">                   &#125;</div><div class="line">               &#125;);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>以上就是版本更新接口的调用，具体的rxjava+retrofit请自行学习<a href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2016/0518/4270.html" target="_blank" rel="external">你真的会用Retrofit2吗?Retrofit2完全教程</a></p>
<p>附上结果回调监听：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CheckCallBack</span></span>&#123;<span class="comment">//检测成功或者失败的相关接口</span></div><div class="line">      <span class="function"><span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(UpdateAppInfo updateInfo)</span></span>;</div><div class="line">      <span class="function"><span class="keyword">void</span> <span class="title">onError</span><span class="params">()</span></span>;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>具体使用接口的处理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//网络检查版本是否需要更新</span></div><div class="line">       CheckUpdateUtils.checkUpdate(<span class="string">"apk"</span>, <span class="string">"1.0.0"</span>, <span class="keyword">new</span> CheckUpdateUtils.CheckCallBack() &#123;</div><div class="line">           <span class="meta">@Override</span></div><div class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(UpdateAppInfo updateInfo)</span> </span>&#123;</div><div class="line">              String isForce=updateInfo.data.getLastForce();<span class="comment">//是否需要强制更新</span></div><div class="line">              String downUrl= updateInfo.data.getUpdateurl();<span class="comment">//apk下载地址</span></div><div class="line">              String updateinfo = updateInfo.data.getUpgradeinfo();<span class="comment">//apk更新详情</span></div><div class="line">              String appName = updateInfo.data.getAppname();</div><div class="line">               <span class="keyword">if</span>(isForce.equals(<span class="string">"1"</span>)&amp;&amp; !TextUtils.isEmpty(updateinfo))&#123;<span class="comment">//强制更新</span></div><div class="line">                   forceUpdate(MainActivity.<span class="keyword">this</span>,appName,downUrl,updateinfo);</div><div class="line">               &#125;<span class="keyword">else</span>&#123;<span class="comment">//非强制更新</span></div><div class="line">                   <span class="comment">//正常升级</span></div><div class="line">   normalUpdate(MainActivity.<span class="keyword">this</span>,appName,downUrl,updateinfo);</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line">           <span class="meta">@Override</span></div><div class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">()</span> </span>&#123;</div><div class="line">               noneUpdate(MainActivity.<span class="keyword">this</span>);</div><div class="line">           &#125;</div><div class="line">       &#125;);</div></pre></td></tr></table></figure>
<p>实在不想写网络也好，直接使用假想数据做相关操作如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">UpdateAppInfo.UpdateInfo  info =<span class="keyword">new</span> UpdateAppInfo.UpdateInfo();</div><div class="line">           info.setLastForce(<span class="string">"1"</span>);</div><div class="line">      info.setAppname(<span class="string">"我日你"</span>);</div><div class="line">      info.setUpgradeinfo(<span class="string">"whejjefjhrherkjreghgrjrgjjhrh"</span>);</div><div class="line">     info.setUpdateurl(<span class="string">"http://releases.b0.upaiyun.com/hoolay.apk"</span>);</div><div class="line">      <span class="keyword">if</span>(info.getLastForce().equals(<span class="string">"1"</span>))&#123;<span class="comment">//强制更新      forceUpdate(MainActivity.this,info.getAppname(),info.getUpdateurl(),info.getUpgradeinfo());</span></div><div class="line">              &#125;<span class="keyword">else</span>&#123;<span class="comment">//非强制更新</span></div><div class="line">                  <span class="comment">//正常升级   normalUpdate(MainActivity.this,info.getAppname(),info.getUpdateurl(),info.getUpgradeinfo());</span></div><div class="line">              &#125;</div></pre></td></tr></table></figure>
<p>更新dialog的使用注意：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">forceUpdate</span><span class="params">(<span class="keyword">final</span> Context context, <span class="keyword">final</span> String appName, <span class="keyword">final</span> String downUrl, <span class="keyword">final</span> String updateinfo)</span> </span>&#123;</div><div class="line">       mDialog = <span class="keyword">new</span> AlertDialog.Builder(context);</div><div class="line">       mDialog.setTitle(appName+<span class="string">"又更新咯！"</span>);</div><div class="line">       mDialog.setMessage(updateinfo);</div><div class="line">       mDialog.setPositiveButton(<span class="string">"立即更新"</span>, <span class="keyword">new</span> DialogInterface.OnClickListener() &#123;</div><div class="line">           <span class="meta">@Override</span></div><div class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(DialogInterface dialog, <span class="keyword">int</span> which)</span> </span>&#123;</div><div class="line">               <span class="keyword">if</span> (!canDownloadState()) &#123;</div><div class="line">                   showDownloadSetting();</div><div class="line">                   <span class="keyword">return</span>;</div><div class="line">               &#125;</div><div class="line">               <span class="comment">//      DownLoadApk.download(MainActivity.this,downUrl,updateinfo,appName);</span></div><div class="line">    AppInnerDownLoder.downLoadApk(MainActivity.<span class="keyword">this</span>,downUrl,appName);</div><div class="line">           &#125;</div><div class="line">       &#125;).setCancelable(<span class="keyword">false</span>).create().show();</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>上面以强制更新举个例子，因为AlertDialog在不同的版本下面表现的美观度不一致，所以我们需要</p>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="keyword">import</span> android.support.v7.app.AlertDialog;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>然后显然是不能按返回键取消的，我们需要</p>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; .setCancelable(<span class="keyword">false</span>)</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<h4 id="使用谷歌推荐的DownloadManager实现下载"><a href="#使用谷歌推荐的DownloadManager实现下载" class="headerlink" title="使用谷歌推荐的DownloadManager实现下载"></a><strong>使用谷歌推荐的DownloadManager实现下载</strong></h4><p>Android自带的DownloadManager模块来下载,在api level 9之后，我们通过通知栏知道, 该模块属于系统自带, 它已经帮我们处理了下载失败、重新下载等功能。整个下载 过程全部交给系统负责，不需要我们过多的处理。</p>
<p><strong>DownLoadManager.Query:主要用于查询下载信息。</strong></p>
<p><strong>DownLoadManager.Request:主要用于发起一个下载请求。</strong></p>
<p>先看下简单的实现：</p>
<p>创建Request对象的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">DownloadManager.Request request = <span class="keyword">new</span> DownloadManager.Request(Uri.parse(apkurl));</div><div class="line">   <span class="comment">//设置在什么网络情况下进行下载</span></div><div class="line">   request.setAllowedNetworkTypes(Request.NETWORK_WIFI);</div><div class="line">   <span class="comment">//设置通知栏标题</span></div><div class="line">   request.setNotificationVisibility(Request.VISIBILITY_VISIBLE);</div><div class="line">   request.setTitle(<span class="string">"下载"</span>);</div><div class="line">   request.setDescription(<span class="string">"apk正在下载"</span>);</div><div class="line">   request.setAllowedOverRoaming(<span class="keyword">false</span>);</div><div class="line">   <span class="comment">//设置文件存放目录</span></div><div class="line">   request.setDestinationInExternalFilesDir(<span class="keyword">this</span>, Environment.DIRECTORY_DOWNLOADS, <span class="string">"mydown"</span>);</div></pre></td></tr></table></figure>
<p>取得系统服务后，调用downloadmanager对象的enqueue方法进行下载，此方法返回一个编号用于标示此下载任务：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">downManager = (DownloadManager)getSystemService(Context.DOWNLOAD_SERVICE);</div><div class="line">id= downManager.enqueue(request);</div></pre></td></tr></table></figure>
<p>这里我们可以看下request的一些属性：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">addRequestHeader(String header,String value):添加网络下载请求的http头信息</div><div class="line">allowScanningByMediaScanner():用于设置是否允许本MediaScanner扫描。</div><div class="line">setAllowedNetworkTypes(<span class="keyword">int</span> flags):设置用于下载时的网络类型，默认任何网络都可以下载，提供的网络常量有：NETWORK_BLUETOOTH、NETWORK_MOBILE、NETWORK_WIFI。</div><div class="line">setAllowedOverRoaming(Boolean allowed):用于设置漫游状态下是否可以下载</div><div class="line">setNotificationVisibility(<span class="keyword">int</span> visibility):用于设置下载时时候在状态栏显示通知信息</div><div class="line">setTitle(CharSequence):设置Notification的title信息</div><div class="line">setDescription(CharSequence):设置Notification的message信息</div><div class="line">setDestinationInExternalFilesDir、setDestinationInExternalPublicDir、 setDestinationUri等方法用于设置下载文件的存放路径，注意如果将下载文件存放在默认路径，那么在空间不足的情况下系统会将文件删除，所 以使用上述方法设置文件存放目录是十分必要的。</div></pre></td></tr></table></figure>
<p>具体实现思路：</p>
<blockquote>
<ol>
<li><p>我们通过downloaderManager来下载apk，并且本地保存downManager.enqueue(request)返回的id值，并且通过这个id获取apk的下载文件路径和下载的状态，并且通过状态来更新通知栏的显示。</p>
</li>
<li><p>第一次下载成功，弹出安装界面</p>
<p>如果用户没有点击安装，而是按了返回键，在某个时候，又再次使用了我们的APP</p>
<p>如果下载成功，则判断本地的apk的包名是否和当前程序是相同的，并且本地apk的版本号大于当前程序的版本，如果都满足则直接启动安装程序。</p>
</li>
</ol>
</blockquote>
<p>具体代码实现：</p>
<p>文件下载管理的实现，包括创建request和加入队列下载，通过返回的id来获取下载路径和下载状态。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileDownloadManager</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> DownloadManager downloadManager;</div><div class="line">    <span class="keyword">private</span> Context context;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> FileDownloadManager instance;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">FileDownloadManager</span><span class="params">(Context context)</span> </span>&#123;</div><div class="line">        downloadManager = (DownloadManager) context.getSystemService(Context.DOWNLOAD_SERVICE);</div><div class="line">        <span class="keyword">this</span>.context = context.getApplicationContext();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> FileDownloadManager <span class="title">getInstance</span><span class="params">(Context context)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</div><div class="line">            instance = <span class="keyword">new</span> FileDownloadManager(context);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> instance;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * <span class="doctag">@param</span> uri</div><div class="line">     * <span class="doctag">@param</span> title</div><div class="line">     * <span class="doctag">@param</span> description</div><div class="line">     * <span class="doctag">@return</span> download id</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">startDownload</span><span class="params">(String uri, String title, String description,String appName)</span> </span>&#123;</div><div class="line">        DownloadManager.Request req = <span class="keyword">new</span> DownloadManager.Request(Uri.parse(uri));</div><div class="line">        req.setAllowedNetworkTypes(DownloadManager.Request.NETWORK_WIFI);</div><div class="line">        <span class="comment">//req.setAllowedOverRoaming(false);</span></div><div class="line"> req.setNotificationVisibility(DownloadManager.Request.VISIBILITY_VISIBLE_NOTIFY_COMPLETED);</div><div class="line">        <span class="comment">//设置文件的保存的位置[三种方式]</span></div><div class="line">        <span class="comment">//第一种</span></div><div class="line">        <span class="comment">//file:///storage/emulated/0/Android/data/your-package/files/Download/update.apk</span></div><div class="line">        req.setDestinationInExternalFilesDir(context, Environment.DIRECTORY_DOWNLOADS, appName+<span class="string">".apk"</span>);</div><div class="line">        <span class="comment">//第二种</span></div><div class="line">        <span class="comment">//file:///storage/emulated/0/Download/update.apk</span></div><div class="line">        <span class="comment">//req.setDestinationInExternalPublicDir(Environment.DIRECTORY_DOWNLOADS, "update.apk");</span></div><div class="line">        <span class="comment">//第三种 自定义文件路径</span></div><div class="line">        <span class="comment">//req.setDestinationUri()</span></div><div class="line"></div><div class="line"></div><div class="line">        <span class="comment">// 设置一些基本显示信息</span></div><div class="line">        req.setTitle(title);</div><div class="line">        req.setDescription(description);</div><div class="line">        <span class="comment">//req.setMimeType("application/vnd.android.package-archive");</span></div><div class="line">        <span class="keyword">return</span> downloadManager.enqueue(req);<span class="comment">//异步</span></div><div class="line">        <span class="comment">//dm.openDownloadedFile()</span></div><div class="line">    &#125;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 获取文件保存的路径</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> downloadId an ID for the download, unique across the system.</div><div class="line">     *                   This ID is used to make future calls related to this download.</div><div class="line">     * <span class="doctag">@return</span> file path</div><div class="line">     * <span class="doctag">@see</span> FileDownloadManager#getDownloadUri(long)</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDownloadPath</span><span class="params">(<span class="keyword">long</span> downloadId)</span> </span>&#123;</div><div class="line">        DownloadManager.Query query = <span class="keyword">new</span> DownloadManager.Query().setFilterById(downloadId);</div><div class="line">        Cursor c = downloadManager.query(query);</div><div class="line">        <span class="keyword">if</span> (c != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="keyword">if</span> (c.moveToFirst()) &#123;</div><div class="line">                    <span class="keyword">return</span> c.getString(c.getColumnIndexOrThrow(DownloadManager.COLUMN_LOCAL_URI));</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                c.close();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 获取保存文件的地址</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> downloadId an ID for the download, unique across the system.</div><div class="line">     *                   This ID is used to make future calls related to this download.</div><div class="line">     * <span class="doctag">@see</span> FileDownloadManager#getDownloadPath(long)</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> Uri <span class="title">getDownloadUri</span><span class="params">(<span class="keyword">long</span> downloadId)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> downloadManager.getUriForDownloadedFile(downloadId);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> DownloadManager <span class="title">getDownloadManager</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> downloadManager;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 获取下载状态</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> downloadId an ID for the download, unique across the system.</div><div class="line">     *                   This ID is used to make future calls related to this download.</div><div class="line">     * <span class="doctag">@return</span> int</div><div class="line">     * <span class="doctag">@see</span> DownloadManager#STATUS_PENDING</div><div class="line">     * <span class="doctag">@see</span> DownloadManager#STATUS_PAUSED</div><div class="line">     * <span class="doctag">@see</span> DownloadManager#STATUS_RUNNING</div><div class="line">     * <span class="doctag">@see</span> DownloadManager#STATUS_SUCCESSFUL</div><div class="line">     * <span class="doctag">@see</span> DownloadManager#STATUS_FAILED</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getDownloadStatus</span><span class="params">(<span class="keyword">long</span> downloadId)</span> </span>&#123;</div><div class="line">        DownloadManager.Query query = <span class="keyword">new</span> DownloadManager.Query().setFilterById(downloadId);</div><div class="line">        Cursor c = downloadManager.query(query);</div><div class="line">        <span class="keyword">if</span> (c != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="keyword">if</span> (c.moveToFirst()) &#123;</div><div class="line">                    <span class="keyword">return</span> c.getInt(c.getColumnIndexOrThrow(DownloadManager.COLUMN_STATUS));</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                c.close();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>app的检测安装的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DownLoadApk</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = DownLoadApk.class.getSimpleName();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">download</span><span class="params">(Context context, String url, String title,<span class="keyword">final</span> String appName)</span> </span>&#123;</div><div class="line">        <span class="comment">// 获取存储ID</span></div><div class="line">        SharedPreferences sp = PreferenceManager.getDefaultSharedPreferences(context);</div><div class="line">        <span class="keyword">long</span> downloadId =sp.getLong(DownloadManager.EXTRA_DOWNLOAD_ID,-<span class="number">1L</span>);</div><div class="line">        <span class="keyword">if</span> (downloadId != -<span class="number">1L</span>) &#123;</div><div class="line">            FileDownloadManager fdm = FileDownloadManager.getInstance(context);</div><div class="line">            <span class="keyword">int</span> status = fdm.getDownloadStatus(downloadId);</div><div class="line">            <span class="keyword">if</span> (status == DownloadManager.STATUS_SUCCESSFUL) &#123;</div><div class="line">                <span class="comment">//启动更新界面</span></div><div class="line">                Uri uri = fdm.getDownloadUri(downloadId);</div><div class="line">                <span class="keyword">if</span> (uri != <span class="keyword">null</span>) &#123;</div><div class="line">                    <span class="keyword">if</span> (compare(getApkInfo(context, uri.getPath()), context)) &#123;</div><div class="line">                        startInstall(context, uri);</div><div class="line">                        <span class="keyword">return</span>;</div><div class="line">                    &#125; <span class="keyword">else</span> &#123;</div><div class="line">                        fdm.getDownloadManager().remove(downloadId);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                start(context, url, title,appName);</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (status == DownloadManager.STATUS_FAILED) &#123;</div><div class="line">                start(context, url, title,appName);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                Log.d(TAG, <span class="string">"apk is already downloading"</span>);</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            start(context, url, title,appName);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(Context context, String url, String title,String appName)</span> </span>&#123;</div><div class="line">        <span class="keyword">long</span> id = FileDownloadManager.getInstance(context).startDownload(url,</div><div class="line">                title, <span class="string">"下载完成后点击打开"</span>,appName);</div><div class="line">        SharedPreferences sp = PreferenceManager.getDefaultSharedPreferences(context);</div><div class="line">        sp.edit().putLong(DownloadManager.EXTRA_DOWNLOAD_ID,id).commit();</div><div class="line">        Log.d(TAG, <span class="string">"apk start download "</span> + id);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">startInstall</span><span class="params">(Context context, Uri uri)</span> </span>&#123;</div><div class="line">        Intent install = <span class="keyword">new</span> Intent(Intent.ACTION_VIEW);</div><div class="line">        install.setDataAndType(uri, <span class="string">"application/vnd.android.package-archive"</span>);</div><div class="line">        install.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</div><div class="line">        context.startActivity(install);</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 获取apk程序信息[packageName,versionName...]</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> context Context</div><div class="line">     * <span class="doctag">@param</span> path    apk path</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> PackageInfo <span class="title">getApkInfo</span><span class="params">(Context context, String path)</span> </span>&#123;</div><div class="line">        PackageManager pm = context.getPackageManager();</div><div class="line">        PackageInfo info = pm.getPackageArchiveInfo(path, PackageManager.GET_ACTIVITIES);</div><div class="line">        <span class="keyword">if</span> (info != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> info;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 下载的apk和当前程序版本比较</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> apkInfo apk file's packageInfo</div><div class="line">     * <span class="doctag">@param</span> context Context</div><div class="line">     * <span class="doctag">@return</span> 如果当前应用版本小于apk的版本则返回true</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">compare</span><span class="params">(PackageInfo apkInfo, Context context)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (apkInfo == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        String localPackage = context.getPackageName();</div><div class="line">        <span class="keyword">if</span> (apkInfo.packageName.equals(localPackage)) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                PackageInfo packageInfo = context.getPackageManager().getPackageInfo(localPackage, <span class="number">0</span>);</div><div class="line">                <span class="keyword">if</span> (apkInfo.versionCode &gt; packageInfo.versionCode) &#123;</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">catch</span> (PackageManager.NameNotFoundException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的代码可知：我们通过获取当前app的信息来比较是否需要下载和是否立即安装。第一次下载把downloadId保存到本地，用户下次进来的时候，取出保存的downloadId，然后通过downloadId来获取下载的状态信息。如果下载失败，则重新下载并且把downloadId存起来。如果下载成功，则<code>判断本地的apk的包名是否和当前程序是相同的，并且本地apk的版本号大于当前程序的版本</code>，如果都满足则直接启动安装程序。</p>
<h3 id="监听app是否安装完成"><a href="#监听app是否安装完成" class="headerlink" title="监听app是否安装完成"></a><strong>监听app是否安装完成</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApkInstallReceiver</span> <span class="keyword">extends</span> <span class="title">BroadcastReceiver</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Context context, Intent intent)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(intent.getAction().equals(DownloadManager.ACTION_DOWNLOAD_COMPLETE))&#123;</div><div class="line">              <span class="keyword">long</span> downloadApkId =intent.getLongExtra(DownloadManager.EXTRA_DOWNLOAD_ID, -<span class="number">1</span>);</div><div class="line">              installApk(context, downloadApkId);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 安装apk</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">installApk</span><span class="params">(Context context,<span class="keyword">long</span> downloadApkId)</span> </span>&#123;</div><div class="line">        <span class="comment">// 获取存储ID</span></div><div class="line">        SharedPreferences sp = PreferenceManager.getDefaultSharedPreferences(context);</div><div class="line">        <span class="keyword">long</span> downId =sp.getLong(DownloadManager.EXTRA_DOWNLOAD_ID,-<span class="number">1L</span>);</div><div class="line">        <span class="keyword">if</span>(downloadApkId == downId)&#123;</div><div class="line">            DownloadManager downManager= (DownloadManager) context.getSystemService(Context.DOWNLOAD_SERVICE);</div><div class="line">            Uri downloadFileUri = downManager.getUriForDownloadedFile(downloadApkId);</div><div class="line">            <span class="keyword">if</span> (downloadFileUri != <span class="keyword">null</span>) &#123;</div><div class="line">            Intent install= <span class="keyword">new</span> Intent(Intent.ACTION_VIEW);</div><div class="line">            install.setDataAndType(downloadFileUri, <span class="string">"application/vnd.android.package-archive"</span>);</div><div class="line">            install.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</div><div class="line">            context.startActivity(install);</div><div class="line">            &#125;<span class="keyword">else</span>&#123;</div><div class="line">                Toast.makeText(context, <span class="string">"下载失败"</span>, Toast.LENGTH_SHORT).show();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>DownloadManager下载完成后会发出一个广播 <code>android.intent.action.DOWNLOAD_COMPLETE</code> 新建一个广播接收者即可：</p>
<p>清单配置：</p>
<p>先添加网络下载的权限：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;uses-permission android:name=<span class="string">"android.permission.INTERNET"</span>/&gt;</div><div class="line">   &lt;uses-permission android:name=<span class="string">"android.permission.WRITE_EXTERNAL_STORAGE"</span>/&gt;</div></pre></td></tr></table></figure>
<p>再添加静态广播：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;receiver android:name=".ApkInstallReceiver"&gt;</div><div class="line">           &lt;intent-filter&gt;</div><div class="line">               &lt;action android:name="android.intent.action.DOWNLOAD_COMPLETE" /&gt;</div><div class="line">           &lt;/intent-filter&gt;</div><div class="line">       &lt;/receiver&gt;</div></pre></td></tr></table></figure>
<h4 id="使用HttpUrlConnection下载"><a href="#使用HttpUrlConnection下载" class="headerlink" title="使用HttpUrlConnection下载"></a><strong>使用HttpUrlConnection下载</strong></h4><p>这种情况下载的话我们就不需要考虑id的问题，因为是直接在项目中下载，所以我们就是一个网络下载的过程，并且使用ProgressDialog显示下载信息及进度更新就ok了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppInnerDownLoder</span> </span>&#123;</div><div class="line">	<span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> String SD_FOLDER = Environment.getExternalStorageDirectory()+ <span class="string">"/VersionChecker/"</span>;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = AppInnerDownLoder.class.getSimpleName();</div><div class="line">	</div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 从服务器中下载APK</div><div class="line">	 */</div><div class="line">	<span class="meta">@SuppressWarnings</span>(<span class="string">"unused"</span>)</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">downLoadApk</span><span class="params">(<span class="keyword">final</span> Context mContext,<span class="keyword">final</span> String downURL,<span class="keyword">final</span> String appName )</span> </span>&#123;</div><div class="line"></div><div class="line">		<span class="keyword">final</span> ProgressDialog pd; <span class="comment">// 进度条对话框</span></div><div class="line">		pd = <span class="keyword">new</span> ProgressDialog(mContext);</div><div class="line">		pd.setCancelable(<span class="keyword">false</span>);<span class="comment">// 必须一直下载完，不可取消</span></div><div class="line">		pd.setProgressStyle(ProgressDialog.STYLE_HORIZONTAL);</div><div class="line">		pd.setMessage(<span class="string">"正在下载安装包，请稍后"</span>);</div><div class="line">		pd.setTitle(<span class="string">"版本升级"</span>);</div><div class="line">		pd.show();</div><div class="line">		<span class="keyword">new</span> Thread() &#123;</div><div class="line">			<span class="meta">@Override</span></div><div class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">				<span class="keyword">try</span> &#123;</div><div class="line">					File file = downloadFile(downURL,appName, pd);</div><div class="line">					sleep(<span class="number">3000</span>);</div><div class="line">					installApk(mContext, file);</div><div class="line">					<span class="comment">// 结束掉进度条对话框</span></div><div class="line">					pd.dismiss();</div><div class="line">				&#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">					pd.dismiss();</div><div class="line"></div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;.start();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 从服务器下载最新更新文件</div><div class="line">	 * </div><div class="line">	 * <span class="doctag">@param</span> path</div><div class="line">	 *            下载路径</div><div class="line">	 * <span class="doctag">@param</span> pd</div><div class="line">	 *            进度条</div><div class="line">	 * <span class="doctag">@return</span></div><div class="line">	 * <span class="doctag">@throws</span> Exception</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> File <span class="title">downloadFile</span><span class="params">(String path,String appName ,ProgressDialog pd)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">		<span class="comment">// 如果相等的话表示当前的sdcard挂载在手机上并且是可用的</span></div><div class="line">		<span class="keyword">if</span> (Environment.MEDIA_MOUNTED.equals(Environment</div><div class="line">				.getExternalStorageState())) &#123;</div><div class="line">			URL url = <span class="keyword">new</span> URL(path);</div><div class="line">			HttpURLConnection conn = (HttpURLConnection) url.openConnection();</div><div class="line">			conn.setConnectTimeout(<span class="number">5000</span>);</div><div class="line">			<span class="comment">// 获取到文件的大小</span></div><div class="line">			pd.setMax(conn.getContentLength());</div><div class="line">			InputStream is = conn.getInputStream();</div><div class="line">			String fileName = SD_FOLDER</div><div class="line">					 + appName+<span class="string">".apk"</span>;</div><div class="line">			File file = <span class="keyword">new</span> File(fileName);</div><div class="line">			<span class="comment">// 目录不存在创建目录</span></div><div class="line">			<span class="keyword">if</span> (!file.getParentFile().exists())</div><div class="line">				file.getParentFile().mkdirs();</div><div class="line">			FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(file);</div><div class="line">			BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(is);</div><div class="line">			<span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</div><div class="line">			<span class="keyword">int</span> len;</div><div class="line">			<span class="keyword">int</span> total = <span class="number">0</span>;</div><div class="line">			<span class="keyword">while</span> ((len = bis.read(buffer)) != -<span class="number">1</span>) &#123;</div><div class="line">				fos.write(buffer, <span class="number">0</span>, len);</div><div class="line">				total += len;</div><div class="line">				<span class="comment">// 获取当前下载量</span></div><div class="line">				pd.setProgress(total);</div><div class="line">			&#125;</div><div class="line">			fos.close();</div><div class="line">			bis.close();</div><div class="line">			is.close();</div><div class="line">			<span class="keyword">return</span> file;</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"未发现有SD卡"</span>);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 安装apk</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">installApk</span><span class="params">(Context mContext, File file)</span> </span>&#123;</div><div class="line">		Uri fileUri = Uri.fromFile(file);</div><div class="line">		Intent it = <span class="keyword">new</span> Intent();</div><div class="line">		it.setAction(Intent.ACTION_VIEW);</div><div class="line">		it.setDataAndType(fileUri, <span class="string">"application/vnd.android.package-archive"</span>);</div><div class="line">		it.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);<span class="comment">// 防止打不开应用</span></div><div class="line">		mContext.startActivity(it);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 获取应用程序版本（versionName）</div><div class="line">	 * </div><div class="line">	 * <span class="doctag">@return</span> 当前应用的版本号</div><div class="line">	 */</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">getLocalVersion</span><span class="params">(Context context)</span> </span>&#123;</div><div class="line">		PackageManager manager = context.getPackageManager();</div><div class="line">		PackageInfo info = <span class="keyword">null</span>;</div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line">			info = manager.getPackageInfo(context.getPackageName(), <span class="number">0</span>);</div><div class="line">		&#125; <span class="keyword">catch</span> (NameNotFoundException e) &#123;</div><div class="line">			Log.e(TAG, <span class="string">"获取应用程序版本失败，原因："</span> + e.getMessage());</div><div class="line">			<span class="keyword">return</span> <span class="number">0.0</span>;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="keyword">return</span> Double.valueOf(info.versionName);</div><div class="line">	&#125;</div><div class="line">	<span class="comment">/** </span></div><div class="line">     * byte(字节)根据长度转成kb(千字节)和mb(兆字节) </div><div class="line">     *  </div><div class="line">     * <span class="doctag">@param</span> bytes </div><div class="line">     * <span class="doctag">@return</span> </div><div class="line">     */  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">bytes2kb</span><span class="params">(<span class="keyword">long</span> bytes)</span> </span>&#123;  </div><div class="line">        BigDecimal filesize = <span class="keyword">new</span> BigDecimal(bytes);  </div><div class="line">        BigDecimal megabyte = <span class="keyword">new</span> BigDecimal(<span class="number">1024</span> * <span class="number">1024</span>);  </div><div class="line">        <span class="keyword">float</span> returnValue = filesize.divide(megabyte, <span class="number">2</span>, BigDecimal.ROUND_UP)  </div><div class="line">                .floatValue();  </div><div class="line">        <span class="keyword">if</span> (returnValue &gt; <span class="number">1</span>)  </div><div class="line">            <span class="keyword">return</span> (returnValue + <span class="string">"MB"</span>);  </div><div class="line">        BigDecimal kilobyte = <span class="keyword">new</span> BigDecimal(<span class="number">1024</span>);  </div><div class="line">        returnValue = filesize.divide(kilobyte, <span class="number">2</span>, BigDecimal.ROUND_UP)  </div><div class="line">                .floatValue();  </div><div class="line">        <span class="keyword">return</span> (returnValue + <span class="string">"KB"</span>);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>基本上具体的代码就写完了，但是说如果停止了<code>下载管理程序</code> 调用dm.enqueue(req);就会上面的错误,从而程序闪退.</p>
<p>所以在使用该组件的时候,需要判断该组件是否可用:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">canDownloadState</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">int</span> state = <span class="keyword">this</span>.getPackageManager().getApplicationEnabledSetting(<span class="string">"com.android.providers.downloads"</span>);</div><div class="line">        <span class="keyword">if</span> (state == PackageManager.COMPONENT_ENABLED_STATE_DISABLED</div><div class="line">                || state == PackageManager.COMPONENT_ENABLED_STATE_DISABLED_USER</div><div class="line">                || state == PackageManager.COMPONENT_ENABLED_STATE_DISABLED_UNTIL_USED) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">        e.printStackTrace();</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以通过如下代码进入 启用/禁用 下载管理 界面:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">String packageName = <span class="string">"com.android.providers.downloads"</span>;</div><div class="line">   Intent intent = <span class="keyword">new</span> Intent(android.provider.Settings.ACTION_APPLICATION_DETAILS_SETTINGS);</div><div class="line">   intent.setData(Uri.parse(<span class="string">"package:"</span> + packageName));</div><div class="line">   startActivity(intent);</div></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>本文意在讲解app的更新逻辑以及不同的表现形式的处理附带的介绍了使用nodejs写一个简单的api接口，重点是如何使用DownloadManager来实现apk的下载更新安装，顺带讲一下retrofit+rxjava的使用以及如何监听app是否下载完成。</p>
<p>DownloadManager的使用概括：</p>
<blockquote>
<ol>
<li><p>构建下载请求:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;    <span class="keyword">new</span> DownloadManager.Request(url)</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</li>
</ol>
</blockquote>
<p>&gt;</p>
<blockquote>
<ol>
<li><p>设置请求属性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;     request.setXXX()</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</li>
</ol>
</blockquote>
<p>&gt;</p>
<blockquote>
<ol>
<li><p>调用downloadmanager对象的enqueue方法进行下载，此方法返回一个编号用于标示此下载任务：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;    downManager = (DownloadManager)getSystemService(Context.DOWNLOAD_SERVICE);</div><div class="line">&gt;</div><div class="line">&gt;    id= downManager.enqueue(request);</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</li>
</ol>
</blockquote>
<p>&gt;</p>
<blockquote>
<ol>
<li><p>DownManager会对所有的现在任务进行保存管理，那么我们如何获取这些信息呢？这个时候就要用到DownManager.Query对象，通过此对象，我们可以查询所有下载任务信息。</p>
<p><strong>setFilterById(long… ids)：根据任务编号查询下载任务信息</strong></p>
<p><strong>setFilterByStatus(int flags)：根据下载状态查询下载任务</strong></p>
</li>
<li><p>如果想取消下载，则可以调用remove方法完成，此方法可以将下载任务和已经下载的文件同时删除：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;    downManager.remove(id);</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</li>
</ol>
</blockquote>
<p>好了具体的都讲的差不多了，本文以同步到我的csdn:<a href="http://blog.csdn.net/u013278099/article/details/52692008" target="_blank" rel="external">安卓开发实战之app之版本更新升级(DownloadManager和http下载)完整实现</a></p>
<p>demo 传送门：<a href="http://download.csdn.net/detail/u013278099/9642306" target="_blank" rel="external">AppUpdate.rar</a></p>
<hr>
<p>未经许可不得转载，转载请注明zilianliuxue的blog,本人保留所有版权。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;本文将讲解app的升级与更新。一般而言用户使用App的时候升级提醒有两种方式获得：&lt;/p&gt;
&lt;ul&gt;
&lt;l
    
    </summary>
    
      <category term="android" scheme="http://zilianliuxue.github.io/categories/android/"/>
    
    
      <category term="app版本更新" scheme="http://zilianliuxue.github.io/tags/app%E7%89%88%E6%9C%AC%E6%9B%B4%E6%96%B0/"/>
    
  </entry>
  
  <entry>
    <title>Fragment之我的解决方案：Fragmentation</title>
    <link href="http://zilianliuxue.github.io/2016/09/06/Fragment%E4%B9%8B%E6%88%91%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%9AFragmentation/"/>
    <id>http://zilianliuxue.github.io/2016/09/06/Fragment之我的解决方案：Fragmentation/</id>
    <published>2016-09-06T08:23:00.000Z</published>
    <updated>2016-09-06T04:57:09.082Z</updated>
    
    <content type="html"><![CDATA[<p>原文链接：<a href="http://www.jianshu.com/p/fd71d65f0ec6" target="_blank" rel="external">http://www.jianshu.com/p/fd71d65f0ec6</a></p>
<p>Fragment系列文章：<br>1、<a href="https://zilianliuxue.github.io/2016/09/06/Fragment%E5%85%A8%E8%A7%A3%E6%9E%90%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E9%82%A3%E4%BA%9B%E5%B9%B4%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91/">Fragment全解析系列（一）：那些年踩过的坑</a><br>2、<a href="https://zilianliuxue.github.io/2016/09/06/Fragment%E5%85%A8%E8%A7%A3%E6%9E%90%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E6%AD%A3%E7%A1%AE%E7%9A%84%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF%20/">Fragment全解析系列（二）：正确的使用姿势</a><br>3、Fragment之我的解决方案：Fragmentation</p>
<p>附：<a href="http://www.jianshu.com/p/626229ca4dc2" target="_blank" rel="external">SwipeBackFragment的实现分析</a></p>
<p>如果你通读了本系列的前两篇，我相信你可以写出大部分场景都能正常运行的Fragment了。如果你想了解更多，那么你可以看看我封装的这个库：Fragmentation。<br>本篇主要介绍这个库，解决了一些BUG，使用简单，提供实时查看栈视图等实用功能。</p>
<hr>
<p>源码地址：<a href="https://github.com/YoKeyword/Fragmentation" target="_blank" rel="external">Github</a>，欢迎Star，Fork。</p>
<p><a href="https://pan.baidu.com/s/1gfNQKU3" target="_blank" rel="external">Demo网盘下载</a><br>Demo演示：<br>单Activity + 多Fragment，项目中有3个Demo。</p>
<p>流式的单Activity＋多Fragment：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/937851-23ae58f2b4d13842.gif?imageMogr2/auto-orient/strip" alt=""></p>
<p>类似微信交互方式的单Activity+多Fragment：（全页面支持滑动返回）</p>
<p><img src="http://upload-images.jianshu.io/upload_images/937851-0f488a2b2598d28b.gif?imageMogr2/auto-orient/strip" alt=""></p>
<p>类似新版仿知乎交互方式的单Activity＋多Frgment</p>
<p><img src="http://upload-images.jianshu.io/upload_images/937851-6ef2ba710a9a78d7.gif?imageMogr2/auto-orient/strip" alt=""></p>
<h1 id="Fragmentation"><a href="#Fragmentation" class="headerlink" title="Fragmentation"></a>Fragmentation</h1><p>为”单Activity ＋ 多Fragment的架构”,”多模块Activity + 多Fragment的架构”而生，帮你简化使用过程，轻松解决各种复杂嵌套等问题，修复了官方Fragment库存在的一些BUG。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/937851-786e8de65830922a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p>
<h1 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h1><p>1、<strong>有效解决各种复杂嵌套、同级等Fragment重叠问题</strong></p>
<p>2、<strong>实时查看Fragment的(包括嵌套Fragment)栈视图的对话框和Log，方便调试</strong></p>
<p>3、<strong>增加启动模式、startForResult等类似Activity的方法</strong></p>
<p>4、<strong>类似Android事件分发机制的Fragment回退方法：onBackPressedSupport()，轻松为每个Fragment实现Back按键事件</strong></p>
<p>5、<strong>完美的防抖动解决方案(防止用户点击速度过快,导致启动多个Fragment)</strong></p>
<p>6、<strong>提供可轻松 设定Fragment转场动画 的解决方案</strong></p>
<p>7、<strong>修复官方库里pop(tag/id)出栈多个Fragment时的一些BUG</strong></p>
<p>8、<strong>支持SwipeBack滑动边缘退出(需要使用Fragmentation_SwipeBack库,详情README)</strong></p>
<p><img src="http://upload-images.jianshu.io/upload_images/937851-84b897cc5ac876d6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1024" alt=""></p>
<h1 id="重大更新日志"><a href="#重大更新日志" class="headerlink" title="重大更新日志"></a>重大更新日志</h1><h3 id="0-7-X-来了！！！"><a href="#0-7-X-来了！！！" class="headerlink" title="0.7.X 来了！！！"></a>0.7.X 来了！！！</h3><p>1、2个新demo: 仿知乎交互 ＋ 仿微信交互的新Demo，展示复杂嵌套Fragment的交互场景</p>
<p>2、全新的Fragment恢复机制</p>
<p>3、更容易编写各种嵌套Fragment的代码</p>
<p>4、支持同级Fragment的处理</p>
<p>5、实验性支持SharedElement－Material过渡动画</p>
<p>6、全新的类似Android事件分发机制的onBackPressedSupport()</p>
<h1 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h1><p><strong>1. 项目下app的build.gradle中依赖：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// appcompat v7包是必须的</div><div class="line">compile &apos;me.yokeyword:fragmentation:0.7.9&apos;</div><div class="line">// 如果想使用SwipeBack 滑动边缘退出Fragment/Activity功能，请再添加下面的库</div><div class="line">// compile &apos;me.yokeyword:fragmentation-swipeback:0.7.9&apos;</div></pre></td></tr></table></figure>
<p><strong>2. Activity继承SupportActivity：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public class MainActivity extends SupportActivity &#123;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(...);</div><div class="line">        if (savedInstanceState == null) &#123;</div><div class="line">            loadRootFragment(R.id.fl_container, HomeFragment.newInstance());  </div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p><strong>3. Fragment继承SupportFragment：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class HomeFragment extends SupportFragment &#123;</div><div class="line"></div><div class="line">    private void xxx() &#123;</div><div class="line">        // 启动新的Fragment, 同时还有start(fragment,SINGTASK)、startForResult、startWithPop等启动方法</div><div class="line">        start(DetailFragment.newInstance(HomeBean));</div><div class="line">        // ... 其他方法请自行查看 API</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="进一步使用，查看wiki"><a href="#进一步使用，查看wiki" class="headerlink" title="进一步使用，查看wiki"></a><a href="https://github.com/YoKeyword/Fragmentation/wiki" target="_blank" rel="external">进一步使用，查看wiki</a></h3><hr>
<p>未经许可不得转载，转载请注明zilianliuxue的blog,本人保留所有版权。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原文链接：&lt;a href=&quot;http://www.jianshu.com/p/fd71d65f0ec6&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.jianshu.com/p/fd71d65f0ec6&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Frag
    
    </summary>
    
      <category term="android" scheme="http://zilianliuxue.github.io/categories/android/"/>
    
    
      <category term="Fragment" scheme="http://zilianliuxue.github.io/tags/Fragment/"/>
    
  </entry>
  
  <entry>
    <title>Fragment全解析系列（二）：正确的使用姿势</title>
    <link href="http://zilianliuxue.github.io/2016/09/06/Fragment%E5%85%A8%E8%A7%A3%E6%9E%90%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E6%AD%A3%E7%A1%AE%E7%9A%84%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF%20/"/>
    <id>http://zilianliuxue.github.io/2016/09/06/Fragment全解析系列（二）：正确的使用姿势 /</id>
    <published>2016-09-06T07:57:00.000Z</published>
    <updated>2016-09-06T05:05:28.034Z</updated>
    
    <content type="html"><![CDATA[<p>原文链接：<a href="http://www.jianshu.com/p/fd71d65f0ec6" target="_blank" rel="external">http://www.jianshu.com/p/fd71d65f0ec6</a></p>
<p>Fragment系列文章：<br>1、<a href="https://zilianliuxue.github.io/2016/09/06/Fragment%E5%85%A8%E8%A7%A3%E6%9E%90%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E9%82%A3%E4%BA%9B%E5%B9%B4%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91/">Fragment全解析系列（一）：那些年踩过的坑</a><br>2、Fragment全解析系列（二）：正确的使用姿势<br>3、<a href="https://zilianliuxue.github.io/2016/09/06/Fragment%E4%B9%8B%E6%88%91%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%9AFragmentation/">Fragment之我的解决方案：Fragmentation</a></p>
<p>本篇主要介绍一些Fragment使用技巧。</p>
<hr>
<p>Fragment是可以让你的app纵享丝滑的设计，如果你的app想在现在基础上<strong>性能大幅度提高</strong>，并且<strong>占用内存降低</strong>，同样的界面Activity占用内存比Fragment要多，响应速度Fragment比Activty在中低端手机上快了很多，甚至能达到好几倍！如果你的app当前或以后有<strong>移植</strong>平板等平台时，可以让你节省大量时间和精力。</p>
<hr>
<p><em>简陋的目录</em><br><strong>1、一些使用建议</strong><br><strong>2、add(), show(), hide(), replace()的那点事</strong><br><strong>3、关于FragmentManager你需要知道的</strong><br><strong>4、使用FragmentPagerAdapter+ViewPager的注意事项</strong><br><strong>5、Fragment事务和动画，你可能不知道的坑</strong><br><strong>6、是使用单Activity＋多Fragment的架构，还是多模块Activity＋多Fragment的架构？</strong></p>
<hr>
<p>作为一个稳定的app，从后台且回到前台，一定会在任何情况都能恢复到离开前的页面，并且保证数据的完整性。</p>
<p>如果你没看过本系列的<a href="undefined">第一篇</a>，为了方便后面文章的介绍，先规定一个“术语”，安卓app有一种特殊情况，就是 app运行在后台的时候，系统资源紧张的时候导致把app的资源全部回收（杀死app的进程），这时把app再从后台返回到前台时，app会重启。这种情况下文简称为：“内存重启”。（屏幕旋转等配置变化也会造成当前Activity重启，本质与“内存重启”类似）</p>
<h1 id="1、一些使用建议"><a href="#1、一些使用建议" class="headerlink" title="1、一些使用建议"></a>1、一些使用建议</h1><p>1、对Fragment传递数据，建议使用<code>setArguments(Bundle args)</code>，而后在<code>onCreate</code>中使用<code>getArguments()</code>取出，在 “内存重启”前，系统会帮你保存数据，不会造成数据的丢失。和Activity的Intent原理一致。</p>
<p>2、使用<code>newInstance(参数)</code> 创建Fragment对象，优点是调用者只需要关系传递的哪些数据，而无需关心传递数据的Key是什么。</p>
<p>3、如果你需要在Fragment中用到宿主Activity对象，建议在你的基类Fragment定义一个Activity的全局变量，在<code>onAttach</code>中初始化，这不是最好的解决办法，但这可以有效避免一些意外Crash。详细原因参考<a href="https://zilianliuxue.github.io/2016/09/06/%E4%BB%8E%E6%BA%90%E7%A0%81%E8%A7%92%E5%BA%A6%E5%88%86%E6%9E%90%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%8F%91%E7%94%9FFragment%E9%87%8D%E5%8F%A0%EF%BC%9F/">第一篇</a>的“getActivity()空指针”部分。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">protected</span> Activity mActivity;</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAttach</span><span class="params">(Activity activity)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>.onAttach(activity);</div><div class="line">    <span class="keyword">this</span>.mActivity = activity;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="2、add-show-hide-replace-的那点事"><a href="#2、add-show-hide-replace-的那点事" class="headerlink" title="2、add(), show(), hide(), replace()的那点事"></a>2、add(), show(), hide(), replace()的那点事</h1><p><strong>1、区别</strong> </p>
<p><code>show()</code>，<code>hide()</code>最终是让Fragment的View <code>setVisibility</code>(true还是false)，不会调用生命周期；<br><code>replace()</code>的话会销毁视图，即调用onDestoryView、onCreateView等一系列生命周期；<br> <code>add()</code>和 <code>replace()</code>不要在同一个阶级的FragmentManager里混搭使用。</p>
<p><strong>2、使用场景</strong><br>如果你有一个很高的概率会再次使用当前的Fragment，建议使用<code>show()</code>，<code>hide()</code>，可以提高性能。</p>
<p>在我使用Fragment过程中，大部分情况下都是用<code>show()</code>，<code>hide()</code>，而不是<code>replace()</code>。</p>
<p>注意：如果你的app有大量图片，这时更好的方式可能是replace，配合你的图片框架在Fragment视图销毁时，回收其图片所占的内存。</p>
<p><strong>3、onHiddenChanged的回调时机</strong><br> 当使用<code>add()</code>+<code>show()，hide()</code>跳转新的Fragment时，旧的Fragment回调<code>onHiddenChanged()</code>，不会回调<code>onStop()</code>等生命周期方法，而新的Fragment在创建时是不会回调<code>onHiddenChanged()</code>，这点要切记。</p>
<p><strong>4、Fragment重叠问题</strong><br>使用<code>show()</code>，<code>hide()</code>带来的一个问题就是，如果你不做任何处理，在“内存重启”后，Fragment会重叠；</p>
<p>有些小伙伴可能就是为了避免Fragment重叠问题，而选择使用<code>replace()</code>，但是使用<code>show()</code>，<code>hide()</code>时，重叠问题是完全可以解决的，有两种方式解决，详情参考<a href="https://zilianliuxue.github.io/2016/09/06/Fragment%E5%85%A8%E8%A7%A3%E6%9E%90%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E9%82%A3%E4%BA%9B%E5%B9%B4%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91/">上一篇</a>。</p>
<h1 id="3、关于FragmentManager你需要知道的"><a href="#3、关于FragmentManager你需要知道的" class="headerlink" title="3、关于FragmentManager你需要知道的"></a>3、关于FragmentManager你需要知道的</h1><p>1、FragmentManager栈视图</p>
<p>（1）每个Fragment以及宿主Activity(继承自FragmentActivity)都会在创建时，初始化一个FragmentManager对象，处理好Fragment嵌套问题的关键，就是理清这些不同阶级的栈视图。</p>
<p>下面给出一个简要的<strong>关系图</strong>：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/937851-6e0b034db7df7199.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="栈关系图.png"></p>
<p>（2）对于宿主Activity，<code>getSupportFragmentManager()</code>获取的FragmentActivity的FragmentManager对象;</p>
<p>对于Fragment，<code>getFragmentManager()</code>是获取的是父Fragment(如果没有，则是FragmentActivity)的FragmentManager对象，而<code>getChildFragmentManager()</code>是获取自己的FragmentManager对象。</p>
<p><strong>2、恢复Fragment时（同时防止Fragment重叠），选择getFragments()还是findFragmentByTag()</strong><br><strong> 6月12日更：可以直接跳过，看我的解决方案，9行代码解决所有情况的Fragment重叠，传送门</strong><br>（1）选择<code>getFragments()</code><br>对于一个Activity内的多个Fragment，如果Fragment的关系是“流程”，比如登录-&gt;注册/忘记密码-&gt;填写信息-&gt;跳转到主页Activity。这种情况下，用getFragments()的方式是最合适的，在你的Activity内（更好的方式是在你的所有”流程”基类Activity里），写下如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">  protected void onCreate(@Nullable Bundle savedInstanceState) &#123;</div><div class="line">      super.onCreate(savedInstanceState);</div><div class="line"></div><div class="line">      if (savedInstanceState != null) &#123;</div><div class="line">          List&lt;Fragment&gt; fragments = getSupportFragmentManager().getFragments();</div><div class="line"></div><div class="line">          if (fragments != null &amp;&amp; fragments.size() &gt; 0) &#123;</div><div class="line">              boolean showFlag = false;</div><div class="line"></div><div class="line">              FragmentTransaction ft = getSupportFragmentManager().beginTransaction();</div><div class="line">              for (int i = fragments.size() - 1; i &gt;= 0; i--) &#123;</div><div class="line">                  Fragment fragment = fragments.get(i);</div><div class="line">                  if (fragment != null) &#123;</div><div class="line">                      if (!showFlag) &#123;</div><div class="line">                          ft.show(fragments.get(i));</div><div class="line">                          showFlag = true;</div><div class="line">                      &#125; else &#123;</div><div class="line">                          ft.hide(fragments.get(i));</div><div class="line">                      &#125;</div><div class="line">                  &#125;</div><div class="line">              &#125;</div><div class="line">              ft.commit();</div><div class="line">          &#125;</div><div class="line">      &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>上面恢复Fragment的方式，不仅提高性能，同时避免了Fragment重叠现象，最重要的事，你根本<strong>不用关心Activity容器里都有哪些Fragment。</strong></p>
<p>（2）选择<code>findFragmentByTag()</code>恢复<br>如果你的Activity的Fragments，不是“流程”关系，而是“同级”关系，比如QQ的主界面，“消息”、“联系人”、“动态”，这3个Fragment属于同级关系，用上面的代码就不合适了，恢复的时候总会恢复最后一个，即“动态Fragment”。<br>正确的做法是在<code>onSaveInstanceState()</code>内保存当前所在Fragment的tag或者下标，在<code>onCreate()</code>是恢复的时候，隐藏其它2个Fragment。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">    super.onCreate(savedInstanceState);</div><div class="line">    setContentView(R.layout.activity);</div><div class="line"></div><div class="line">    MsgFragment msgFragment;</div><div class="line">    ContactFragment contactFragment;</div><div class="line">    MeFragment meFragment;</div><div class="line"></div><div class="line">    if (savedInstanceState != null) &#123;  // “内存重启”时调用</div><div class="line">        msgFragment = getSupportFragmentManager().findFragmentByTag(MsgFragment.class.getName);</div><div class="line">        contactFragment = getSupportFragmentManager().findFragmentByTag(ContactFragment.class.getName);</div><div class="line">        meFragment = getSupportFragmentManager().findFragmentByTag(MeFragment.class.getName);</div><div class="line"></div><div class="line">        index = saveInstanceState.getInt(KEY_INDEX);</div><div class="line">        // 根据下标判断离开前是显示哪个Fragment，</div><div class="line">        // 这里省略判断代码，假设离开前是ConactFragment</div><div class="line">        // 解决重叠问题</div><div class="line">        getFragmentManager().beginTransaction()</div><div class="line">                .show(contactFragment)</div><div class="line">                .hide(msgFragment)</div><div class="line">                .hide(meFragment)</div><div class="line">                .commit();</div><div class="line">    &#125;else&#123;  // 正常时</div><div class="line">        msgFragment = MsgFragment.newInstance();</div><div class="line">        contactFragment = ContactFragment.newInstance();</div><div class="line">        meFragment = MeFragment.newInstance();</div><div class="line"></div><div class="line">        getFragmentManager().beginTransaction()</div><div class="line">                .add(R.id.container, msgFragment, msgFragment.getClass().getName())</div><div class="line">                .add(R.id.container, contactFragment, contactFragment.getClass().getName())</div><div class="line">                .add(R.id,container,meFragment,meFragment.getClass().getName())</div><div class="line">                .hide(contactFragment)</div><div class="line">                .hide(meFragment)</div><div class="line">                .commit();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@Override</div><div class="line">public void onSaveInstanceState(Bundle outState) &#123;</div><div class="line">    super.onSaveInstanceState(outState);</div><div class="line">    // 保存当前Fragment的下标</div><div class="line">    outState.putInt(KEY_INDEX, index);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当然在“同级”关系中，使用getFragments()恢复也是可以的。</p>
<p><strong> 6月12日更：我的解决方案，9行代码解决所有情况的Fragment重叠，传送门</strong></p>
<h1 id="4、使用FragmentPagerAdapter-ViewPager的注意事项"><a href="#4、使用FragmentPagerAdapter-ViewPager的注意事项" class="headerlink" title="4、使用FragmentPagerAdapter+ViewPager的注意事项"></a>4、使用FragmentPagerAdapter+ViewPager的注意事项</h1><p>1、使用FragmentPagerAdapter+ViewPager时，切换回上一个Fragment页面时（已经初始化完毕）</p>
<p>使用FragmentPagerAdapter+ViewPager时，切换回上一个Fragment页面时（已经初始化完毕），不会回调任何生命周期方法以及<code>onHiddenChanged()</code>，只有<code>setUserVisibleHint(boolean isVisibleToUser)</code>会被回调，所以如果你想进行一些懒加载，需要在这里处理。</p>
<p>2、在给ViewPager绑定FragmentPagerAdapter时，<code>new FragmentPagerAdapter(fragmentManager)</code>的FragmentManager，一定要保证正确，如果ViewPager是Activity内的控件，则传递<code>getSupportFragmentManager()</code>，如果是Fragment的控件中，则应该传递<code>getChildFragmentManager()</code>。只要记住ViewPager内的Fragments是当前组件的子Fragment这个原则即可。</p>
<p>3、你不需要在“内存重启”的情况下，去恢复的Fragments，有FragmentPagerAdapter的存在，不需要你去做恢复工作。</p>
<h1 id="5、Fragment事务和动画，你可能不知道的坑"><a href="#5、Fragment事务和动画，你可能不知道的坑" class="headerlink" title="5、Fragment事务和动画，你可能不知道的坑"></a>5、Fragment事务和动画，你可能不知道的坑</h1><p>1、如果你在使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">popBackStackImmdiate()</div></pre></td></tr></table></figure>
<p>方法后，紧接着直接调用类似如下事务的方法，出栈动画还没完成就进行下一个事务方法，这会导致在内存重启后按返回键报错问题。</p>
<p>如果你设置了动画，这个异常你可能比较熟悉</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">getSupportFragmentManager().popBackStackImmdiate();</div><div class="line">getSupportFragmentManager().beginTransaction()</div><div class="line">        .add(R.id.container, fragment , tag)</div><div class="line">        .hide(currentFragment)</div><div class="line">        .commit;</div></pre></td></tr></table></figure>
<p>正确的做法是使用主线程的Handler，将事务放到Runnable里运行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">getSupportFragmentManager().popBackStackImmdiate();</div><div class="line">new Handler().postDelay(new Runnable()&#123;</div><div class="line">          @Override</div><div class="line">           public void run() &#123;</div><div class="line">                // 在这里执行Fragment事务</div><div class="line">           &#125;</div><div class="line">&#125;, 你的出栈动画时间);</div></pre></td></tr></table></figure>
<p>2、给Fragment设定Fragment转场动画时，如果你的app有使用popStackBackxx(tag/id,flags)出栈多个Fragment时，应避免直接使用<code>.setCustomAnimations(enter, exit, popEnter, popExit)</code>，需要配合<code>onCreateAnimtation方法</code>将出栈动画临时取消，本系列最后一篇给出了我的解决方案，解决了该问题，有兴趣可以自行查看 :)</p>
<p><strong>(注意：如果你想给下一个Fragment设置进栈动画和出栈动画，.setCustomAnimations(enter, exit)只能设置进栈动画，第二个参数并不是设置出栈动画；请使用.setCustomAnimations(enter, exit, popEnter, popExit)，这个方法的第1个参数对应进栈动画，第4个参数对应出栈动画，所以是.setCustomAnimations(进栈动画, exit, popEnter, 出栈动画))</strong></p>
<p><strong>另外一提</strong>：谨慎使用<code>popStackBack(String tag/int id,int flasg)</code>系列的方法，原因在<a href="https://zilianliuxue.github.io/2016/09/06/Fragment%E5%85%A8%E8%A7%A3%E6%9E%90%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E9%82%A3%E4%BA%9B%E5%B9%B4%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91/">上一篇</a>中已经描述。</p>
<p><strong>Tip：</strong><br><strong>如果你遇到Fragment的mNextAnim空指针的异常（通常是在你的Fragment被重启的情况下），那么你首先需要检查是否操作的Fragment是否为null；其次在你的Fragment转场动画还没结束时，你是否就执行了其他事务等方法；解决思路就是延迟一个动画时间再执行事务，或者临时将该Fragment设为无动画</strong></p>
<h1 id="6、是使用单Activity＋多Fragment的架构，还是多模块Activity＋多Fragment的架构？"><a href="#6、是使用单Activity＋多Fragment的架构，还是多模块Activity＋多Fragment的架构？" class="headerlink" title="6、是使用单Activity＋多Fragment的架构，还是多模块Activity＋多Fragment的架构？"></a>6、是使用单Activity＋多Fragment的架构，还是多模块Activity＋多Fragment的架构？</h1><p>单Activity＋多Fragment：</p>
<p>一个app仅有一个Activity，界面皆是Frament，Activity作为app容器使用。</p>
<p>优点：性能高，速度最快。参考：新版知乎 、google系app</p>
<p>缺点：逻辑比较复杂，尤其当Fragment之间联动较多或者嵌套较深时，比较复杂。</p>
<p><strong>多模块Activity＋多Fragment：</strong><br>一个模块用一个Activity，比如<br>1、登录注册流程：<br>LoginActivity + 登录Fragment + 注册Fragment + 填写信息Fragment ＋ 忘记密码Fragment<br>2、或者常见的数据展示流程：<br>DataActivity + 数据列表Fragment + 数据详情Fragment ＋ …</p>
<p>优点：速度快，相比较单Activity+多Fragment，更易维护。</p>
<p><strong>我的观点：</strong><br>权衡利弊，我认为多模块Activity＋多Fragment是最合适的架构，开发起来不是很复杂，app的性能又很高效。</p>
<p>当然。<strong>Fragment只是官方提供的灵活组件，请优先遵从你的项目设计！</strong>真的特别复杂的界面，或者单个Activity就可以完成一个流程的界面，使用Activity可能是更好的方案。</p>
<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>如果你读完了<a href="https://zilianliuxue.github.io/2016/09/06/%E4%BB%8E%E6%BA%90%E7%A0%81%E8%A7%92%E5%BA%A6%E5%88%86%E6%9E%90%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%8F%91%E7%94%9FFragment%E9%87%8D%E5%8F%A0%EF%BC%9F/">第一篇</a>和这篇文章，那么我相信你使用多模块Activity+多Fragment的架构所遇到的坑，大部分都应该能找到解决办法。</p>
<p>但是如果流程较为复杂，比如Fragment A需要启动一个新的Fragment B并且关闭当前A,或者A启动B，B在获取数据后，想在返回到A时把数据交给A（类似Activity的<code>startActivityForResult</code>），又或者你保证在Fragment转场动画的情况下，使用<code>pop(tag\id)</code>从栈内退出多个Fragment，或者你甚至想Fragment有一个类似Activity的<code>SingleTask</code>启动模式，那么你可以参考<a href="https://zilianliuxue.github.io/2016/09/06/Fragment%E4%B9%8B%E6%88%91%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%9AFragmentation/">下一篇</a>，我的解决方案库，<a href="https://github.com/YoKeyword/Fragmentation" target="_blank" rel="external">Fragmentation</a>。它甚至提供了一个让你在开发时，可以随时查看所有阶级的栈视图的UI界面。</p>
<hr>
<p>未经许可不得转载，转载请注明zilianliuxue的blog,本人保留所有版权。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原文链接：&lt;a href=&quot;http://www.jianshu.com/p/fd71d65f0ec6&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.jianshu.com/p/fd71d65f0ec6&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Frag
    
    </summary>
    
      <category term="android" scheme="http://zilianliuxue.github.io/categories/android/"/>
    
    
      <category term="Fragment" scheme="http://zilianliuxue.github.io/tags/Fragment/"/>
    
  </entry>
  
  <entry>
    <title>Fragment全解析系列（一）：那些年踩过的坑</title>
    <link href="http://zilianliuxue.github.io/2016/09/06/Fragment%E5%85%A8%E8%A7%A3%E6%9E%90%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E9%82%A3%E4%BA%9B%E5%B9%B4%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91/"/>
    <id>http://zilianliuxue.github.io/2016/09/06/Fragment全解析系列（一）：那些年踩过的坑/</id>
    <published>2016-09-06T07:20:00.000Z</published>
    <updated>2016-09-06T05:05:14.813Z</updated>
    
    <content type="html"><![CDATA[<p>原文链接：<a href="http://www.jianshu.com/p/d9143a92ad94" target="_blank" rel="external">http://www.jianshu.com/p/d9143a92ad94</a><br>Fragment系列文章：<br>1、Fragment全解析系列（一）：那些年踩过的坑<br>2、<a href="https://zilianliuxue.github.io/2016/09/06/Fragment%E5%85%A8%E8%A7%A3%E6%9E%90%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E6%AD%A3%E7%A1%AE%E7%9A%84%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF%20/">Fragment全解析系列（二）：正确的使用姿势</a><br>3、<a href="https://zilianliuxue.github.io/2016/09/06/Fragment%E4%B9%8B%E6%88%91%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%9AFragmentation/">Fragment之我的解决方案：Fragmentation</a></p>
<p>本篇主要介绍一些最常见的Fragment的坑以及官方Fragment库的那些自身的BUG，这些BUG在你深度使用时会遇到，比如Fragment嵌套时或者单Activity＋多Fragment架构时遇到的坑。<br>如果想看较为实用的技巧，请直接看<a href="https://zilianliuxue.github.io/2016/09/06/Fragment%E5%85%A8%E8%A7%A3%E6%9E%90%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E6%AD%A3%E7%A1%AE%E7%9A%84%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF%20/">第二篇</a></p>
<hr>
<p>Fragment是可以让你的app纵享丝滑的设计，如果你的app想在现在基础上<strong>性能大幅度提高</strong>，并且<strong>占用内存降低</strong>，同样的界面Activity占用内存比Fragment要多，响应速度Fragment比Activty在中低端手机上快了很多，甚至能达到好几倍！如果你的app当前或以后有<strong>移植</strong>平板等平台时，可以让你节省大量时间和精力。</p>
<hr>
<p><em>简陋的目录</em><br><strong>1、getActivity()空指针</strong><br><strong>2、Fragment重叠异常—–正确使用hide、show的姿势</strong><br><strong>3、Fragment嵌套的那些坑</strong><br><strong>4、未必靠谱的出栈方法remove()</strong><br><strong>5、多个Fragment同时出栈的那些深坑BUG</strong><br><strong>6、超级深坑 Fragment转场动画</strong></p>
<hr>
<h1 id="开始之前"><a href="#开始之前" class="headerlink" title="开始之前"></a>开始之前</h1><p>最新版知乎，单Activity多Fragment的架构，响应可以说非常“丝滑”，非要说缺点的话，就是没有转场动画，并且转场会有类似闪屏现象。我猜测可能和Fragment转场动画的一些BUG有关。（这系列的最后一篇文章我会给出我的解决方案，可以自定义转场动画，并能在各种特殊情况下正常运行。）</p>
<p>但是！Fragment相比较Activity要难用很多，在多Fragment以及嵌套Fragment的情况下更是如此。<br>更重要的是Fragment的坑真的太多了，看Square公司的这篇文章吧，<a href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/0605/2996.html" target="_blank" rel="external">Square：从今天开始抛弃Fragment吧！</a></p>
<p>当然，不能说不再用Fragment，Fragment的这些坑都是有解决办法的，官方也在逐步修复一些BUG。<br>下面罗列一些，有常见的，也有极度隐蔽的一些坑，也是我在用单Activity多Fragment时遇到的坑，可能有更多坑可以挖掘…</p>
<p>在这之前为了方便后面文章的介绍，先规定一个“术语”，安卓app有一种特殊情况，就是 app运行在后台的时候，系统资源紧张的时候导致把app的资源全部回收（杀死app的进程），这时把app再从后台返回到前台时，app会重启。这种情况下文简称为：<strong>“内存重启”</strong>。（屏幕旋转等配置变化也会造成当前Activity重启，本质与“内存重启”类似）</p>
<p>在系统要把app回收之前，系统会把Activity的状态保存下来，Activity的FragmentManager负责把Activity中的Fragment保存起来。在“内存重启”后，Activity的恢复是从栈顶逐步恢复，Fragment会在宿主Activity的<code>onCreate</code>方法调用后紧接着恢复（<code>从onAttach</code>生命周期开始）。</p>
<h1 id="getActivity-空指针"><a href="#getActivity-空指针" class="headerlink" title="getActivity()空指针"></a>getActivity()空指针</h1><p>可能你遇到过getActivity()返回null，或者平时运行完好的代码，在“内存重启”之后，调用getActivity()的地方却返回null，报了空指针异常。</p>
<p>大多数情况下的原因：你在调用了getActivity()时，当前的Fragment已经<code>onDetach()</code>了宿主Activity。<br>比如：你在pop了Fragment之后，该Fragment的异步任务仍然在执行，并且在执行完成后调用了getActivity()方法，这样就会空指针。</p>
<p>解决办法：<br><strong>更”安全”的方法</strong>：(对于Fragment已经onDetach这种情况，我们应该避免在这之后再去调用宿主Activity对象，比如取消这些异步任务，但我们的团队可能会有粗心大意的情况，所以下面给出的这个方案会保证安全)</p>
<p>在Fragment基类里设置一个Activity mActivity的全局变量，在<code>onAttach(Activity activity)</code>里赋值，使用mActivity代替<code>getActivity()</code>，保证Fragment即使在<code>onDetach</code>后，仍持有Activity的引用（有引起内存泄露的风险，但是相比空指针闪退，这种做法“安全”些），即：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">protected Activity mActivity;</div><div class="line">@Override</div><div class="line">public void onAttach(Activity activity) &#123;</div><div class="line">    super.onAttach(activity);</div><div class="line">    this.mActivity = activity;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line">*  如果你用了support 23的库，上面的方法会提示过时，有强迫症的小伙伴，可以用下面的方法代替</div><div class="line">*/</div><div class="line">@Override</div><div class="line">public void onAttach(Context context) &#123;</div><div class="line">    super.onAttach(context);</div><div class="line">    this.mActivity = (Activity)context;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="Fragment重叠异常—–正确使用hide、show的姿势"><a href="#Fragment重叠异常—–正确使用hide、show的姿势" class="headerlink" title="Fragment重叠异常—–正确使用hide、show的姿势"></a>Fragment重叠异常—–正确使用hide、show的姿势</h1><p>如果你<code>add()</code>了几个Fragment，使用<code>show()、hide()</code>方法控制，比如微信、QQ的底部tab等情景，如果你什么都不做的话，在“内存重启”后回到前台，app的这几个Fragment界面会重叠。</p>
<p>原因是FragmentManager帮我们管理Fragment，当发生“内存重启”，他会从栈底向栈顶的顺序一次性恢复Fragment；<br>但是因为没有保存Fragment的mHidden属性，默认为false，即show状态，所以所有Fragment都是以show的形式恢复，我们看到了界面重叠。<br>（如果是<code>replace</code>，恢复形式和Activity一致，只有当你pop之后上一个Fragment才开始重新恢复，所有使用<code>replace</code>不会造成重叠现象）</p>
<p>详细原因：<a href="https://zilianliuxue.github.io/2016/09/06/%E4%BB%8E%E6%BA%90%E7%A0%81%E8%A7%92%E5%BA%A6%E5%88%86%E6%9E%90%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%8F%91%E7%94%9FFragment%E9%87%8D%E5%8F%A0%EF%BC%9F/">从源码角度分析，为什么会发生Fragment重叠？</a></p>
<p>这里给出3个解决方案：<br><strong>1、是大家比较熟悉的 findFragmentByTag：</strong></p>
<p>即在<code>add()</code>或者<code>replace()</code>时绑定一个tag，一般我们是用fragment的类名作为tag，然后在发生“内存重启”时，通过<code>findFragmentByTag</code>找到对应的Fragment，并<code>hide()</code>需要隐藏的fragment。</p>
<p>下面是个标准恢复写法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">    super.onCreate(savedInstanceState);</div><div class="line">    setContentView(R.layout.activity);</div><div class="line"></div><div class="line">    TargetFragment targetFragment;</div><div class="line">    HideFragment hideFragment;</div><div class="line"></div><div class="line">    if (savedInstanceState != null) &#123;  // “内存重启”时调用</div><div class="line">        targetFragment = getSupportFragmentManager().findFragmentByTag(TargetFragment.class.getName);</div><div class="line">        hideFragment = getSupportFragmentManager().findFragmentByTag(HideFragment.class.getName);</div><div class="line">        // 解决重叠问题</div><div class="line">        getFragmentManager().beginTransaction()</div><div class="line">                .show(targetFragment)</div><div class="line">                .hide(hideFragment)</div><div class="line">                .commit();</div><div class="line">    &#125;else&#123;  // 正常时</div><div class="line">        targetFragment = TargetFragment.newInstance();</div><div class="line">        hideFragment = HideFragment.newInstance();</div><div class="line"></div><div class="line">        getFragmentManager().beginTransaction()</div><div class="line">                .add(R.id.container, targetFragment, targetFragment.getClass().getName())</div><div class="line">                .add(R.id,container,hideFragment,hideFragment.getClass().getName())</div><div class="line">                .hide(hideFragment)</div><div class="line">                .commit();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果你想恢复到用户离开时的那个Fragment的界面，你还需要在<code>onSaveInstanceState(Bundle outState)</code>里保存离开时的那个可见的tag或下标，在<code>onCreate</code>“内存重启”代码块中，取出tag/下标，进行恢复。</p>
<p><strong>2、使用getSupportFragmentManager().getFragments()恢复</strong></p>
<p>通过<code>getFragments()</code>可以获取到当前FragmentManager管理的栈内所有Fragment。</p>
<p>标准写法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">    super.onCreate(savedInstanceState);</div><div class="line">    setContentView(R.layout.activity);</div><div class="line"></div><div class="line">    TargetFragment targetFragment;</div><div class="line">    HideFragment hideFragment;</div><div class="line"></div><div class="line">    if (savedInstanceState != null) &#123;  // “内存重启”时调用</div><div class="line">        List&lt;Fragment&gt; fragmentList = getSupportFragmentManager().getFragments();</div><div class="line">        for (Fragment fragment : fragmentList) &#123;</div><div class="line">            if(fragment instanceof TartgetFragment)&#123;</div><div class="line">               targetFragment = (TargetFragment)fragment; </div><div class="line">            &#125;else if(fragment instanceof HideFragment)&#123;</div><div class="line">               hideFragment = (HideFragment)fragment;</div><div class="line">            &#125;</div><div class="line">        ｝</div><div class="line">        // 解决重叠问题</div><div class="line">        getFragmentManager().beginTransaction()</div><div class="line">                .show(targetFragment)</div><div class="line">                .hide(hideFragment)</div><div class="line">                .commit();</div><div class="line">    &#125;else&#123;  // 正常时</div><div class="line">        targetFragment = TargetFragment.newInstance();</div><div class="line">        hideFragment = HideFragment.newInstance();</div><div class="line"></div><div class="line">        // 这里add时，tag可传可不传</div><div class="line">        getFragmentManager().beginTransaction()</div><div class="line">                .add(R.id.container)</div><div class="line">                .add(R.id,container,hideFragment)</div><div class="line">                .hide(hideFragment)</div><div class="line">                .commit();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从代码看起来，这种方式比较复杂，但是这种方式在一些场景下比第一种方式更加简便有效。<br>我会在<a href="https://zilianliuxue.github.io/2016/09/06/Fragment%E5%85%A8%E8%A7%A3%E6%9E%90%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E6%AD%A3%E7%A1%AE%E7%9A%84%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF%20/">下一篇</a>中介绍在不同场景下如果选择，何时用<code>findFragmentByTag()</code>，何时用<code>getFragments()</code>恢复。</p>
<p>顺便一提，有些小伙伴会用一种并<strong>不合适</strong>的方法恢复Fragment，虽然效果也能达到，但并<strong>不恰当</strong>。即：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">// 保存</div><div class="line">@Override</div><div class="line">protected void onSaveInstanceState(Bundle outState) &#123;</div><div class="line">    super.onSaveInstanceState(outState);</div><div class="line"></div><div class="line">    getSupportFragmentManager().putFragment(outState, KEY, targetFragment);</div><div class="line">&#125;</div><div class="line">// 恢复</div><div class="line">@Override</div><div class="line">protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">    super.onCreate(savedInstanceState);</div><div class="line">    setContentView(R.layout.activity_scrolling);</div><div class="line"></div><div class="line">    if (savedInstanceState != null) &#123;</div><div class="line">        Fragment targetFragment = getSupportFragmentManager().getFragment(savedInstanceState, KEY);</div><div class="line">    &#125;</div><div class="line">｝</div></pre></td></tr></table></figure>
<p>如果仅仅为了找回栈内的Fragment，使用<code>putFragment(bundle, key, fragment)</code>保存fragment，是完全没有必要的；因为FragmentManager在任何情况都会帮你存储Fragment，你要做的仅仅是在“内存重启”后，找回这些Fragment即可。<br>。</p>
<p><strong> 3、我的解决方案，9行代码解决所有情况的Fragment重叠：传送门</strong></p>
<h1 id="Fragment嵌套的那些坑"><a href="#Fragment嵌套的那些坑" class="headerlink" title="Fragment嵌套的那些坑"></a>Fragment嵌套的那些坑</h1><p>其实一些小伙伴遇到的很多嵌套的坑，大部分都是由于对嵌套的栈视图产生混乱，只要理清栈视图关系，做好恢复相关工作以及正确选择是使用<code>getFragmentManager()</code>还是<code>getChildFragmentManager()</code>就可以避免这些问题。</p>
<p>这部分内容是我们感觉Fragment非常难用的一个点，我会在<a href="https://zilianliuxue.github.io/2016/09/06/Fragment%E5%85%A8%E8%A7%A3%E6%9E%90%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E6%AD%A3%E7%A1%AE%E7%9A%84%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF%20/">下一篇</a>中，详细介绍使用Fragment嵌套的一些技巧，以及如何清晰分析各个层级的栈视图。</p>
<p>附：startActivityForResult接收返回问题<br>在support 23.2.0以下的支持库中，对于在嵌套子Fragment的<code>startActivityForResult ()</code>，会发现无论如何都不能在<code>onActivityResult()</code>中接收到返回值，只有最顶层的父Fragment才能接收到，这是一个support v4库的一个BUG，不过在前两天发布的support 23.2.0库中，已经修复了该问题，嵌套的子Fragment也能正常接收到返回数据了! </p>
<h1 id="未必靠谱的出栈方法remove"><a href="#未必靠谱的出栈方法remove" class="headerlink" title="未必靠谱的出栈方法remove()"></a>未必靠谱的出栈方法remove()</h1><p>如果你想让某一个Fragment出栈，使用<code>remove()</code>在加入回退栈时并不靠谱。</p>
<p>如果你在add的同时将Fragment加入回退栈：addToBackStack(name)的情况下，它并不能真正将Fragment从栈内移除，如果你在2秒后（确保Fragment事务已经完成）打印<code>getSupportFragmentManager().getFragments()</code>，会发现该Fragment依然存在，并且依然可以返回到被remove的Fragment，而且是空白页面。</p>
<p>如果你没有将Fragment加入回退栈，remove方法可以正常出栈。</p>
<p>如果你加入了回退栈，<code>popBackStack()</code>系列方法才能真正出栈，这也就引入下一个深坑，<code>popBackStack(String tag,int flags)</code>等系列方法的BUG。</p>
<h1 id="多个Fragment同时出栈的那些深坑BUG"><a href="#多个Fragment同时出栈的那些深坑BUG" class="headerlink" title="多个Fragment同时出栈的那些深坑BUG"></a>多个Fragment同时出栈的那些深坑BUG</h1><p>在Fragment库中如下4个方法是有BUG的：</p>
<p>1、popBackStack(String tag,int flags)<br>2、popBackStack(int id,int flags)<br>3、popBackStackImmediate(String tag,int flags)<br>4、popBackStackImmediate(int id,int flags)</p>
<p>上面4个方法作用是，出栈到tag/id的fragment，即一次多个Fragment被出栈。</p>
<p><strong>1、FragmentManager栈中管理fragment下标位置的数组ArrayList mAvailIndeices的BUG</strong></p>
<p>下面的方法FragmentManagerImpl类方法，产生BUG的罪魁祸首是管理Fragment栈下标的<code>mAvailIndeices</code>属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">void makeActive(Fragment f) &#123;</div><div class="line">      if (f.mIndex &gt;= 0) &#123;</div><div class="line">         return;</div><div class="line">      &#125; </div><div class="line">      if (mAvailIndices == null || mAvailIndices.size() &lt;= 0) &#123;</div><div class="line">           if (mActive == null) &#123;</div><div class="line">              mActive = new ArrayList&lt;Fragment&gt;();</div><div class="line">           &#125; </div><div class="line">           f.setIndex(mActive.size(), mParent); </div><div class="line">           mActive.add(f);</div><div class="line">       &#125; else &#123;</div><div class="line">           f.setIndex(mAvailIndices.remove(mAvailIndices.size()-1), mParent);</div><div class="line">           mActive.set(f.mIndex, f);</div><div class="line">       &#125; </div><div class="line">      if (DEBUG) Log.v(TAG, &quot;Allocated fragment index &quot; + f);</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>上面代码最终导致了栈内顺序不正确的问题，如下图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/937851-8f0337f08a9d380b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p>
<p>上面的这个情况，会一次异常，一次正常。带来的问题就是“内存重启”后，各种异常甚至Crash。</p>
<p>我发现这BUG的时候，我也懵比了，幸好，stackoverflow上有大神给出了<a href="http://stackoverflow.com/questions/25520705/android-cant-retain-fragments-that-are-nested-in-other-fragments" target="_blank" rel="external">解决方案</a>！hack <code>FragmentManagerImpl</code>的<code>mAvailIndices</code>，对其进行一次<code>Collections.reverseOrder()</code>降序排序，保证栈内Fragment的index的正确。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class FragmentTransactionBugFixHack &#123;</div><div class="line"></div><div class="line">  public static void reorderIndices(FragmentManager fragmentManager) &#123;</div><div class="line">    if (!(fragmentManager instanceof FragmentManagerImpl))</div><div class="line">      return;</div><div class="line">    FragmentManagerImpl fragmentManagerImpl = (FragmentManagerImpl) fragmentManager;</div><div class="line">    if (fragmentManagerImpl.mAvailIndices != null &amp;&amp; fragmentManagerImpl.mAvailIndices.size() &gt; 1) &#123;</div><div class="line">      Collections.sort(fragmentManagerImpl.mAvailIndices, Collections.reverseOrder());</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用方法就是通过<code>popBackStackImmediate(tag/id)</code>多个Fragment后，调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">hanler.post(new Runnable()&#123;</div><div class="line">    @Override</div><div class="line">     public void run() &#123;</div><div class="line">         FragmentTransactionBugFixHack.reorderIndices(fragmentManager));</div><div class="line">     &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p><strong>2、popBackStack的坑</strong><br><code>popBackStack</code>和<code>popBackStackImmediate</code>的区别在于前者是加入到主线队列的末尾，等其它任务完成后才开始出栈，后者是立刻出栈。</p>
<p>如果你<code>popBackStack</code>多个Fragment后，紧接着<code>beginTransaction()</code> add新的一个Fragment，接着发生了“内存重启”后，你再执行<code>popBackStack()</code>，app就会Crash，解决方案是postDelay出栈动画时间再执行其它事务，但是根据我的观察不是很稳定。<br>我的建议是：如果你想出栈多个Fragment，你应尽量使用<code>popBackStackImmediate(tag/id)</code>，而不是<code>popBackStack(tag/id)</code>，如果你想在出栈后，立刻<code>beginTransaction()</code>开始一项事务，你应该把事务的代码post/postDelay到主线程的消息队列里，下一篇有详细描述。</p>
<h1 id="超级深坑-Fragment转场动画"><a href="#超级深坑-Fragment转场动画" class="headerlink" title="超级深坑 Fragment转场动画"></a>超级深坑 Fragment转场动画</h1><p>如果你的Fragment没有转场动画，或者使用<code>setCustomAnimations(enter, exit)</code>的话，那么上面的那些坑解决后，你可以愉快的玩耍了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">getFragmentManager().beginTransaction()</div><div class="line">         .setCustomAnimations(enter, exit)</div><div class="line">        // 如果你有通过tag/id同时出栈多个Fragment的情况时，</div><div class="line">        // 请谨慎使用.setCustomAnimations(enter, exit, popEnter, popExit)  </div><div class="line">        // 因为在出栈多Fragment时，伴随出栈动画，会在某些情况下发生异常</div><div class="line">        // 你需要搭配Fragment的onCreateAnimation()临时取消出栈动画，或者延迟一个动画时间再执行一次上面提到的Hack方法，排序</div></pre></td></tr></table></figure>
<p><strong>(注意：如果你想给下一个Fragment设置进栈动画和出栈动画，.setCustomAnimations(enter, exit)只能设置进栈动画，第二个参数并不是设置出栈动画；请使用.setCustomAnimations(enter, exit, popEnter, popExit)，这个方法的第1个参数对应进栈动画，第4个参数对应出栈动画，所以是.setCustomAnimations(进栈动画, exit, popEnter, 出栈动画))</strong></p>
<p>总结起来就是Fragment没有出栈动画的话，可以避免很多坑。<br>如果想让出栈动画运作正常的话，需要使用Fragment的<code>onCreateAnimation</code>中控制动画。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public Animation onCreateAnimation(int transit, boolean enter, int nextAnim) &#123;</div><div class="line">    // 此处设置动画</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但是用代价也是有的，你需要解决出栈动画带来的几个坑。</p>
<p><strong>1、pop多个Fragment时转场动画 带来的问题</strong><br>在使用 <code>pop(tag/id)</code>出栈多个Fragment的这种情况下，将转场动画临时取消或者延迟一个动画的时间再去执行其他事务；</p>
<p>原因在于这种情景下，如果发生“内存重启”后，因为Fragment转场动画没结束时再执行其他方法，会导致Fragment状态不会被FragmentManager正常保存下来。</p>
<p><strong>2、进入新的Fragment并立刻关闭当前Fragment 时的一些问题</strong><br>（1）如果你想从当前Fragment进入一个新的Fragment，并且同时要关闭当前Fragment。由于数据结构是栈，所以正确做法是先<code>pop</code>，再<code>add</code>，但是转场动画会有覆盖的不正常现象，你需要特殊处理，不然会闪屏！</p>
<p>（2）Fragment的根布局要设置<code>android:clickable = true</code>，原因是在<code>pop</code>后又立刻<code>add</code>新的Fragment时，在转场动画过程中，如果你的手速太快，在动画结束前你多点击了一下，上一个Fragment的可点击区域可能会在下一个Fragment上依然可用。</p>
<p><strong>Tip：</strong><br><strong>如果你遇到Fragment的mNextAnim空指针的异常（通常是在你的Fragment被重启的情况下），那么你首先需要检查是否操作的Fragment是否为null；其次在你的Fragment转场动画还没结束时，你是否就执行了其他事务等方法；解决思路就是延迟一个动画时间再执行事务，或者临时将该Fragment设为无动画</strong></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>看了上面的介绍，你可能会觉得Fragment有点可怕。</p>
<p>但是我想说，如果你只是浅度使用，比如一个Activity容器包含列表Fragment＋详情Fragment这种简单情景下，不涉及到<code>popBackStack/Immediate(tag/id)</code>这些的方法，还是比较轻松使用的，出现的问题，网上都可以找到解决方案。</p>
<p>但是如果你的Fragment逻辑比较复杂，有特殊需求，或者你的app架构是仅有一个Activity + 多个Fragment，上面说的这些坑，你都应该全部解决。</p>
<p>在<a href="https://zilianliuxue.github.io/2016/09/06/Fragment%E5%85%A8%E8%A7%A3%E6%9E%90%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E6%AD%A3%E7%A1%AE%E7%9A%84%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF%20/">下一篇</a>中，介绍了一些非常实用的使用技巧，包括如何解决Fragment嵌套、各种环境、组件下Fragment的使用等技巧，推荐阅读！</p>
<p>还有一些比较隐蔽的问题，不影响app的正常运行，仅仅是一些显示的BUG，并没有在上面介绍，在本系列的<a href="https://zilianliuxue.github.io/2016/09/06/Fragment%E4%B9%8B%E6%88%91%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%9AFragmentation/">最后一篇</a>，我给出了我的解决方案，一个我封装的<a href="https://github.com/YoKeyword/Fragmentation" target="_blank" rel="external">Fragmentation库</a>，解决了所有动画问题，非常适合<strong>单Activity+多Fragment</strong> 或者 <strong>多模块Activity＋多Fragment</strong>的架构。有兴趣的可以看看 :)</p>
<hr>
<p>未经许可不得转载，转载请注明zilianliuxue的blog,本人保留所有版权。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原文链接：&lt;a href=&quot;http://www.jianshu.com/p/d9143a92ad94&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.jianshu.com/p/d9143a92ad94&lt;/a&gt;&lt;br&gt;Fragment
    
    </summary>
    
      <category term="android" scheme="http://zilianliuxue.github.io/categories/android/"/>
    
    
      <category term="Fragment" scheme="http://zilianliuxue.github.io/tags/Fragment/"/>
    
  </entry>
  
  <entry>
    <title>Fragment防手抖 最佳实践</title>
    <link href="http://zilianliuxue.github.io/2016/09/06/Fragment%E9%98%B2%E6%89%8B%E6%8A%96%20%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
    <id>http://zilianliuxue.github.io/2016/09/06/Fragment防手抖 最佳实践/</id>
    <published>2016-09-06T06:25:00.000Z</published>
    <updated>2016-09-06T04:38:35.753Z</updated>
    
    <content type="html"><![CDATA[<p>原文链接：<a href="http://www.jianshu.com/p/9dbb03203fbc" target="_blank" rel="external">http://www.jianshu.com/p/9dbb03203fbc</a></p>
<p>防抖动：防止用户手抖，连续快速地点击多次同一个按钮。</p>
<h2 id="为什么需要防手抖处理？"><a href="#为什么需要防手抖处理？" class="headerlink" title="为什么需要防手抖处理？"></a>为什么需要防手抖处理？</h2><p>在Fragment(v4)之间的跳转过程中，下面两种情况会导致用户体验不佳：（以AFragment 跳转 BFragment为例）</p>
<p>1、BFragment还没真正创建时（因为Fragment事务并不是立即开始的），你手抖点了2下，就会一次性启动2个BFragment；</p>
<p>2、在跳转BFragment过程中，如果有转场动画的存在，在动画结束前的任意时间，你点击了BFragment页面中可点击的区域，就会触发该点击区域的事件。</p>
<p>不做任何防手抖处理的话，你可能遭遇下面GIF的情况：</p>
<p>无防手抖处理</p>
<p>所以对Fragment进行防手抖处理还是很有必要的，RxJava系列的Rxbinding包可以帮你解决该问题，debounce操作符可以实现防手抖，但很多情况，你会使用RxJava但不想使用Rxbinding。</p>
<p>其实不管哪种方案，我想你都不会愿意在每个点击事件里都手动处理一次防抖动问题。</p>
<p>我们需要一个封装的基类，可以解决防抖动问题，而不必在每个启动Fragment的按钮都进行防抖动处理。</p>
<h2 id="常见方案"><a href="#常见方案" class="headerlink" title="常见方案"></a>常见方案</h2><p>有1种常见的防手抖处理方式：<strong>通过时间差</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">private static final long DEBOUNCE_TIME = 300L;</div><div class="line">private long mCurrentTime;</div><div class="line"></div><div class="line">private void addFragment(Fragment fragment) &#123;</div><div class="line">    long time = System.currentTimeMillis();</div><div class="line">    if (time - mCurrentTime &lt; DEBOUNCE_TIME) &#123;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    mCurrentTime = time;</div><div class="line"></div><div class="line">    getSupportFragmentManager().beginTransaction()</div><div class="line">            .add(R.id.fl_container, fragment, fragment.getClass().getSimpleName())  // replace亦一样</div><div class="line">            ....省略设置动画 加入回退栈等</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这种方式虽然也能实现防抖动的效果，但是适用性有限；<br>比如如果我需要add一个Fragment，然后紧接着该Fragment又立即需要add一个子Fragment，这时add子Fragment的操作可能就会被这个时间差屏蔽掉。</p>
<h2 id="我的方案"><a href="#我的方案" class="headerlink" title="我的方案"></a>我的方案</h2><p>鉴于上述方法的拘束性，再结合Fragment的宿主是Activity，我有了下面的方案：<br>利用Activity的<code>dispatchTouchEvent(MotionEvent ev)</code>方法。</p>
<p><strong>大致思路是，在点击后立即让Activity拦截一切Touch事件，在目标Fragment的转场动画结束后（如果是无转场动画，则是在onActivityCreated被调用后），再让Activity取消拦截。</strong></p>
<p>接下来我们就看看具体如何实现吧！</p>
<h5 id="在BaseActivity中"><a href="#在BaseActivity中" class="headerlink" title="在BaseActivity中:"></a>在BaseActivity中:</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">public class BaseActivity extends AppCompatActivity &#123;</div><div class="line"></div><div class="line">    private boolean mAllowClickable = true;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public boolean dispatchTouchEvent(MotionEvent event)&#123;</div><div class="line">        // 防抖动(防止点击速度过快)</div><div class="line">        if (!mFragmentClickable) &#123;</div><div class="line">            return true;</div><div class="line">        &#125;</div><div class="line">        return super.dispatchTouchEvent(ev);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     *  控制Activity是否拦截Touch事件</div><div class="line">     */</div><div class="line">    public void allowFragmentClickable(boolean clickable)&#123;</div><div class="line">        mAllowClickable = clickable;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     *  加载Fragment (replace同理)</div><div class="line">     */</div><div class="line">    private void addFragment(Fragment fragment) &#123;</div><div class="line">        // 启动Fragment时，Activity拦截一切Touch事件</div><div class="line">        allowFragmentClickable(false);</div><div class="line"></div><div class="line">        getSupportFragmentManager().beginTransaction()</div><div class="line">                .add(R.id.fl_container, fragment, fragment.getClass().getSimpleName())  // replace亦一样</div><div class="line">        ....省略设置动画 加入回退栈等</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onBackPressed() &#123;</div><div class="line">        // 这里是防止动画过程中，按返回键取消加载Fragment</div><div class="line">        if(!mAllowClickable)&#123;</div><div class="line">            setFragmentClickable(true);</div><div class="line">        &#125;</div><div class="line">        super.onBackPressed();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>所有Activity中的Touch事件，首先都需要经过Activity的<code>dispatchTouchEvent</code>方法，该方法通过Window分发Touch事件，如果返回true，则不再往下层分发，这时我们布局内的任何Touch事件都会“无效”。</p>
<p>在通过Activity来加载Fragment时，将mAllowClickable设为false，此时只到为true时，屏幕的Touch事件将都无效。</p>
<h5 id="在BaseFragment中："><a href="#在BaseFragment中：" class="headerlink" title="在BaseFragment中："></a>在BaseFragment中：</h5><p>这里将<strong>有转场动画</strong>和<strong>无转场动画</strong>两种情况都进行了防手抖处理：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">public class BaseFragment extends Fragment &#123;</div><div class="line">    // 记录是否有转场动画</div><div class="line">    private boolean mEnterAnimFlag = false;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public Animation onCreateAnimation(int transit, boolean enter, int nextAnim) &#123;</div><div class="line">        if (enter &amp;&amp; nextAnim != 0) &#123;</div><div class="line">            // 记录 有转场动画</div><div class="line">            mEnterAnimFlag = true;</div><div class="line"></div><div class="line">            Animation anim = AnimationUtils.loadAnimation(mActivity, nextAnim);</div><div class="line">            mNoAnim.setAnimationListener(new Animation.AnimationListener() &#123;</div><div class="line">                ...省略</div><div class="line">                @Override</div><div class="line">                public void onAnimationEnd(Animation animation) &#123;</div><div class="line">                    // 转场动画结束时，允许Touch事件</div><div class="line">                    mActivity.allowFragmentClickable(true);</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">        &#125;</div><div class="line">        return super.onCreateAnimation(transit, enter, nextAnim);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onActivityCreated(@Nullable Bundle savedInstanceState) &#123;</div><div class="line">        super.onActivityCreated(savedInstanceState);</div><div class="line">        // 无转场动画时 处理</div><div class="line">        if(!mEnterAnimFlag) &#123;</div><div class="line">            mActivity.allowFragmentClickable(true);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在Fragment初始化时，其生命周期顺序：<br>… -&gt; onCreateView -&gt; onCreateAnimation -&gt; onActivityCreated</p>
<p>由此生命周期，再结合代码上的注释，相信你一看就懂了～</p>
<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>最终，利用Android的事件分发机制，使用不到50行代码就完美解决了Fragment的防手抖处理。<br>最后看下效果：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/937851-caf287a92b4a81d2.gif?imageMogr2/auto-orient/strip" alt=""></p>
<p>防手抖</p>
<blockquote>
<p>想查看更多Fragment优化细节或者深度使用Fragment的小伙伴，建议看看我的这个<a href="https://github.com/YoKeyword/Fragmentation" target="_blank" rel="external">Fragmentation</a>库</p>
</blockquote>
<hr>
<p>未经许可不得转载，转载请注明zilianliuxue的blog,本人保留所有版权。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原文链接：&lt;a href=&quot;http://www.jianshu.com/p/9dbb03203fbc&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.jianshu.com/p/9dbb03203fbc&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;防抖动：
    
    </summary>
    
      <category term="android" scheme="http://zilianliuxue.github.io/categories/android/"/>
    
    
      <category term="Fragment" scheme="http://zilianliuxue.github.io/tags/Fragment/"/>
    
  </entry>
  
  <entry>
    <title>9行代码让你app内的Fragment对重叠说再见</title>
    <link href="http://zilianliuxue.github.io/2016/09/06/9%E8%A1%8C%E4%BB%A3%E7%A0%81%E8%AE%A9%E4%BD%A0App%E5%86%85%E7%9A%84Fragment%E5%AF%B9%E9%87%8D%E5%8F%A0%E8%AF%B4%E5%86%8D%E8%A7%81/"/>
    <id>http://zilianliuxue.github.io/2016/09/06/9行代码让你App内的Fragment对重叠说再见/</id>
    <published>2016-09-06T05:25:00.000Z</published>
    <updated>2016-09-06T04:52:28.689Z</updated>
    
    <content type="html"><![CDATA[<p>原文链接：<a href="http://www.jianshu.com/p/c12a98a36b2b" target="_blank" rel="external">http://www.jianshu.com/p/c12a98a36b2b</a></p>
<p>在上一篇<a href="https://zilianliuxue.github.io/2016/09/06/%E4%BB%8E%E6%BA%90%E7%A0%81%E8%A7%92%E5%BA%A6%E5%88%86%E6%9E%90%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%8F%91%E7%94%9FFragment%E9%87%8D%E5%8F%A0%EF%BC%9F/">从源码角度分析，为什么会发生Fragment重叠？</a>里，我们分析了造成Fragment重叠的原因，这一篇我会介绍几个解决方案，同时给出一个<strong>我的方案：9行代码让你app内的Fragment对重叠说再见！</strong></p>
<h2 id="通过findFragmentByTag-amp-getFragments-的解决方案"><a href="#通过findFragmentByTag-amp-getFragments-的解决方案" class="headerlink" title="通过findFragmentByTag() &amp; getFragments()的解决方案"></a>通过findFragmentByTag() &amp; getFragments()的解决方案</h2><p>这两种方案在我这篇简书<a href="https://zilianliuxue.github.io/2016/09/06/Fragment%E5%85%A8%E8%A7%A3%E6%9E%90%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E9%82%A3%E4%BA%9B%E5%B9%B4%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91/">Fragment全解析系列（一）：那些年踩过的坑</a>里有比较详细的介绍，可以自行查看，这里不多做介绍，这两种方案也是最常见的解决方案。</p>
<p><strong>缺点：</strong></p>
<ul>
<li><strong>使用比较麻烦，代码量较多；</strong></li>
<li><strong>在Fragment嵌套的场景下，恢复会有问题，原因在于：页面重启后，在父Fragment没有初始化完成前，getChildFragmentManager()子栈内的子Fragment是空，只有父Fragment初始化完成后，子栈内的子Fragment才能正确获取到。</strong></li>
</ul>
<h2 id="从源码角度想到的解决方案：自己保存Fragment的Hidden状态"><a href="#从源码角度想到的解决方案：自己保存Fragment的Hidden状态" class="headerlink" title="从源码角度想到的解决方案：自己保存Fragment的Hidden状态"></a>从源码角度想到的解决方案：自己保存Fragment的Hidden状态</h2><p>下面这个方案，是我在完善<a href="https://github.com/YoKeyword/Fragmentation" target="_blank" rel="external">Fragmentation库</a>时想到的方案。</p>
<blockquote>
<p>Fragmentation库前几天push了改变重大的0.7版本，应该算是比较成熟了，如果你重度使用Fragment或者想使用单Activity+多Fragment的组件架构的话，强烈推荐看看；对于各种复杂嵌套、同级Fragment的使用场景，你不必担心Fragment的重叠，同时大大简化Fragment的嵌套逻辑。</p>
</blockquote>
<p>在<a href="https://zilianliuxue.github.io/2016/09/06/%E4%BB%8E%E6%BA%90%E7%A0%81%E8%A7%92%E5%BA%A6%E5%88%86%E6%9E%90%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%8F%91%E7%94%9FFragment%E9%87%8D%E5%8F%A0%EF%BC%9F/">上一篇</a>分析中，我们知道了发生Fragment重叠的根本原因在于FragmentState没有保存Fragment的显示状态，即<code>mHidden</code>，导致页面重启后，该值为默认的false，即show状态，所以导致了Fragment的重叠。</p>
<p>根据这个原因，我想到我们手动维护一个<code>mSupportHidden</code>不就行了吗？<br>看下面的基类Fragment代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">public class BaseFragment extends Fragment &#123;</div><div class="line">    private static final String STATE_SAVE_IS_HIDDEN = &quot;STATE_SAVE_IS_HIDDEN&quot;;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onCreate(@Nullable Bundle savedInstanceState) &#123;</div><div class="line">    ...</div><div class="line">    if (savedInstanceState != null) &#123;</div><div class="line">        boolean isSupportHidden = savedInstanceState.getBoolean(STATE_SAVE_IS_HIDDEN);</div><div class="line"></div><div class="line">        FragmentTransaction ft = getFragmentManager().beginTransaction();</div><div class="line">        if (isSupportHidden) &#123;</div><div class="line">            ft.hide(this);</div><div class="line">        &#125; else &#123;</div><div class="line">            ft.show(this);</div><div class="line">        &#125;</div><div class="line">        ft.commit();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onSaveInstanceState(Bundle outState) &#123;</div><div class="line">        ...</div><div class="line">        outState.putBoolean(STATE_SAVE_IS_HIDDEN, isHidden());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>是的你没看错，只要上面的9行代码！ FragmentState没帮我们保存Hidden状态，那就我们自己来保存，在页面重启后，我们自己来决定Fragment是否显示！<br>解决思路转变了，由Activity/父Fragment来管理子Fragment的Hidden状态转变为 <strong>由Fragment自己来管理自己的Hidden状态</strong>！</p>
<p>优点：不管多深的嵌套Fragment、同级Fragment等场景，全都可以正常工作，不会发生重叠！<br>缺点：暂时没有发现。</p>
<p><strong>补充：</strong><br>有些小伙伴反应还是会重叠，其实是因为加载<strong>根Fragment</strong>时没有经过判断的原因，当在类似<code>onCreate</code>等初始化生命周期里加载根Fragment（即第一个Fragment）时，需要下面的判断，避免重复加载相同的Fragment：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public class MainActivity ... &#123;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onCreate(@Nullable Bundle savedInstanceState) &#123;</div><div class="line">        ...</div><div class="line">        // 这里一定要在save为null时才加载Fragment，Fragment中onCreateView等生命周里加载根子Fragment同理</div><div class="line">        // 因为在页面重启时，Fragment会被保存恢复，而此时再加载Fragment会重复加载，导致重叠</div><div class="line">        if(saveInstanceState == null)&#123;</div><div class="line">              // 这里加载根Fragment</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>最后的方案用在了我的<a href="https://github.com/YoKeyword/Fragmentation" target="_blank" rel="external">Fragmentation库</a>中，在新的仿知乎的Demo里，各种复杂场景表现完美。</p>
<p>但是这个方案真的神奇的不可思议，在我的测试下，各种情况都正常适用，但是之前从没看到有人提到过该方案，所以如果你发现该方案有我没有考虑到的BUG，请第一时间告诉我！</p>
<p>最后是一点心得体会：<br>当遇到问题时，我们如果从源头思考：为什么会发生这个问题？ 从源码角度分析问题，可能就会得到一个更好的解决问题的思路！</p>
<hr>
<p>未经许可不得转载，转载请注明zilianliuxue的blog,本人保留所有版权。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原文链接：&lt;a href=&quot;http://www.jianshu.com/p/c12a98a36b2b&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.jianshu.com/p/c12a98a36b2b&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在上一篇
    
    </summary>
    
      <category term="android" scheme="http://zilianliuxue.github.io/categories/android/"/>
    
    
      <category term="Fragment" scheme="http://zilianliuxue.github.io/tags/Fragment/"/>
    
  </entry>
  
  <entry>
    <title>从源码角度分析，为什么发生页面重启后会导致重叠？</title>
    <link href="http://zilianliuxue.github.io/2016/09/06/%E4%BB%8E%E6%BA%90%E7%A0%81%E8%A7%92%E5%BA%A6%E5%88%86%E6%9E%90%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%8F%91%E7%94%9FFragment%E9%87%8D%E5%8F%A0%EF%BC%9F/"/>
    <id>http://zilianliuxue.github.io/2016/09/06/从源码角度分析，为什么会发生Fragment重叠？/</id>
    <published>2016-09-06T03:20:00.000Z</published>
    <updated>2016-09-06T04:48:40.741Z</updated>
    
    <content type="html"><![CDATA[<p>原文链接：<a href="http://www.jianshu.com/p/78ec81b42f92" target="_blank" rel="external">http://www.jianshu.com/p/78ec81b42f92</a></p>
<p>我们在使用Fragment的过程中，有时会发现一直表现正常的Fragment，突然重叠了！</p>
<h2 id="什么情况下会发生Fragment重叠？"><a href="#什么情况下会发生Fragment重叠？" class="headerlink" title="什么情况下会发生Fragment重叠？"></a>什么情况下会发生Fragment重叠？</h2><p>一般满足下面2个条件才可能会发生重叠：</p>
<p>1、发生了页面重启（旋转屏幕、内存不足等情况被强杀重启）。<br>2、重复<code>replace</code>｜<code>add</code> Fragment 或者 使用<code>show</code> , <code>hide</code>控制Fragment；</p>
<h2 id="为什么会发生Fragment重叠？"><a href="#为什么会发生Fragment重叠？" class="headerlink" title="为什么会发生Fragment重叠？"></a>为什么会发生Fragment重叠？</h2><h5 id="从源码角度分析，为什么发生页面重启后会导致重叠？（在以add方式加载Fragment的时候）"><a href="#从源码角度分析，为什么发生页面重启后会导致重叠？（在以add方式加载Fragment的时候）" class="headerlink" title="从源码角度分析，为什么发生页面重启后会导致重叠？（在以add方式加载Fragment的时候）"></a>从源码角度分析，为什么发生页面重启后会导致重叠？（在以add方式加载Fragment的时候）</h5><p>我们知道Activity中有个<code>onSaveInstanceState()</code>方法，该方法在app进入后台、屏幕旋转前、跳转下一个Activity等情况下会被调用，此时系统帮我们保存一个Bundle类型的数据，我们可以根据自己的需求，手动保存一些例如播放进度等数据，而后如果发生了页面重启，我们可以在<code>onRestoreInstanceState()</code>或<code>onCreate()</code>里get该数据，从而恢复播放进度等状态。</p>
<p> 而产生Fragment重叠的原因就与这个保存状态的机制有关，<strong>大致原因就是系统在页面重启前，帮我们保存了Fragment的状态，但是在重启后恢复时，视图的可见状态没帮我们保存，而Fragment默认的是show状态，所以产生了Fragment重叠现象。</strong></p>
<p> <strong>分析：</strong><br> 我们先看FragmentActivity的相关源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">public class FragmentActivity extends ... &#123;</div><div class="line">    final FragmentController mFragments = FragmentController.createController(new HostCallbacks());</div><div class="line"></div><div class="line">    protected void onCreate(@Nullable Bundle savedInstanceState) &#123;</div><div class="line">        ...省略</div><div class="line">        if (savedInstanceState != null) &#123;</div><div class="line">            Parcelable p = savedInstanceState.getParcelable(FRAGMENTS_TAG);</div><div class="line">            mFragments.restoreAllState(p, nc != null ? nc.fragments : null);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onSaveInstanceState(Bundle outState) &#123;</div><div class="line">        super.onSaveInstanceState(outState);</div><div class="line">        Parcelable p = mFragments.saveAllState();</div><div class="line">        ...省略</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从上面源码可以看出，FragmentActivity确实是帮我们保存了Fragment的状态，并且在页面重启后会帮我们恢复！</p>
<p>其中的<code>mFragments</code>是FragmentController，它是一个Controller，内部通过FragmentHostCallback间接控制FragmentManagerImpl。<br>相关代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public class FragmentController &#123;</div><div class="line">    private final FragmentHostCallback&lt;?&gt; mHost;</div><div class="line"></div><div class="line">    public Parcelable saveAllState() &#123;</div><div class="line">        return mHost.mFragmentManager.saveAllState();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void restoreAllState(Parcelable state, List&lt;Fragment&gt; nonConfigList) &#123;</div><div class="line">        mHost.mFragmentManager.restoreAllState(state, nonConfigList);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public abstract class FragmentHostCallback&lt;E&gt; extends FragmentContainer &#123;</div><div class="line">    final FragmentManagerImpl mFragmentManager = new FragmentManagerImpl();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过上面代码可以看出FragmentController通过FragmentHostCallback里的FragmentManagerImpl对象来控制恢复工作。</p>
<p>我们接着看FragmentManagerImpl到底做了什么：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">final class FragmentManagerImpl extends FragmentManager &#123;</div><div class="line">    Parcelable saveAllState() &#123;</div><div class="line">        ...省略 详细保存过程</div><div class="line">        FragmentManagerState fms = new FragmentManagerState();</div><div class="line">        fms.mActive = active;</div><div class="line">        fms.mAdded = added;</div><div class="line">        fms.mBackStack = backStack;</div><div class="line">        return fms;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    void restoreAllState(Parcelable state, List&lt;Fragment&gt; nonConfig) &#123;</div><div class="line">        // 恢复核心代码</div><div class="line">        FragmentManagerState fms = (FragmentManagerState)state;</div><div class="line">        FragmentState fs = fms.mActive[i];</div><div class="line">        if (fs != null) &#123;</div><div class="line">            Fragment f = fs.instantiate(mHost, mParent);</div><div class="line">        ｝</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们通过<code>saveAllState()</code>看到了关键的保存代码，原来是是通过FragmentManagerState来保存Fragment的状态、所处Fragment栈下标、回退栈状态等。</p>
<p>而在<code>restoreAllState()</code>恢复时，通过FragmentManagerState里的FragmentState的<code>instantiate()</code>方法恢复了Fragment（见下面的分析就明白啦）</p>
<p>我们看下FragmentManagerState：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">final class FragmentManagerState implements Parcelable &#123;</div><div class="line">    FragmentState[] mActive;           // Fragment状态</div><div class="line">    int[] mAdded;                      // 所处Fragment栈下标</div><div class="line">    BackStackState[] mBackStack;       // 回退栈状态</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们只看FragmentState，它也实现了Parcelable，保存了Fragment的类名、下标、id、Tag、ContainerId以及Arguments等数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">final class FragmentState implements Parcelable &#123;</div><div class="line">    final String mClassName;</div><div class="line">    final int mIndex;</div><div class="line">    final boolean mFromLayout;</div><div class="line">    final int mFragmentId;</div><div class="line">    final int mContainerId;</div><div class="line">    final String mTag;</div><div class="line">    final boolean mRetainInstance;</div><div class="line">    final boolean mDetached;</div><div class="line">    final Bundle mArguments;</div><div class="line">    ...</div><div class="line"></div><div class="line">    //  在FragmentManagerImpl的restoreAllState()里被调用</div><div class="line">    public Fragment instantiate(FragmentHostCallback host, Fragment parent) &#123;</div><div class="line">        ...省略</div><div class="line">        mInstance = Fragment.instantiate(context, mClassName, mArguments);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>至此，我们就明白了系统帮我们保存的Fragment其实最终是以FragmentState形式存在的。</p>
<p>此时我们再思考下<strong>为什么在页面重启后会发生Fragment的重叠？ 其实答案已经很明显了，根据上面的源码分析，我们会发现FragmentState里没有Hidden状态的字段！</strong></p>
<p>而Hidden状态对应Fragment中的<code>mHidden</code>，该值默认false…</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public class Fragment ... &#123;</div><div class="line">    boolean mHidden;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我想你应该明白了，在以add方式加载Fragment的场景下，系统在恢复Fragment时，<code>mHidden＝false</code>，即show状态，这样在页面重启后，Activity内的Fragment都是以show状态显示的，而如果你不进行处理，那么就会发生Fragment重叠现象！</p>
<h5 id="为什么重复replace-add-Fragment-或者-使用show-hide控制Fragment会导致重叠？"><a href="#为什么重复replace-add-Fragment-或者-使用show-hide控制Fragment会导致重叠？" class="headerlink" title="为什么重复replace|add Fragment 或者 使用show , hide控制Fragment会导致重叠？"></a>为什么重复<code>replace</code>|<code>add</code> Fragment 或者 使用<code>show</code> , <code>hide</code>控制Fragment会导致重叠？</h5><ul>
<li><p><strong>重复replace|add Fragment </strong><br>我们知道加载Fragment有2种方式：<code>replace()</code>和<code>add()</code>。<br>不管哪种方式，重复加载Fragment都会导致重叠，这个很好理解，你加载同一个Fragment2次当然会重叠了；问题是我们在哪里重复加载了Fragment？<br>一般情况下，我们会在Activity的<code>onCreate()</code>里或者Fragment的<code>onCreateView()</code>里加载根Fragment，如果在这里没有进行页面重启的判断的话，就可能导致重复加载Fragment引起重叠，正确的写法应该是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">  protected void onCreate(@Nullable Bundle savedInstanceState) &#123;</div><div class="line">      ...</div><div class="line">      // 判空， Fragment同理</div><div class="line">      if(saveInstanceState == null)&#123;</div><div class="line">            // 这里replace或add 根Fragment</div><div class="line">      &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>这里一定要在<code>saveInstanceState==null</code>时才加载Fragment，因为经过上面的分析，在页面重启时，Fragment的状态会被保存恢复，而此时再加载Fragment会重复加载，就导致栈已经有该Fragment的情况下，再加载一该Fragment，从而导致重叠！</p>
</li>
<li><p><strong>使用show , hide控制Fragment</strong><br>我们使用<code>show()</code>,<code>hide()</code>时，都是使用<code>add</code>的方式加载Fragment的，add配合hide使Fragment的视图改变为GONE状态；而replace是销毁Fragment 的视图。<br>页面重启时，add的Fragment会全部走生命周期，创建视图；而replace的非栈顶Fragment不会走生命周期，只有Back时，才会逐一走栈顶Fragment生命周期，创建视图。</p>
<p>结合上面的源码分析，在使用replace加载Fragment时，页面重启后，Fragment视图都还没创建，所以<code>mHidden</code>没有意义，不会发生重叠现象；<br>而在使用add加载时，视图是存在的并且叠加在一起，页面重启后 <code>mHidden=false</code>，所有的Fragment都会是show状态显示出来（即VISIBLE），从而造成了Fragment重叠！</p>
</li>
</ul>
<h2 id="最后-amp-解决方案"><a href="#最后-amp-解决方案" class="headerlink" title="最后&amp;解决方案"></a>最后&amp;解决方案</h2><p>通过上面的分析，我想小伙伴们应该彻底明白Fragment重叠的原因了吧！</p>
<p>鉴于篇幅原因，我另写了一篇简书来谈谈 Fragment重叠的解决方案，同时会给出我通过分析源码想到的一个解决方案，下一篇<a href="https://zilianliuxue.github.io/2016/09/06/9%E8%A1%8C%E4%BB%A3%E7%A0%81%E8%AE%A9%E4%BD%A0App%E5%86%85%E7%9A%84Fragment%E5%AF%B9%E9%87%8D%E5%8F%A0%E8%AF%B4%E5%86%8D%E8%A7%81/">解决方案的传送门</a></p>
<hr>
<p>未经许可不得转载，转载请注明zilianliuxue的blog,本人保留所有版权。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原文链接：&lt;a href=&quot;http://www.jianshu.com/p/78ec81b42f92&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.jianshu.com/p/78ec81b42f92&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我们在使
    
    </summary>
    
      <category term="android" scheme="http://zilianliuxue.github.io/categories/android/"/>
    
    
      <category term="Fragment" scheme="http://zilianliuxue.github.io/tags/Fragment/"/>
    
  </entry>
  
  <entry>
    <title>简单实现图片三级缓存</title>
    <link href="http://zilianliuxue.github.io/2016/09/03/%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98/"/>
    <id>http://zilianliuxue.github.io/2016/09/03/简单实现图片三级缓存/</id>
    <published>2016-09-03T05:25:00.000Z</published>
    <updated>2016-09-03T05:30:35.548Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>现在的Android应用程序中，不可避免的都会使用到图片，如果每次加载图片的时候都要从网络重新拉取，这样不但很耗费用户的流量，而且图片加载的也会很慢，用户体验很不好。所以一个应用的图片缓存策略是很重要的。通常情况下，Android应用程序中图片的缓存策略采用“内存-本地-网络”三级缓存策略。</p>
<p>​       当然现在处理网络图片的时候，一般人都会选择UIL或Glide，它已经将网络缓存处理的相当好了，并且glide还能加载gif，面试的时候通常也会问到图片缓存是怎么做的，这里就来简单实现这个功能。</p>
<h2 id="什么是三级缓存"><a href="#什么是三级缓存" class="headerlink" title="什么是三级缓存"></a>什么是三级缓存</h2><ul>
<li>网络缓存, 不优先加载, 速度慢,浪费流量</li>
</ul>
<ul>
<li>本地缓存, 次优先加载, 速度快</li>
</ul>
<ul>
<li>内存缓存, 优先加载, 速度最快</li>
</ul>
<hr>
<h2 id="三级缓存原理"><a href="#三级缓存原理" class="headerlink" title="三级缓存原理"></a>三级缓存原理</h2><ul>
<li><p>首次加载 Android App 时，肯定要通过网络交互来获取图片，之后我们可以将图片保存至本地SD卡和内存中</p>
</li>
<li><p>之后运行 App 时，优先访问内存中的图片缓存，若内存中没有，则加载本地SD卡中的图片</p>
</li>
<li><p>总之，只在初次访问新内容时，才通过网络获取图片资源</p>
<p>​</p>
</li>
</ul>
<p>  <img src="http://i.imgur.com/WBX1gFQ.png" alt=""></p>
<h2 id=""><a href="#" class="headerlink" title=" "></a> </h2><h4 id="内存缓存（MemoryCache）"><a href="#内存缓存（MemoryCache）" class="headerlink" title="内存缓存（MemoryCache）"></a>内存缓存（MemoryCache）</h4><p>  内存缓存说白了就是在内存中保存一份图片集合，首先会想到HashMap这种键值对的形式来进行保存，以url作为key,bitmap作为value。</p>
<ul>
<li>通过 <code>HashMap</code>键值对的方式保存图片，key为地址，value为图片对象，但因是强引用对象，很容易造成内存溢出，可以尝试SoftReference软引用对象</li>
</ul>
<ul>
<li>通过 <code>HashMap&gt;</code>SoftReference 为软引用对象（GC垃圾回收会自动回收软引用对象），但在Android2.3+后，系统会优先考虑回收弱引用对象，官方提出使用LruCache</li>
</ul>
<ul>
<li><p>通过 <code>LruCache</code> least recentlly use 最少最近使用算法</p>
<p>会将内存控制在一定的大小内, 超出最大值时会自动回收, 这个最大值开发者自己定</p>
<p>所以呢这里使用LruCache来进行：</p>
<p>这个类非常适合用来缓存图片，它的主要算法原理是把最近使用的对象用强引用存储在 LinkedHashMap 中，并且把最近最少使用的对象在缓存值达到预设定值之前从内存中移除。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.losileeya.imageloader.ImageLoder;</div><div class="line"></div><div class="line"><span class="keyword">import</span> android.graphics.Bitmap;</div><div class="line"><span class="keyword">import</span> android.util.LruCache;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * User: Losileeya (847457332@qq.com)</div><div class="line"> * Date: 2016-08-31</div><div class="line"> * Time: 11:08</div><div class="line"> * 类描述：内存缓存</div><div class="line"> *</div><div class="line"> * <span class="doctag">@version</span> :</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MemoryCache</span> </span>&#123;</div><div class="line">    <span class="comment">// private HashMap&lt;String,Bitmap&gt; mMemoryCache=new HashMap&lt;&gt;();//1.因为强引用,容易造成内存溢出，所以考虑使用下面弱引用的方法</span></div><div class="line">    <span class="comment">// private HashMap&lt;String, SoftReference&lt;Bitmap&gt;&gt; mMemoryCache = new HashMap&lt;&gt;();//2.因为在Android2.3+后,系统会优先考虑回收弱引用对象,官方提出使用LruCache</span></div><div class="line">    <span class="keyword">private</span> LruCache &lt;String,Bitmap&gt; mMemoryCache=<span class="keyword">null</span>;</div><div class="line">    <span class="function"><span class="keyword">public</span>  <span class="title">MemoryCache</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">long</span> mCurrentMemory  = Runtime.getRuntime().maxMemory();<span class="comment">//得到手机最大允许内存</span></div><div class="line">        <span class="keyword">long</span> maxSize=mCurrentMemory/<span class="number">8</span>;<span class="comment">//得到手机最大允许内存的1/8,即超过指定内存,则开始回收</span></div><div class="line">        mMemoryCache=<span class="keyword">new</span> LruCache&lt;String,Bitmap&gt;((<span class="keyword">int</span>)maxSize)&#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">sizeOf</span><span class="params">(String key, Bitmap value)</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span>  value.getRowBytes()*value.getHeight();</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 从内存中读图片</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> key</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> Bitmap <span class="title">getBitmapFormMemory</span><span class="params">(String key)</span></span>&#123;</div><div class="line">        <span class="comment">//Bitmap bitmap = mMemoryCache.get(url);//1.强引用方法</span></div><div class="line">        <span class="comment">/*2.弱引用方法</span></div><div class="line">        SoftReference&lt;Bitmap&gt; bitmapSoftReference = mMemoryCache.get(url);</div><div class="line">        if (bitmapSoftReference != null) &#123;</div><div class="line">            Bitmap bitmap = bitmapSoftReference.get();</div><div class="line">            return bitmap;</div><div class="line">        &#125;</div><div class="line">        */</div><div class="line">        Bitmap bitmap=mMemoryCache.get(key);</div><div class="line">        <span class="keyword">return</span>  bitmap;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 往内存中写图片</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> key</div><div class="line">     * <span class="doctag">@param</span> bitmap</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putBitmapToMemory</span><span class="params">(String key,Bitmap bitmap)</span></span>&#123;</div><div class="line">        <span class="comment">//mMemoryCache.put(url, bitmap);//1.强引用方法</span></div><div class="line">        <span class="comment">/*2.弱引用方法</span></div><div class="line">        mMemoryCache.put(url, new SoftReference&lt;&gt;(bitmap));</div><div class="line">        */</div><div class="line">        mMemoryCache.put(key,bitmap);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="本地缓存（保存到文件LocalCache）"><a href="#本地缓存（保存到文件LocalCache）" class="headerlink" title="本地缓存（保存到文件LocalCache）"></a>本地缓存（保存到文件LocalCache）</h4><p>从网络加载完图片之后，将图片保存到本地SD卡中。在加载图片的时候，判断一下SD卡中是否有图片缓存，如果有，就直接从SD卡加载图片。本地缓存的工具类中有两个公共的方法，分别是向本地SD卡设置网络图片，获取SD卡中的图片。设置图片的时候采用键值对的形式进行存储，将图片的url作为键，作为文件的名字，图片的Bitmap作位值来保存。由于url含有特殊字符，不能直接作为图片的名字来存储，故采用url的MD5值作为文件的名字。</p>
</li>
</ul>
<ul>
<li><p>在初次通过网络获取图片后，我们可以在本地SD卡中将图片保存起来</p>
</li>
<li><p>可以使用MD5加密图片的网络地址，来作为图片的名称保存</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.losileeya.imageloader.ImageLoder;</div><div class="line"></div><div class="line"><span class="keyword">import</span> android.graphics.Bitmap;</div><div class="line"><span class="keyword">import</span> android.graphics.BitmapFactory;</div><div class="line"><span class="keyword">import</span> android.os.Environment;</div><div class="line"></div><div class="line"><span class="keyword">import</span> com.losileeya.imageloader.utils.Md5Encoder;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.File;</div><div class="line"><span class="keyword">import</span> java.io.FileInputStream;</div><div class="line"><span class="keyword">import</span> java.io.FileOutputStream;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * User: Losileeya (847457332@qq.com)</div><div class="line"> * Date: 2016-08-31</div><div class="line"> * Time: 10:49</div><div class="line"> * 类描述：把bitmap保存到sd卡</div><div class="line"> *</div><div class="line"> * <span class="doctag">@version</span> :</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalCache</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 文件保存的路径</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span>  <span class="keyword">static</span>  <span class="keyword">final</span>  String CACHE_PATH= Environment.getExternalStorageDirectory().getAbsolutePath()+<span class="string">"/LosileeyaLocalCache"</span>;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 向本地SD卡写网络图片</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> url</div><div class="line">     * <span class="doctag">@param</span> bitmap</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBitmapToLocal</span><span class="params">(String url, Bitmap bitmap)</span></span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            String fileName=  Md5Encoder.encode(url);<span class="comment">// 文件的名字</span></div><div class="line">            File file=<span class="keyword">new</span> File(CACHE_PATH,fileName);<span class="comment">// 创建文件流，指向该路径，文件名叫做fileName</span></div><div class="line">            <span class="comment">//通过得到文件的父文件,判断父文件是否存在</span></div><div class="line">            File parentFile = file.getParentFile();</div><div class="line">            <span class="keyword">if</span> (!parentFile.exists())&#123;<span class="comment">// 文件夹不存在</span></div><div class="line">                parentFile.mkdirs();<span class="comment">// 创建文件夹</span></div><div class="line">            &#125;</div><div class="line">            <span class="comment">//把图片保存至本地</span></div><div class="line">            bitmap.compress(Bitmap.CompressFormat.JPEG,<span class="number">100</span>,<span class="keyword">new</span> FileOutputStream(file));</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 从本地SD卡获取网络图片，key是url的MD5值</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> url</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> Bitmap <span class="title">getBitampFormLocal</span><span class="params">(String url)</span></span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            String fileName = Md5Encoder.encode(url);<span class="comment">//把图片的url当做文件名,并进行MD5加密</span></div><div class="line">            File file=<span class="keyword">new</span> File(CACHE_PATH,fileName);</div><div class="line">            Bitmap bitmap= BitmapFactory.decodeStream(<span class="keyword">new</span> FileInputStream(file));</div><div class="line">            <span class="keyword">return</span>  bitmap;</div><div class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span>  <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="md5"><a href="#md5" class="headerlink" title="md5"></a>md5</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.losileeya.imageloader.utils;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.security.MessageDigest;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * User: Losileeya (847457332@qq.com)</div><div class="line"> * Date: 2016-08-31</div><div class="line"> * Time: 11:02</div><div class="line"> * 类描述：</div><div class="line"> *</div><div class="line"> * <span class="doctag">@version</span> :</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Md5Encoder</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">static</span> String <span class="title">encode</span><span class="params">(String str)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="keyword">byte</span>[] hash = MessageDigest.getInstance(<span class="string">"MD5"</span>).digest(str.getBytes(<span class="string">"UTF-8"</span>));</div><div class="line">        StringBuilder hex = <span class="keyword">new</span> StringBuilder(hash.length * <span class="number">2</span>);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">byte</span> b : hash) &#123;</div><div class="line">            <span class="keyword">if</span> ((b &amp; <span class="number">0xFF</span>) &lt; <span class="number">0x10</span>) &#123;</div><div class="line">                hex.append(<span class="string">"0"</span>);</div><div class="line">            &#125;</div><div class="line">            hex.append(Integer.toHexString(b &amp; <span class="number">0xFF</span>));</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> hex.toString();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="网络缓存（NetCache）"><a href="#网络缓存（NetCache）" class="headerlink" title="网络缓存（NetCache）"></a>网络缓存（NetCache）</h4><p>网络拉取图片严格来讲不能称之为缓存，实质上就是下载url对应的图片，我们这里姑且把它看作是缓存的一种。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.losileeya.imageloader.ImageLoder;</div><div class="line"></div><div class="line"><span class="keyword">import</span> android.graphics.Bitmap;</div><div class="line"><span class="keyword">import</span> android.graphics.BitmapFactory;</div><div class="line"><span class="keyword">import</span> android.os.AsyncTask;</div><div class="line"><span class="keyword">import</span> android.widget.ImageView;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"><span class="keyword">import</span> java.net.HttpURLConnection;</div><div class="line"><span class="keyword">import</span> java.net.URL;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * User: Losileeya (847457332@qq.com)</div><div class="line"> * Date: 2016-08-31</div><div class="line"> * Time: 10:50</div><div class="line"> * 类描述：网络下载图片</div><div class="line"> *</div><div class="line"> * <span class="doctag">@version</span> :</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NetCache</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> LocalCache mLocalCache;</div><div class="line">    <span class="keyword">private</span> MemoryCache mMemoryCache;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NetCache</span><span class="params">(LocalCache localCache, MemoryCache memoryCache)</span> </span>&#123;</div><div class="line">        mLocalCache = localCache;</div><div class="line">        mMemoryCache = memoryCache;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 从网络下载图片</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> ivPic 显示图片的imageview</div><div class="line">     * <span class="doctag">@param</span> url   下载图片的网络地址</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getBitmapFromNet</span><span class="params">(ImageView ivPic, String url)</span> </span>&#123;</div><div class="line">      <span class="comment">//  new BitmapTask().execute(ivPic, url);//启动AsyncTask</span></div><div class="line">          <span class="keyword">new</span> BitmapTask().executeOnExecutor(Executors.newFixedThreadPool(<span class="number">5</span>),ivPic,url);<span class="comment">//启动5个线程的线程池AsyncTask</span></div><div class="line">    &#125;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * AsyncTask就是对handler和线程池的封装</div><div class="line">     * 第一个泛型:参数类型</div><div class="line">     * 第二个泛型:更新进度的泛型</div><div class="line">     * 第三个泛型:onPostExecute的返回结果</div><div class="line">     */</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">BitmapTask</span> <span class="keyword">extends</span> <span class="title">AsyncTask</span>&lt;<span class="title">Object</span>, <span class="title">Void</span>, <span class="title">Bitmap</span>&gt; </span>&#123;</div><div class="line">        <span class="keyword">private</span> ImageView ivPic;</div><div class="line">        <span class="keyword">private</span> String url;</div><div class="line">        <span class="comment">/**</span></div><div class="line">         * 后台耗时操作,存在于子线程中</div><div class="line">         *</div><div class="line">         * <span class="doctag">@param</span> params</div><div class="line">         * <span class="doctag">@return</span></div><div class="line">         */</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">protected</span> Bitmap <span class="title">doInBackground</span><span class="params">(Object... params)</span> </span>&#123;</div><div class="line">            ivPic = (ImageView) params[<span class="number">0</span>];</div><div class="line">            url = (String) params[<span class="number">1</span>];</div><div class="line">            <span class="keyword">return</span> downLoadBitmap(url);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">/**</span></div><div class="line">         * 更新进度,在主线程中</div><div class="line">         *</div><div class="line">         * <span class="doctag">@param</span> values</div><div class="line">         */</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onProgressUpdate</span><span class="params">(Void[] values)</span> </span>&#123;</div><div class="line">            <span class="keyword">super</span>.onProgressUpdate(values);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">/**</span></div><div class="line">         * 耗时方法结束后执行该方法,主线程中</div><div class="line">         *</div><div class="line">         * <span class="doctag">@param</span> result</div><div class="line">         */</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPostExecute</span><span class="params">(Bitmap result)</span> </span>&#123;</div><div class="line">            <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</div><div class="line">                ivPic.setImageBitmap(result);</div><div class="line">                System.out.println(<span class="string">"从网络缓存图片啦....."</span>);</div><div class="line"></div><div class="line">                <span class="comment">//从网络获取图片后,保存至本地缓存</span></div><div class="line">                mLocalCache.setBitmapToLocal(url, result);</div><div class="line">                <span class="comment">//保存至内存中</span></div><div class="line">                mMemoryCache.putBitmapToMemory(url, result);</div><div class="line">                <span class="comment">//保存置硬盘disk</span></div><div class="line"><span class="comment">//                DiskCache.openCache(context);</span></div><div class="line"><span class="comment">//                try &#123;</span></div><div class="line"><span class="comment">//                    DiskCache.putBitmapToDisk( result,url);</span></div><div class="line"><span class="comment">//                   DiskCache.closeCache();</span></div><div class="line"><span class="comment">//                &#125; catch (Exception e) &#123;</span></div><div class="line"><span class="comment">//                    e.printStackTrace();</span></div><div class="line"><span class="comment">//                &#125;</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 网络下载图片</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> url</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> Bitmap <span class="title">downLoadBitmap</span><span class="params">(String url)</span> </span>&#123;</div><div class="line">        HttpURLConnection conn = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            conn = (HttpURLConnection) <span class="keyword">new</span> URL(url).openConnection();</div><div class="line">            conn.setConnectTimeout(<span class="number">5000</span>);</div><div class="line">            conn.setReadTimeout(<span class="number">5000</span>);</div><div class="line">            conn.setRequestMethod(<span class="string">"GET"</span>);</div><div class="line">            <span class="keyword">int</span> responseCode = conn.getResponseCode();</div><div class="line">            <span class="keyword">if</span> (responseCode == <span class="number">200</span>) &#123;</div><div class="line">                <span class="comment">//图片压缩</span></div><div class="line">                BitmapFactory.Options options = <span class="keyword">new</span> BitmapFactory.Options();</div><div class="line">                options.inSampleSize = <span class="number">2</span>;<span class="comment">//宽高压缩为原来的1/2</span></div><div class="line">                options.inPreferredConfig = Bitmap.Config.ARGB_4444;</div><div class="line">                Bitmap bitmap = BitmapFactory.decodeStream(conn.getInputStream(), <span class="keyword">null</span>, options);</div><div class="line">                <span class="keyword">return</span> bitmap;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;<span class="keyword">finally</span> &#123;</div><div class="line">            <span class="keyword">if</span>(conn!=<span class="keyword">null</span>)&#123;</div><div class="line">                conn.disconnect();</div><div class="line">                conn=<span class="keyword">null</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="提供调用方法ImageLoder-disPlayImage"><a href="#提供调用方法ImageLoder-disPlayImage" class="headerlink" title="提供调用方法ImageLoder.disPlayImage"></a>提供调用方法ImageLoder.disPlayImage</h4><p>严格的来说需要提供一个门面来加载显示图片的，这里就简单的加载了:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.losileeya.imageloader.ImageLoder;</div><div class="line"></div><div class="line"><span class="keyword">import</span> android.content.Context;</div><div class="line"><span class="keyword">import</span> android.graphics.Bitmap;</div><div class="line"><span class="keyword">import</span> android.widget.ImageView;</div><div class="line"></div><div class="line"><span class="keyword">import</span> com.losileeya.imageloader.R;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * User: Losileeya (847457332@qq.com)</div><div class="line"> * Date: 2016-08-31</div><div class="line"> * Time: 10:49</div><div class="line"> * 类描述：实现三级缓存，加载显示图片</div><div class="line"> *</div><div class="line"> * <span class="doctag">@version</span> :</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImageLoder</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> NetCache mNetCache;</div><div class="line">    <span class="keyword">private</span> LocalCache mLocalCache;</div><div class="line">    <span class="keyword">private</span> MemoryCache mMemoryCache;</div><div class="line">    <span class="keyword">private</span> Context context;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ImageLoder</span><span class="params">(Context context)</span> </span>&#123;</div><div class="line">        mLocalCache = <span class="keyword">new</span> LocalCache();</div><div class="line">        mMemoryCache = <span class="keyword">new</span> MemoryCache();</div><div class="line">        mNetCache = <span class="keyword">new</span> NetCache(mLocalCache,mMemoryCache);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">disPlayImage</span><span class="params">(ImageView pic, String url)</span> </span>&#123;</div><div class="line">        pic.setImageResource(R.mipmap.ic_launcher);</div><div class="line">        Bitmap bitmap;</div><div class="line">        <span class="comment">//内存缓存</span></div><div class="line">        bitmap=mMemoryCache.getBitmapFormMemory(url);</div><div class="line">        <span class="keyword">if</span> (bitmap!=<span class="keyword">null</span>)&#123;</div><div class="line">            pic.setImageBitmap(bitmap);</div><div class="line">            System.out.println(<span class="string">"从内存获取图片啦....."</span>);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//本地缓存</span></div><div class="line">        bitmap = mLocalCache.getBitampFormLocal(url);</div><div class="line"><span class="comment">//        DiskCache.openCache(context);</span></div><div class="line"><span class="comment">//        if(DiskCache.hasCache(url))&#123;</span></div><div class="line"><span class="comment">//            try &#123;</span></div><div class="line"><span class="comment">//                bitmap= DiskCache.getBitmapFormDisk(url);</span></div><div class="line"><span class="comment">//            &#125; catch (Exception e) &#123;</span></div><div class="line"><span class="comment">//                e.printStackTrace();</span></div><div class="line"><span class="comment">//            &#125;</span></div><div class="line"><span class="comment">//        &#125;</span></div><div class="line">        <span class="keyword">if</span>(bitmap !=<span class="keyword">null</span>)&#123;</div><div class="line">            pic.setImageBitmap(bitmap);</div><div class="line">            System.out.println(<span class="string">"从本地获取图片啦....."</span>);</div><div class="line">            <span class="comment">//从本地获取图片后,保存至内存中</span></div><div class="line">            mMemoryCache.putBitmapToMemory(url,bitmap);</div><div class="line">            <span class="comment">//从disk获取图片后，保存到内存</span></div><div class="line"><span class="comment">//            try &#123;</span></div><div class="line"><span class="comment">//                DiskCache.putBitmapToDisk(bitmap,url);</span></div><div class="line"><span class="comment">//                 DiskCache.closeCache();</span></div><div class="line"><span class="comment">//            &#125; catch (Exception e) &#123;</span></div><div class="line"><span class="comment">//                e.printStackTrace();</span></div><div class="line"><span class="comment">//            &#125;</span></div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//网络缓存</span></div><div class="line">        mNetCache.getBitmapFromNet(pic,url);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从代码里我们可以看出，显示我们就是按顺序判断是否在内存中有bitmap，有就显示，没有就继续从本地找bitmap都没有去网络下载显示。</p>
<p>上述代码里面注释了DiskCache，因为自己写的一般保存到本地的方法都为存文件到sd卡，这里就顺带介绍下DiskLruCache。</p>
<h4 id="DiskLruCache硬盘缓存"><a href="#DiskLruCache硬盘缓存" class="headerlink" title="DiskLruCache硬盘缓存"></a>DiskLruCache硬盘缓存</h4><p>从各大图片缓存框架我们知道从网络上获取到之后都会存入到本地缓存中使用的是DiskLruCache，</p>
<p>由于DiskLruCache并不是由Google官方编写的，所以这个类并没有被包含在Android API当中，我们需要将这个类从网上下载下来，然后手动添加到项目当中。(代码有点多)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div><div class="line">250</div><div class="line">251</div><div class="line">252</div><div class="line">253</div><div class="line">254</div><div class="line">255</div><div class="line">256</div><div class="line">257</div><div class="line">258</div><div class="line">259</div><div class="line">260</div><div class="line">261</div><div class="line">262</div><div class="line">263</div><div class="line">264</div><div class="line">265</div><div class="line">266</div><div class="line">267</div><div class="line">268</div><div class="line">269</div><div class="line">270</div><div class="line">271</div><div class="line">272</div><div class="line">273</div><div class="line">274</div><div class="line">275</div><div class="line">276</div><div class="line">277</div><div class="line">278</div><div class="line">279</div><div class="line">280</div><div class="line">281</div><div class="line">282</div><div class="line">283</div><div class="line">284</div><div class="line">285</div><div class="line">286</div><div class="line">287</div><div class="line">288</div><div class="line">289</div><div class="line">290</div><div class="line">291</div><div class="line">292</div><div class="line">293</div><div class="line">294</div><div class="line">295</div><div class="line">296</div><div class="line">297</div><div class="line">298</div><div class="line">299</div><div class="line">300</div><div class="line">301</div><div class="line">302</div><div class="line">303</div><div class="line">304</div><div class="line">305</div><div class="line">306</div><div class="line">307</div><div class="line">308</div><div class="line">309</div><div class="line">310</div><div class="line">311</div><div class="line">312</div><div class="line">313</div><div class="line">314</div><div class="line">315</div><div class="line">316</div><div class="line">317</div><div class="line">318</div><div class="line">319</div><div class="line">320</div><div class="line">321</div><div class="line">322</div><div class="line">323</div><div class="line">324</div><div class="line">325</div><div class="line">326</div><div class="line">327</div><div class="line">328</div><div class="line">329</div><div class="line">330</div><div class="line">331</div><div class="line">332</div><div class="line">333</div><div class="line">334</div><div class="line">335</div><div class="line">336</div><div class="line">337</div><div class="line">338</div><div class="line">339</div><div class="line">340</div><div class="line">341</div><div class="line">342</div><div class="line">343</div><div class="line">344</div><div class="line">345</div><div class="line">346</div><div class="line">347</div><div class="line">348</div><div class="line">349</div><div class="line">350</div><div class="line">351</div><div class="line">352</div><div class="line">353</div><div class="line">354</div><div class="line">355</div><div class="line">356</div><div class="line">357</div><div class="line">358</div><div class="line">359</div><div class="line">360</div><div class="line">361</div><div class="line">362</div><div class="line">363</div><div class="line">364</div><div class="line">365</div><div class="line">366</div><div class="line">367</div><div class="line">368</div><div class="line">369</div><div class="line">370</div><div class="line">371</div><div class="line">372</div><div class="line">373</div><div class="line">374</div><div class="line">375</div><div class="line">376</div><div class="line">377</div><div class="line">378</div><div class="line">379</div><div class="line">380</div><div class="line">381</div><div class="line">382</div><div class="line">383</div><div class="line">384</div><div class="line">385</div><div class="line">386</div><div class="line">387</div><div class="line">388</div><div class="line">389</div><div class="line">390</div><div class="line">391</div><div class="line">392</div><div class="line">393</div><div class="line">394</div><div class="line">395</div><div class="line">396</div><div class="line">397</div><div class="line">398</div><div class="line">399</div><div class="line">400</div><div class="line">401</div><div class="line">402</div><div class="line">403</div><div class="line">404</div><div class="line">405</div><div class="line">406</div><div class="line">407</div><div class="line">408</div><div class="line">409</div><div class="line">410</div><div class="line">411</div><div class="line">412</div><div class="line">413</div><div class="line">414</div><div class="line">415</div><div class="line">416</div><div class="line">417</div><div class="line">418</div><div class="line">419</div><div class="line">420</div><div class="line">421</div><div class="line">422</div><div class="line">423</div><div class="line">424</div><div class="line">425</div><div class="line">426</div><div class="line">427</div><div class="line">428</div><div class="line">429</div><div class="line">430</div><div class="line">431</div><div class="line">432</div><div class="line">433</div><div class="line">434</div><div class="line">435</div><div class="line">436</div><div class="line">437</div><div class="line">438</div><div class="line">439</div><div class="line">440</div><div class="line">441</div><div class="line">442</div><div class="line">443</div><div class="line">444</div><div class="line">445</div><div class="line">446</div><div class="line">447</div><div class="line">448</div><div class="line">449</div><div class="line">450</div><div class="line">451</div><div class="line">452</div><div class="line">453</div><div class="line">454</div><div class="line">455</div><div class="line">456</div><div class="line">457</div><div class="line">458</div><div class="line">459</div><div class="line">460</div><div class="line">461</div><div class="line">462</div><div class="line">463</div><div class="line">464</div><div class="line">465</div><div class="line">466</div><div class="line">467</div><div class="line">468</div><div class="line">469</div><div class="line">470</div><div class="line">471</div><div class="line">472</div><div class="line">473</div><div class="line">474</div><div class="line">475</div><div class="line">476</div><div class="line">477</div><div class="line">478</div><div class="line">479</div><div class="line">480</div><div class="line">481</div><div class="line">482</div><div class="line">483</div><div class="line">484</div><div class="line">485</div><div class="line">486</div><div class="line">487</div><div class="line">488</div><div class="line">489</div><div class="line">490</div><div class="line">491</div><div class="line">492</div><div class="line">493</div><div class="line">494</div><div class="line">495</div><div class="line">496</div><div class="line">497</div><div class="line">498</div><div class="line">499</div><div class="line">500</div><div class="line">501</div><div class="line">502</div><div class="line">503</div><div class="line">504</div><div class="line">505</div><div class="line">506</div><div class="line">507</div><div class="line">508</div><div class="line">509</div><div class="line">510</div><div class="line">511</div><div class="line">512</div><div class="line">513</div><div class="line">514</div><div class="line">515</div><div class="line">516</div><div class="line">517</div><div class="line">518</div><div class="line">519</div><div class="line">520</div><div class="line">521</div><div class="line">522</div><div class="line">523</div><div class="line">524</div><div class="line">525</div><div class="line">526</div><div class="line">527</div><div class="line">528</div><div class="line">529</div><div class="line">530</div><div class="line">531</div><div class="line">532</div><div class="line">533</div><div class="line">534</div><div class="line">535</div><div class="line">536</div><div class="line">537</div><div class="line">538</div><div class="line">539</div><div class="line">540</div><div class="line">541</div><div class="line">542</div><div class="line">543</div><div class="line">544</div><div class="line">545</div><div class="line">546</div><div class="line">547</div><div class="line">548</div><div class="line">549</div><div class="line">550</div><div class="line">551</div><div class="line">552</div><div class="line">553</div><div class="line">554</div><div class="line">555</div><div class="line">556</div><div class="line">557</div><div class="line">558</div><div class="line">559</div><div class="line">560</div><div class="line">561</div><div class="line">562</div><div class="line">563</div><div class="line">564</div><div class="line">565</div><div class="line">566</div><div class="line">567</div><div class="line">568</div><div class="line">569</div><div class="line">570</div><div class="line">571</div><div class="line">572</div><div class="line">573</div><div class="line">574</div><div class="line">575</div><div class="line">576</div><div class="line">577</div><div class="line">578</div><div class="line">579</div><div class="line">580</div><div class="line">581</div><div class="line">582</div><div class="line">583</div><div class="line">584</div><div class="line">585</div><div class="line">586</div><div class="line">587</div><div class="line">588</div><div class="line">589</div><div class="line">590</div><div class="line">591</div><div class="line">592</div><div class="line">593</div><div class="line">594</div><div class="line">595</div><div class="line">596</div><div class="line">597</div><div class="line">598</div><div class="line">599</div><div class="line">600</div><div class="line">601</div><div class="line">602</div><div class="line">603</div><div class="line">604</div><div class="line">605</div><div class="line">606</div><div class="line">607</div><div class="line">608</div><div class="line">609</div><div class="line">610</div><div class="line">611</div><div class="line">612</div><div class="line">613</div><div class="line">614</div><div class="line">615</div><div class="line">616</div><div class="line">617</div><div class="line">618</div><div class="line">619</div><div class="line">620</div><div class="line">621</div><div class="line">622</div><div class="line">623</div><div class="line">624</div><div class="line">625</div><div class="line">626</div><div class="line">627</div><div class="line">628</div><div class="line">629</div><div class="line">630</div><div class="line">631</div><div class="line">632</div><div class="line">633</div><div class="line">634</div><div class="line">635</div><div class="line">636</div><div class="line">637</div><div class="line">638</div><div class="line">639</div><div class="line">640</div><div class="line">641</div><div class="line">642</div><div class="line">643</div><div class="line">644</div><div class="line">645</div><div class="line">646</div><div class="line">647</div><div class="line">648</div><div class="line">649</div><div class="line">650</div><div class="line">651</div><div class="line">652</div><div class="line">653</div><div class="line">654</div><div class="line">655</div><div class="line">656</div><div class="line">657</div><div class="line">658</div><div class="line">659</div><div class="line">660</div><div class="line">661</div><div class="line">662</div><div class="line">663</div><div class="line">664</div><div class="line">665</div><div class="line">666</div><div class="line">667</div><div class="line">668</div><div class="line">669</div><div class="line">670</div><div class="line">671</div><div class="line">672</div><div class="line">673</div><div class="line">674</div><div class="line">675</div><div class="line">676</div><div class="line">677</div><div class="line">678</div><div class="line">679</div><div class="line">680</div><div class="line">681</div><div class="line">682</div><div class="line">683</div><div class="line">684</div><div class="line">685</div><div class="line">686</div><div class="line">687</div><div class="line">688</div><div class="line">689</div><div class="line">690</div><div class="line">691</div><div class="line">692</div><div class="line">693</div><div class="line">694</div><div class="line">695</div><div class="line">696</div><div class="line">697</div><div class="line">698</div><div class="line">699</div><div class="line">700</div><div class="line">701</div><div class="line">702</div><div class="line">703</div><div class="line">704</div><div class="line">705</div><div class="line">706</div><div class="line">707</div><div class="line">708</div><div class="line">709</div><div class="line">710</div><div class="line">711</div><div class="line">712</div><div class="line">713</div><div class="line">714</div><div class="line">715</div><div class="line">716</div><div class="line">717</div><div class="line">718</div><div class="line">719</div><div class="line">720</div><div class="line">721</div><div class="line">722</div><div class="line">723</div><div class="line">724</div><div class="line">725</div><div class="line">726</div><div class="line">727</div><div class="line">728</div><div class="line">729</div><div class="line">730</div><div class="line">731</div><div class="line">732</div><div class="line">733</div><div class="line">734</div><div class="line">735</div><div class="line">736</div><div class="line">737</div><div class="line">738</div><div class="line">739</div><div class="line">740</div><div class="line">741</div><div class="line">742</div><div class="line">743</div><div class="line">744</div><div class="line">745</div><div class="line">746</div><div class="line">747</div><div class="line">748</div><div class="line">749</div><div class="line">750</div><div class="line">751</div><div class="line">752</div><div class="line">753</div><div class="line">754</div><div class="line">755</div><div class="line">756</div><div class="line">757</div><div class="line">758</div><div class="line">759</div><div class="line">760</div><div class="line">761</div><div class="line">762</div><div class="line">763</div><div class="line">764</div><div class="line">765</div><div class="line">766</div><div class="line">767</div><div class="line">768</div><div class="line">769</div><div class="line">770</div><div class="line">771</div><div class="line">772</div><div class="line">773</div><div class="line">774</div><div class="line">775</div><div class="line">776</div><div class="line">777</div><div class="line">778</div><div class="line">779</div><div class="line">780</div><div class="line">781</div><div class="line">782</div><div class="line">783</div><div class="line">784</div><div class="line">785</div><div class="line">786</div><div class="line">787</div><div class="line">788</div><div class="line">789</div><div class="line">790</div><div class="line">791</div><div class="line">792</div><div class="line">793</div><div class="line">794</div><div class="line">795</div><div class="line">796</div><div class="line">797</div><div class="line">798</div><div class="line">799</div><div class="line">800</div><div class="line">801</div><div class="line">802</div><div class="line">803</div><div class="line">804</div><div class="line">805</div><div class="line">806</div><div class="line">807</div><div class="line">808</div><div class="line">809</div><div class="line">810</div><div class="line">811</div><div class="line">812</div><div class="line">813</div><div class="line">814</div><div class="line">815</div><div class="line">816</div><div class="line">817</div><div class="line">818</div><div class="line">819</div><div class="line">820</div><div class="line">821</div><div class="line">822</div><div class="line">823</div><div class="line">824</div><div class="line">825</div><div class="line">826</div><div class="line">827</div><div class="line">828</div><div class="line">829</div><div class="line">830</div><div class="line">831</div><div class="line">832</div><div class="line">833</div><div class="line">834</div><div class="line">835</div><div class="line">836</div><div class="line">837</div><div class="line">838</div><div class="line">839</div><div class="line">840</div><div class="line">841</div><div class="line">842</div><div class="line">843</div><div class="line">844</div><div class="line">845</div><div class="line">846</div><div class="line">847</div><div class="line">848</div><div class="line">849</div><div class="line">850</div><div class="line">851</div><div class="line">852</div><div class="line">853</div><div class="line">854</div><div class="line">855</div><div class="line">856</div><div class="line">857</div><div class="line">858</div><div class="line">859</div><div class="line">860</div><div class="line">861</div><div class="line">862</div><div class="line">863</div><div class="line">864</div><div class="line">865</div><div class="line">866</div><div class="line">867</div><div class="line">868</div><div class="line">869</div><div class="line">870</div><div class="line">871</div><div class="line">872</div><div class="line">873</div><div class="line">874</div><div class="line">875</div><div class="line">876</div><div class="line">877</div><div class="line">878</div><div class="line">879</div><div class="line">880</div><div class="line">881</div><div class="line">882</div><div class="line">883</div><div class="line">884</div><div class="line">885</div><div class="line">886</div><div class="line">887</div><div class="line">888</div><div class="line">889</div><div class="line">890</div><div class="line">891</div><div class="line">892</div><div class="line">893</div><div class="line">894</div><div class="line">895</div><div class="line">896</div><div class="line">897</div><div class="line">898</div><div class="line">899</div><div class="line">900</div><div class="line">901</div><div class="line">902</div><div class="line">903</div><div class="line">904</div><div class="line">905</div><div class="line">906</div><div class="line">907</div><div class="line">908</div><div class="line">909</div><div class="line">910</div><div class="line">911</div><div class="line">912</div><div class="line">913</div><div class="line">914</div><div class="line">915</div><div class="line">916</div><div class="line">917</div><div class="line">918</div><div class="line">919</div><div class="line">920</div><div class="line">921</div><div class="line">922</div><div class="line">923</div><div class="line">924</div><div class="line">925</div><div class="line">926</div><div class="line">927</div><div class="line">928</div><div class="line">929</div><div class="line">930</div><div class="line">931</div><div class="line">932</div><div class="line">933</div><div class="line">934</div><div class="line">935</div><div class="line">936</div><div class="line">937</div><div class="line">938</div><div class="line">939</div><div class="line">940</div><div class="line">941</div><div class="line">942</div><div class="line">943</div><div class="line">944</div><div class="line">945</div><div class="line">946</div><div class="line">947</div><div class="line">948</div><div class="line">949</div><div class="line">950</div><div class="line">951</div><div class="line">952</div><div class="line">953</div><div class="line">954</div><div class="line">955</div><div class="line">956</div><div class="line">957</div><div class="line">958</div><div class="line">959</div><div class="line">960</div><div class="line">961</div><div class="line">962</div><div class="line">963</div><div class="line">964</div><div class="line">965</div><div class="line">966</div><div class="line">967</div><div class="line">968</div><div class="line">969</div><div class="line">970</div><div class="line">971</div><div class="line">972</div><div class="line">973</div><div class="line">974</div><div class="line">975</div><div class="line">976</div><div class="line">977</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.losileeya.imageloader.utils;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * User: Losileeya (847457332@qq.com)</div><div class="line"> * Date: 2016-08-31</div><div class="line"> * Time: 10:51</div><div class="line"> * 类描述：</div><div class="line"> *</div><div class="line"> * <span class="doctag">@version</span> :</div><div class="line"> */</div><div class="line"><span class="comment">/*</span></div><div class="line"> * Copyright (C) 2011 The Android Open Source Project</div><div class="line"> *</div><div class="line"> * Licensed under the Apache License, Version 2.0 (the "License");</div><div class="line"> * you may not use this file except in compliance with the License.</div><div class="line"> * You may obtain a copy of the License at</div><div class="line"> *</div><div class="line"> *      http://www.apache.org/licenses/LICENSE-2.0</div><div class="line"> *</div><div class="line"> * Unless required by applicable law or agreed to in writing, software</div><div class="line"> * distributed under the License is distributed on an "AS IS" BASIS,</div><div class="line"> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</div><div class="line"> * See the License for the specific language governing permissions and</div><div class="line"> * limitations under the License.</div><div class="line"> */</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.BufferedInputStream;</div><div class="line"><span class="keyword">import</span> java.io.BufferedWriter;</div><div class="line"><span class="keyword">import</span> java.io.Closeable;</div><div class="line"><span class="keyword">import</span> java.io.EOFException;</div><div class="line"><span class="keyword">import</span> java.io.File;</div><div class="line"><span class="keyword">import</span> java.io.FileInputStream;</div><div class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</div><div class="line"><span class="keyword">import</span> java.io.FileOutputStream;</div><div class="line"><span class="keyword">import</span> java.io.FileWriter;</div><div class="line"><span class="keyword">import</span> java.io.FilterOutputStream;</div><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"><span class="keyword">import</span> java.io.InputStream;</div><div class="line"><span class="keyword">import</span> java.io.InputStreamReader;</div><div class="line"><span class="keyword">import</span> java.io.OutputStream;</div><div class="line"><span class="keyword">import</span> java.io.OutputStreamWriter;</div><div class="line"><span class="keyword">import</span> java.io.Reader;</div><div class="line"><span class="keyword">import</span> java.io.StringWriter;</div><div class="line"><span class="keyword">import</span> java.io.Writer;</div><div class="line"><span class="keyword">import</span> java.lang.reflect.Array;</div><div class="line"><span class="keyword">import</span> java.nio.charset.Charset;</div><div class="line"><span class="keyword">import</span> java.util.ArrayList;</div><div class="line"><span class="keyword">import</span> java.util.Arrays;</div><div class="line"><span class="keyword">import</span> java.util.Iterator;</div><div class="line"><span class="keyword">import</span> java.util.LinkedHashMap;</div><div class="line"><span class="keyword">import</span> java.util.Map;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.LinkedBlockingQueue;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * *****************************************************************************</div><div class="line"> * Taken from the JB source code, can be found in:</div><div class="line"> * libcore/luni/src/main/java/libcore/io/DiskLruCache.java</div><div class="line"> * or direct link:</div><div class="line"> * https://android.googlesource.com/platform/libcore/+/android-4.1.1_r1/luni/src/main/java/libcore/io/DiskLruCache.java</div><div class="line"> * *****************************************************************************</div><div class="line"> * &lt;p/&gt;</div><div class="line"> * A cache that uses a bounded amount of space on a filesystem. Each cache</div><div class="line"> * entry has a string key and a fixed number of values. Values are byte</div><div class="line"> * sequences, accessible as streams or files. Each value must be between &#123;<span class="doctag">@code</span></div><div class="line"> * 0&#125; and &#123;<span class="doctag">@code</span> Integer.MAX_VALUE&#125; bytes in length.</div><div class="line"> * &lt;p/&gt;</div><div class="line"> * &lt;p&gt;The cache stores its data in a directory on the filesystem. This</div><div class="line"> * directory must be exclusive to the cache; the cache may delete or overwrite</div><div class="line"> * files from its directory. It is an error for multiple processes to use the</div><div class="line"> * same cache directory at the same time.</div><div class="line"> * &lt;p/&gt;</div><div class="line"> * &lt;p&gt;This cache limits the number of bytes that it will store on the</div><div class="line"> * filesystem. When the number of stored bytes exceeds the limit, the cache will</div><div class="line"> * remove entries in the background until the limit is satisfied. The limit is</div><div class="line"> * not strict: the cache may temporarily exceed it while waiting for files to be</div><div class="line"> * deleted. The limit does not include filesystem overhead or the cache</div><div class="line"> * journal so space-sensitive applications should set a conservative limit.</div><div class="line"> * &lt;p/&gt;</div><div class="line"> * &lt;p&gt;Clients call &#123;<span class="doctag">@link</span> #edit&#125; to create or update the values of an entry. An</div><div class="line"> * entry may have only one editor at one time; if a value is not available to be</div><div class="line"> * edited then &#123;<span class="doctag">@link</span> #edit&#125; will return null.</div><div class="line"> * &lt;ul&gt;</div><div class="line"> * &lt;li&gt;When an entry is being &lt;strong&gt;created&lt;/strong&gt; it is necessary to</div><div class="line"> * supply a full set of values; the empty value should be used as a</div><div class="line"> * placeholder if necessary.</div><div class="line"> * &lt;li&gt;When an entry is being &lt;strong&gt;edited&lt;/strong&gt;, it is not necessary</div><div class="line"> * to supply data for every value; values default to their previous</div><div class="line"> * value.</div><div class="line"> * &lt;/ul&gt;</div><div class="line"> * Every &#123;<span class="doctag">@link</span> #edit&#125; call must be matched by a call to &#123;<span class="doctag">@link</span> Editor#commit&#125;</div><div class="line"> * or &#123;<span class="doctag">@link</span> Editor#abort&#125;. Committing is atomic: a read observes the full set</div><div class="line"> * of values as they were before or after the commit, but never a mix of values.</div><div class="line"> * &lt;p/&gt;</div><div class="line"> * &lt;p&gt;Clients call &#123;<span class="doctag">@link</span> #get&#125; to read a snapshot of an entry. The read will</div><div class="line"> * observe the value at the time that &#123;<span class="doctag">@link</span> #get&#125; was called. Updates and</div><div class="line"> * removals after the call do not impact ongoing reads.</div><div class="line"> * &lt;p/&gt;</div><div class="line"> * &lt;p&gt;This class is tolerant of some I/O errors. If files are missing from the</div><div class="line"> * filesystem, the corresponding entries will be dropped from the cache. If</div><div class="line"> * an error occurs while writing a cache value, the edit will fail silently.</div><div class="line"> * Callers should handle other problems by catching &#123;<span class="doctag">@code</span> IOException&#125; and</div><div class="line"> * responding appropriately.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DiskLruCache</span> <span class="keyword">implements</span> <span class="title">Closeable</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String JOURNAL_FILE = <span class="string">"journal"</span>;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String JOURNAL_FILE_TMP = <span class="string">"journal.tmp"</span>;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String MAGIC = <span class="string">"com.losileeya.DiskLruCache"</span>;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String VERSION_1 = <span class="string">"1"</span>;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> ANY_SEQUENCE_NUMBER = -<span class="number">1</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String CLEAN = <span class="string">"CLEAN"</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DIRTY = <span class="string">"DIRTY"</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String REMOVE = <span class="string">"REMOVE"</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String READ = <span class="string">"READ"</span>;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Charset UTF_8 = Charset.forName(<span class="string">"UTF-8"</span>);</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> IO_BUFFER_SIZE = <span class="number">8</span> * <span class="number">1024</span>;</div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line">     * This cache uses a journal file named "journal". A typical journal file</div><div class="line">     * looks like this:</div><div class="line">     *     libcore.io.DiskLruCache</div><div class="line">     *     1</div><div class="line">     *     100</div><div class="line">     *     2</div><div class="line">     *</div><div class="line">     *     CLEAN 3400330d1dfc7f3f7f4b8d4d803dfcf6 832 21054</div><div class="line">     *     DIRTY 335c4c6028171cfddfbaae1a9c313c52</div><div class="line">     *     CLEAN 335c4c6028171cfddfbaae1a9c313c52 3934 2342</div><div class="line">     *     REMOVE 335c4c6028171cfddfbaae1a9c313c52</div><div class="line">     *     DIRTY 1ab96a171faeeee38496d8b330771a7a</div><div class="line">     *     CLEAN 1ab96a171faeeee38496d8b330771a7a 1600 234</div><div class="line">     *     READ 335c4c6028171cfddfbaae1a9c313c52</div><div class="line">     *     READ 3400330d1dfc7f3f7f4b8d4d803dfcf6</div><div class="line">     *</div><div class="line">     * The first five lines of the journal form its header. They are the</div><div class="line">     * constant string "libcore.io.DiskLruCache", the disk cache's version,</div><div class="line">     * the application's version, the value count, and a blank line.</div><div class="line">     *</div><div class="line">     * Each of the subsequent lines in the file is a record of the state of a</div><div class="line">     * cache entry. Each line contains space-separated values: a state, a key,</div><div class="line">     * and optional state-specific values.</div><div class="line">     *   o DIRTY lines track that an entry is actively being created or updated.</div><div class="line">     *     Every successful DIRTY action should be followed by a CLEAN or REMOVE</div><div class="line">     *     action. DIRTY lines without a matching CLEAN or REMOVE indicate that</div><div class="line">     *     temporary files may need to be deleted.</div><div class="line">     *   o CLEAN lines track a cache entry that has been successfully published</div><div class="line">     *     and may be read. A publish line is followed by the lengths of each of</div><div class="line">     *     its values.</div><div class="line">     *   o READ lines track accesses for LRU.</div><div class="line">     *   o REMOVE lines track entries that have been deleted.</div><div class="line">     *</div><div class="line">     * The journal file is appended to as cache operations occur. The journal may</div><div class="line">     * occasionally be compacted by dropping redundant lines. A temporary file named</div><div class="line">     * "journal.tmp" will be used during compaction; that file should be deleted if</div><div class="line">     * it exists when the cache is opened.</div><div class="line">     */</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> File directory;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> File journalFile;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> File journalFileTmp;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> appVersion;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> maxSize;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> valueCount;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">long</span> size = <span class="number">0</span>;</div><div class="line">    <span class="keyword">private</span> Writer journalWriter;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LinkedHashMap&lt;String, Entry&gt; lruEntries</div><div class="line">            = <span class="keyword">new</span> LinkedHashMap&lt;String, Entry&gt;(<span class="number">0</span>, <span class="number">0.75f</span>, <span class="keyword">true</span>);</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> redundantOpCount;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * To differentiate between old and current snapshots, each entry is given</div><div class="line">     * a sequence number each time an edit is committed. A snapshot is stale if</div><div class="line">     * its sequence number is not equal to its entry's sequence number.</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">long</span> nextSequenceNumber = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="comment">/* From java.util.Arrays */</span></div><div class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; T[] copyOfRange(T[] original, <span class="keyword">int</span> start, <span class="keyword">int</span> end) &#123;</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> originalLength = original.length; <span class="comment">// For exception priority compatibility.</span></div><div class="line">        <span class="keyword">if</span> (start &gt; end) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (start &lt; <span class="number">0</span> || start &gt; originalLength) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> resultLength = end - start;</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> copyLength = Math.min(resultLength, originalLength - start);</div><div class="line">        <span class="keyword">final</span> T[] result = (T[]) Array</div><div class="line">                .newInstance(original.getClass().getComponentType(), resultLength);</div><div class="line">        System.arraycopy(original, start, result, <span class="number">0</span>, copyLength);</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Returns the remainder of 'reader' as a string, closing it when done.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">readFully</span><span class="params">(Reader reader)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            StringWriter writer = <span class="keyword">new</span> StringWriter();</div><div class="line">            <span class="keyword">char</span>[] buffer = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1024</span>];</div><div class="line">            <span class="keyword">int</span> count;</div><div class="line">            <span class="keyword">while</span> ((count = reader.read(buffer)) != -<span class="number">1</span>) &#123;</div><div class="line">                writer.write(buffer, <span class="number">0</span>, count);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> writer.toString();</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            reader.close();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Returns the ASCII characters up to but not including the next "\r\n", or</div><div class="line">     * "\n".</div><div class="line">     *</div><div class="line">     * <span class="doctag">@throws</span> java.io.EOFException if the stream is exhausted before the next newline</div><div class="line">     *                              character.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">readAsciiLine</span><span class="params">(InputStream in)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        <span class="comment">// <span class="doctag">TODO:</span> support UTF-8 here instead</span></div><div class="line"></div><div class="line">        StringBuilder result = <span class="keyword">new</span> StringBuilder(<span class="number">80</span>);</div><div class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">            <span class="keyword">int</span> c = in.read();</div><div class="line">            <span class="keyword">if</span> (c == -<span class="number">1</span>) &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> EOFException();</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">'\n'</span>) &#123;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            result.append((<span class="keyword">char</span>) c);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> length = result.length();</div><div class="line">        <span class="keyword">if</span> (length &gt; <span class="number">0</span> &amp;&amp; result.charAt(length - <span class="number">1</span>) == <span class="string">'\r'</span>) &#123;</div><div class="line">            result.setLength(length - <span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result.toString();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Closes 'closeable', ignoring any checked exceptions. Does nothing if 'closeable' is null.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">closeQuietly</span><span class="params">(Closeable closeable)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (closeable != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                closeable.close();</div><div class="line">            &#125; <span class="keyword">catch</span> (RuntimeException rethrown) &#123;</div><div class="line">                <span class="keyword">throw</span> rethrown;</div><div class="line">            &#125; <span class="keyword">catch</span> (Exception ignored) &#123;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Recursively delete everything in &#123;<span class="doctag">@code</span> dir&#125;.</div><div class="line">     */</div><div class="line">    <span class="comment">// <span class="doctag">TODO:</span> this should specify paths as Strings rather than as Files</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deleteContents</span><span class="params">(File dir)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        File[] files = dir.listFiles();</div><div class="line">        <span class="keyword">if</span> (files == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"not a directory: "</span> + dir);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span> (File file : files) &#123;</div><div class="line">            <span class="keyword">if</span> (file.isDirectory()) &#123;</div><div class="line">                deleteContents(file);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (!file.delete()) &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"failed to delete file: "</span> + file);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * This cache uses a single background thread to evict entries.</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ExecutorService executorService = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, <span class="number">1</span>,</div><div class="line">            <span class="number">60L</span>, TimeUnit.SECONDS, <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Callable&lt;Void&gt; cleanupCallable = <span class="keyword">new</span> Callable&lt;Void&gt;() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> Void <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">            <span class="keyword">synchronized</span> (DiskLruCache.<span class="keyword">this</span>) &#123;</div><div class="line">                <span class="keyword">if</span> (journalWriter == <span class="keyword">null</span>) &#123;</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">// closed</span></div><div class="line">                &#125;</div><div class="line">                trimToSize();</div><div class="line">                <span class="keyword">if</span> (journalRebuildRequired()) &#123;</div><div class="line">                    rebuildJournal();</div><div class="line">                    redundantOpCount = <span class="number">0</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">DiskLruCache</span><span class="params">(File directory, <span class="keyword">int</span> appVersion, <span class="keyword">int</span> valueCount, <span class="keyword">long</span> maxSize)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.directory = directory;</div><div class="line">        <span class="keyword">this</span>.appVersion = appVersion;</div><div class="line">        <span class="keyword">this</span>.journalFile = <span class="keyword">new</span> File(directory, JOURNAL_FILE);</div><div class="line">        <span class="keyword">this</span>.journalFileTmp = <span class="keyword">new</span> File(directory, JOURNAL_FILE_TMP);</div><div class="line">        <span class="keyword">this</span>.valueCount = valueCount;</div><div class="line">        <span class="keyword">this</span>.maxSize = maxSize;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Opens the cache in &#123;<span class="doctag">@code</span> directory&#125;, creating a cache if none exists</div><div class="line">     * there.</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> directory  a writable directory</div><div class="line">     * <span class="doctag">@param</span> appVersion</div><div class="line">     * <span class="doctag">@param</span> valueCount the number of values per cache entry. Must be positive.</div><div class="line">     * <span class="doctag">@param</span> maxSize    the maximum number of bytes this cache should use to store</div><div class="line">     * <span class="doctag">@throws</span> java.io.IOException if reading or writing the cache directory fails</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DiskLruCache <span class="title">open</span><span class="params">(File directory, <span class="keyword">int</span> appVersion, <span class="keyword">int</span> valueCount, <span class="keyword">long</span> maxSize)</span></span></div><div class="line">            <span class="keyword">throws</span> IOException &#123;</div><div class="line">        <span class="keyword">if</span> (maxSize &lt;= <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"maxSize &lt;= 0"</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (valueCount &lt;= <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"valueCount &lt;= 0"</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// prefer to pick up where we left off</span></div><div class="line">        DiskLruCache cache = <span class="keyword">new</span> DiskLruCache(directory, appVersion, valueCount, maxSize);</div><div class="line">        <span class="keyword">if</span> (cache.journalFile.exists()) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                cache.readJournal();</div><div class="line">                cache.processJournal();</div><div class="line">                cache.journalWriter = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(cache.journalFile, <span class="keyword">true</span>),</div><div class="line">                        IO_BUFFER_SIZE);</div><div class="line">                <span class="keyword">return</span> cache;</div><div class="line">            &#125; <span class="keyword">catch</span> (IOException journalIsCorrupt) &#123;</div><div class="line"><span class="comment">//                System.logW("DiskLruCache " + directory + " is corrupt: "</span></div><div class="line"><span class="comment">//                        + journalIsCorrupt.getMessage() + ", removing");</span></div><div class="line">                cache.delete();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// create a new empty cache</span></div><div class="line">        directory.mkdirs();</div><div class="line">        cache = <span class="keyword">new</span> DiskLruCache(directory, appVersion, valueCount, maxSize);</div><div class="line">        cache.rebuildJournal();</div><div class="line">        <span class="keyword">return</span> cache;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readJournal</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        InputStream in = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(journalFile), IO_BUFFER_SIZE);</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            String magic = readAsciiLine(in);</div><div class="line">            String version = readAsciiLine(in);</div><div class="line">            String appVersionString = readAsciiLine(in);</div><div class="line">            String valueCountString = readAsciiLine(in);</div><div class="line">            String blank = readAsciiLine(in);</div><div class="line">            <span class="keyword">if</span> (!MAGIC.equals(magic)</div><div class="line">                    || !VERSION_1.equals(version)</div><div class="line">                    || !Integer.toString(appVersion).equals(appVersionString)</div><div class="line">                    || !Integer.toString(valueCount).equals(valueCountString)</div><div class="line">                    || !<span class="string">""</span>.equals(blank)) &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"unexpected journal header: ["</span></div><div class="line">                        + magic + <span class="string">", "</span> + version + <span class="string">", "</span> + valueCountString + <span class="string">", "</span> + blank + <span class="string">"]"</span>);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    readJournalLine(readAsciiLine(in));</div><div class="line">                &#125; <span class="keyword">catch</span> (EOFException endOfJournal) &#123;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            closeQuietly(in);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readJournalLine</span><span class="params">(String line)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        String[] parts = line.split(<span class="string">" "</span>);</div><div class="line">        <span class="keyword">if</span> (parts.length &lt; <span class="number">2</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"unexpected journal line: "</span> + line);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        String key = parts[<span class="number">1</span>];</div><div class="line">        <span class="keyword">if</span> (parts[<span class="number">0</span>].equals(REMOVE) &amp;&amp; parts.length == <span class="number">2</span>) &#123;</div><div class="line">            lruEntries.remove(key);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        Entry entry = lruEntries.get(key);</div><div class="line">        <span class="keyword">if</span> (entry == <span class="keyword">null</span>) &#123;</div><div class="line">            entry = <span class="keyword">new</span> Entry(key);</div><div class="line">            lruEntries.put(key, entry);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (parts[<span class="number">0</span>].equals(CLEAN) &amp;&amp; parts.length == <span class="number">2</span> + valueCount) &#123;</div><div class="line">            entry.readable = <span class="keyword">true</span>;</div><div class="line">            entry.currentEditor = <span class="keyword">null</span>;</div><div class="line">            entry.setLengths(copyOfRange(parts, <span class="number">2</span>, parts.length));</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parts[<span class="number">0</span>].equals(DIRTY) &amp;&amp; parts.length == <span class="number">2</span>) &#123;</div><div class="line">            entry.currentEditor = <span class="keyword">new</span> Editor(entry);</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parts[<span class="number">0</span>].equals(READ) &amp;&amp; parts.length == <span class="number">2</span>) &#123;</div><div class="line">            <span class="comment">// this work was already done by calling lruEntries.get()</span></div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"unexpected journal line: "</span> + line);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Computes the initial size and collects garbage as a part of opening the</div><div class="line">     * cache. Dirty entries are assumed to be inconsistent and will be deleted.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processJournal</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        deleteIfExists(journalFileTmp);</div><div class="line">        <span class="keyword">for</span> (Iterator&lt;Entry&gt; i = lruEntries.values().iterator(); i.hasNext(); ) &#123;</div><div class="line">            Entry entry = i.next();</div><div class="line">            <span class="keyword">if</span> (entry.currentEditor == <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">0</span>; t &lt; valueCount; t++) &#123;</div><div class="line">                    size += entry.lengths[t];</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                entry.currentEditor = <span class="keyword">null</span>;</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">0</span>; t &lt; valueCount; t++) &#123;</div><div class="line">                    deleteIfExists(entry.getCleanFile(t));</div><div class="line">                    deleteIfExists(entry.getDirtyFile(t));</div><div class="line">                &#125;</div><div class="line">                i.remove();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Creates a new journal that omits redundant information. This replaces the</div><div class="line">     * current journal if it exists.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">rebuildJournal</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        <span class="keyword">if</span> (journalWriter != <span class="keyword">null</span>) &#123;</div><div class="line">            journalWriter.close();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        Writer writer = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(journalFileTmp), IO_BUFFER_SIZE);</div><div class="line">        writer.write(MAGIC);</div><div class="line">        writer.write(<span class="string">"\n"</span>);</div><div class="line">        writer.write(VERSION_1);</div><div class="line">        writer.write(<span class="string">"\n"</span>);</div><div class="line">        writer.write(Integer.toString(appVersion));</div><div class="line">        writer.write(<span class="string">"\n"</span>);</div><div class="line">        writer.write(Integer.toString(valueCount));</div><div class="line">        writer.write(<span class="string">"\n"</span>);</div><div class="line">        writer.write(<span class="string">"\n"</span>);</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (Entry entry : lruEntries.values()) &#123;</div><div class="line">            <span class="keyword">if</span> (entry.currentEditor != <span class="keyword">null</span>) &#123;</div><div class="line">                writer.write(DIRTY + <span class="string">' '</span> + entry.key + <span class="string">'\n'</span>);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                writer.write(CLEAN + <span class="string">' '</span> + entry.key + entry.getLengths() + <span class="string">'\n'</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        writer.close();</div><div class="line">        journalFileTmp.renameTo(journalFile);</div><div class="line">        journalWriter = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(journalFile, <span class="keyword">true</span>), IO_BUFFER_SIZE);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deleteIfExists</span><span class="params">(File file)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line"><span class="comment">//        try &#123;</span></div><div class="line"><span class="comment">//            Libcore.os.remove(file.getPath());</span></div><div class="line"><span class="comment">//        &#125; catch (ErrnoException errnoException) &#123;</span></div><div class="line"><span class="comment">//            if (errnoException.errno != OsConstants.ENOENT) &#123;</span></div><div class="line"><span class="comment">//                throw errnoException.rethrowAsIOException();</span></div><div class="line"><span class="comment">//            &#125;</span></div><div class="line"><span class="comment">//        &#125;</span></div><div class="line">        <span class="keyword">if</span> (file.exists() &amp;&amp; !file.delete()) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Returns a snapshot of the entry named &#123;<span class="doctag">@code</span> key&#125;, or null if it doesn't</div><div class="line">     * exist is not currently readable. If a value is returned, it is moved to</div><div class="line">     * the head of the LRU queue.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Snapshot <span class="title">get</span><span class="params">(String key)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        checkNotClosed();</div><div class="line">        validateKey(key);</div><div class="line">        Entry entry = lruEntries.get(key);</div><div class="line">        <span class="keyword">if</span> (entry == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (!entry.readable) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">/*</span></div><div class="line">         * Open all streams eagerly to guarantee that we see a single published</div><div class="line">         * snapshot. If we opened streams lazily then the streams could come</div><div class="line">         * from different edits.</div><div class="line">         */</div><div class="line">        InputStream[] ins = <span class="keyword">new</span> InputStream[valueCount];</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; valueCount; i++) &#123;</div><div class="line">                ins[i] = <span class="keyword">new</span> FileInputStream(entry.getCleanFile(i));</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</div><div class="line">            <span class="comment">// a file must have been deleted manually!</span></div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        redundantOpCount++;</div><div class="line">        journalWriter.append(READ + <span class="string">' '</span> + key + <span class="string">'\n'</span>);</div><div class="line">        <span class="keyword">if</span> (journalRebuildRequired()) &#123;</div><div class="line">            executorService.submit(cleanupCallable);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Snapshot(key, entry.sequenceNumber, ins);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Returns an editor for the entry named &#123;<span class="doctag">@code</span> key&#125;, or null if another</div><div class="line">     * edit is in progress.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> Editor <span class="title">edit</span><span class="params">(String key)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        <span class="keyword">return</span> edit(key, ANY_SEQUENCE_NUMBER);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> Editor <span class="title">edit</span><span class="params">(String key, <span class="keyword">long</span> expectedSequenceNumber)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        checkNotClosed();</div><div class="line">        validateKey(key);</div><div class="line">        Entry entry = lruEntries.get(key);</div><div class="line">        <span class="keyword">if</span> (expectedSequenceNumber != ANY_SEQUENCE_NUMBER</div><div class="line">                &amp;&amp; (entry == <span class="keyword">null</span> || entry.sequenceNumber != expectedSequenceNumber)) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">// snapshot is stale</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (entry == <span class="keyword">null</span>) &#123;</div><div class="line">            entry = <span class="keyword">new</span> Entry(key);</div><div class="line">            lruEntries.put(key, entry);</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (entry.currentEditor != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">// another edit is in progress</span></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        Editor editor = <span class="keyword">new</span> Editor(entry);</div><div class="line">        entry.currentEditor = editor;</div><div class="line"></div><div class="line">        <span class="comment">// flush the journal before creating files to prevent file leaks</span></div><div class="line">        journalWriter.write(DIRTY + <span class="string">' '</span> + key + <span class="string">'\n'</span>);</div><div class="line">        journalWriter.flush();</div><div class="line">        <span class="keyword">return</span> editor;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Returns the directory where this cache stores its data.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> File <span class="title">getDirectory</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> directory;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Returns the maximum number of bytes that this cache should use to store</div><div class="line">     * its data.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">maxSize</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> maxSize;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Returns the number of bytes currently being used to store the values in</div><div class="line">     * this cache. This may be greater than the max size if a background</div><div class="line">     * deletion is pending.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">long</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> size;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">completeEdit</span><span class="params">(Editor editor, <span class="keyword">boolean</span> success)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        Entry entry = editor.entry;</div><div class="line">        <span class="keyword">if</span> (entry.currentEditor != editor) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// if this edit is creating the entry for the first time, every index must have a value</span></div><div class="line">        <span class="keyword">if</span> (success &amp;&amp; !entry.readable) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; valueCount; i++) &#123;</div><div class="line">                <span class="keyword">if</span> (!entry.getDirtyFile(i).exists()) &#123;</div><div class="line">                    editor.abort();</div><div class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"edit didn't create file "</span> + i);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; valueCount; i++) &#123;</div><div class="line">            File dirty = entry.getDirtyFile(i);</div><div class="line">            <span class="keyword">if</span> (success) &#123;</div><div class="line">                <span class="keyword">if</span> (dirty.exists()) &#123;</div><div class="line">                    File clean = entry.getCleanFile(i);</div><div class="line">                    dirty.renameTo(clean);</div><div class="line">                    <span class="keyword">long</span> oldLength = entry.lengths[i];</div><div class="line">                    <span class="keyword">long</span> newLength = clean.length();</div><div class="line">                    entry.lengths[i] = newLength;</div><div class="line">                    size = size - oldLength + newLength;</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                deleteIfExists(dirty);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        redundantOpCount++;</div><div class="line">        entry.currentEditor = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">if</span> (entry.readable | success) &#123;</div><div class="line">            entry.readable = <span class="keyword">true</span>;</div><div class="line">            journalWriter.write(CLEAN + <span class="string">' '</span> + entry.key + entry.getLengths() + <span class="string">'\n'</span>);</div><div class="line">            <span class="keyword">if</span> (success) &#123;</div><div class="line">                entry.sequenceNumber = nextSequenceNumber++;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            lruEntries.remove(entry.key);</div><div class="line">            journalWriter.write(REMOVE + <span class="string">' '</span> + entry.key + <span class="string">'\n'</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (size &gt; maxSize || journalRebuildRequired()) &#123;</div><div class="line">            executorService.submit(cleanupCallable);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * We only rebuild the journal when it will halve the size of the journal</div><div class="line">     * and eliminate at least 2000 ops.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">journalRebuildRequired</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> REDUNDANT_OP_COMPACT_THRESHOLD = <span class="number">2000</span>;</div><div class="line">        <span class="keyword">return</span> redundantOpCount &gt;= REDUNDANT_OP_COMPACT_THRESHOLD</div><div class="line">                &amp;&amp; redundantOpCount &gt;= lruEntries.size();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Drops the entry for &#123;<span class="doctag">@code</span> key&#125; if it exists and can be removed. Entries</div><div class="line">     * actively being edited cannot be removed.</div><div class="line">     *</div><div class="line">     * <span class="doctag">@return</span> true if an entry was removed.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(String key)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        checkNotClosed();</div><div class="line">        validateKey(key);</div><div class="line">        Entry entry = lruEntries.get(key);</div><div class="line">        <span class="keyword">if</span> (entry == <span class="keyword">null</span> || entry.currentEditor != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; valueCount; i++) &#123;</div><div class="line">            File file = entry.getCleanFile(i);</div><div class="line">            <span class="keyword">if</span> (!file.delete()) &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"failed to delete "</span> + file);</div><div class="line">            &#125;</div><div class="line">            size -= entry.lengths[i];</div><div class="line">            entry.lengths[i] = <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        redundantOpCount++;</div><div class="line">        journalWriter.append(REMOVE + <span class="string">' '</span> + key + <span class="string">'\n'</span>);</div><div class="line">        lruEntries.remove(key);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (journalRebuildRequired()) &#123;</div><div class="line">            executorService.submit(cleanupCallable);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Returns true if this cache has been closed.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isClosed</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> journalWriter == <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkNotClosed</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (journalWriter == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"cache is closed"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Force buffered operations to the filesystem.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">flush</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        checkNotClosed();</div><div class="line">        trimToSize();</div><div class="line">        journalWriter.flush();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Closes this cache. Stored values will remain on the filesystem.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        <span class="keyword">if</span> (journalWriter == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span>; <span class="comment">// already closed</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span> (Entry entry : <span class="keyword">new</span> ArrayList&lt;Entry&gt;(lruEntries.values())) &#123;</div><div class="line">            <span class="keyword">if</span> (entry.currentEditor != <span class="keyword">null</span>) &#123;</div><div class="line">                entry.currentEditor.abort();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        trimToSize();</div><div class="line">        journalWriter.close();</div><div class="line">        journalWriter = <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">trimToSize</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        <span class="keyword">while</span> (size &gt; maxSize) &#123;</div><div class="line"><span class="comment">//            Map.Entry&lt;String, Entry&gt; toEvict = lruEntries.eldest();</span></div><div class="line">            <span class="keyword">final</span> Map.Entry&lt;String, Entry&gt; toEvict = lruEntries.entrySet().iterator().next();</div><div class="line">            remove(toEvict.getKey());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Closes the cache and deletes all of its stored values. This will delete</div><div class="line">     * all files in the cache directory including files that weren't created by</div><div class="line">     * the cache.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        close();</div><div class="line">        deleteContents(directory);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">validateKey</span><span class="params">(String key)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (key.contains(<span class="string">" "</span>) || key.contains(<span class="string">"\n"</span>) || key.contains(<span class="string">"\r"</span>)) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</div><div class="line">                    <span class="string">"keys must not contain spaces or newlines: \""</span> + key + <span class="string">"\""</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">inputStreamToString</span><span class="params">(InputStream in)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        <span class="keyword">return</span> readFully(<span class="keyword">new</span> InputStreamReader(in, UTF_8));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * A snapshot of the values for an entry.</div><div class="line">     */</div><div class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Snapshot</span> <span class="keyword">implements</span> <span class="title">Closeable</span> </span>&#123;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">final</span> String key;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> sequenceNumber;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">final</span> InputStream[] ins;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">private</span> <span class="title">Snapshot</span><span class="params">(String key, <span class="keyword">long</span> sequenceNumber, InputStream[] ins)</span> </span>&#123;</div><div class="line">            <span class="keyword">this</span>.key = key;</div><div class="line">            <span class="keyword">this</span>.sequenceNumber = sequenceNumber;</div><div class="line">            <span class="keyword">this</span>.ins = ins;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">/**</span></div><div class="line">         * Returns an editor for this snapshot's entry, or null if either the</div><div class="line">         * entry has changed since this snapshot was created or if another edit</div><div class="line">         * is in progress.</div><div class="line">         */</div><div class="line">        <span class="function"><span class="keyword">public</span> Editor <span class="title">edit</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">            <span class="keyword">return</span> DiskLruCache.<span class="keyword">this</span>.edit(key, sequenceNumber);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">/**</span></div><div class="line">         * Returns the unbuffered stream with the value for &#123;<span class="doctag">@code</span> index&#125;.</div><div class="line">         */</div><div class="line">        <span class="function"><span class="keyword">public</span> InputStream <span class="title">getInputStream</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> ins[index];</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">/**</span></div><div class="line">         * Returns the string value for &#123;<span class="doctag">@code</span> index&#125;.</div><div class="line">         */</div><div class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getString</span><span class="params">(<span class="keyword">int</span> index)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">            <span class="keyword">return</span> inputStreamToString(getInputStream(index));</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">for</span> (InputStream in : ins) &#123;</div><div class="line">                closeQuietly(in);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Edits the values for an entry.</div><div class="line">     */</div><div class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Editor</span> </span>&#123;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Entry entry;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">boolean</span> hasErrors;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">private</span> <span class="title">Editor</span><span class="params">(Entry entry)</span> </span>&#123;</div><div class="line">            <span class="keyword">this</span>.entry = entry;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">/**</span></div><div class="line">         * Returns an unbuffered input stream to read the last committed value,</div><div class="line">         * or null if no value has been committed.</div><div class="line">         */</div><div class="line">        <span class="function"><span class="keyword">public</span> InputStream <span class="title">newInputStream</span><span class="params">(<span class="keyword">int</span> index)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">            <span class="keyword">synchronized</span> (DiskLruCache.<span class="keyword">this</span>) &#123;</div><div class="line">                <span class="keyword">if</span> (entry.currentEditor != <span class="keyword">this</span>) &#123;</div><div class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (!entry.readable) &#123;</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">new</span> FileInputStream(entry.getCleanFile(index));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">/**</span></div><div class="line">         * Returns the last committed value as a string, or null if no value</div><div class="line">         * has been committed.</div><div class="line">         */</div><div class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getString</span><span class="params">(<span class="keyword">int</span> index)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">            InputStream in = newInputStream(index);</div><div class="line">            <span class="keyword">return</span> in != <span class="keyword">null</span> ? inputStreamToString(in) : <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">/**</span></div><div class="line">         * Returns a new unbuffered output stream to write the value at</div><div class="line">         * &#123;<span class="doctag">@code</span> index&#125;. If the underlying output stream encounters errors</div><div class="line">         * when writing to the filesystem, this edit will be aborted when</div><div class="line">         * &#123;<span class="doctag">@link</span> #commit&#125; is called. The returned output stream does not throw</div><div class="line">         * IOExceptions.</div><div class="line">         */</div><div class="line">        <span class="function"><span class="keyword">public</span> OutputStream <span class="title">newOutputStream</span><span class="params">(<span class="keyword">int</span> index)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">            <span class="keyword">synchronized</span> (DiskLruCache.<span class="keyword">this</span>) &#123;</div><div class="line">                <span class="keyword">if</span> (entry.currentEditor != <span class="keyword">this</span>) &#123;</div><div class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">new</span> FaultHidingOutputStream(<span class="keyword">new</span> FileOutputStream(entry.getDirtyFile(index)));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">/**</span></div><div class="line">         * Sets the value at &#123;<span class="doctag">@code</span> index&#125; to &#123;<span class="doctag">@code</span> value&#125;.</div><div class="line">         */</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, String value)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">            Writer writer = <span class="keyword">null</span>;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                writer = <span class="keyword">new</span> OutputStreamWriter(newOutputStream(index), UTF_8);</div><div class="line">                writer.write(value);</div><div class="line">            &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                closeQuietly(writer);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">/**</span></div><div class="line">         * Commits this edit so it is visible to readers.  This releases the</div><div class="line">         * edit lock so another edit may be started on the same key.</div><div class="line">         */</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">            <span class="keyword">if</span> (hasErrors) &#123;</div><div class="line">                completeEdit(<span class="keyword">this</span>, <span class="keyword">false</span>);</div><div class="line">                remove(entry.key); <span class="comment">// the previous entry is stale</span></div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                completeEdit(<span class="keyword">this</span>, <span class="keyword">true</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">/**</span></div><div class="line">         * Aborts this edit. This releases the edit lock so another edit may be</div><div class="line">         * started on the same key.</div><div class="line">         */</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">abort</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">            completeEdit(<span class="keyword">this</span>, <span class="keyword">false</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">FaultHidingOutputStream</span> <span class="keyword">extends</span> <span class="title">FilterOutputStream</span> </span>&#123;</div><div class="line">            <span class="function"><span class="keyword">private</span> <span class="title">FaultHidingOutputStream</span><span class="params">(OutputStream out)</span> </span>&#123;</div><div class="line">                <span class="keyword">super</span>(out);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> oneByte)</span> </span>&#123;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    out.write(oneByte);</div><div class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">                    hasErrors = <span class="keyword">true</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">byte</span>[] buffer, <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span> </span>&#123;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    out.write(buffer, offset, length);</div><div class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">                    hasErrors = <span class="keyword">true</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    out.close();</div><div class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">                    hasErrors = <span class="keyword">true</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flush</span><span class="params">()</span> </span>&#123;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    out.flush();</div><div class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">                    hasErrors = <span class="keyword">true</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> </span>&#123;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">final</span> String key;</div><div class="line"></div><div class="line">        <span class="comment">/**</span></div><div class="line">         * Lengths of this entry's files.</div><div class="line">         */</div><div class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span>[] lengths;</div><div class="line"></div><div class="line">        <span class="comment">/**</span></div><div class="line">         * True if this entry has ever been published</div><div class="line">         */</div><div class="line">        <span class="keyword">private</span> <span class="keyword">boolean</span> readable;</div><div class="line"></div><div class="line">        <span class="comment">/**</span></div><div class="line">         * The ongoing edit or null if this entry is not being edited.</div><div class="line">         */</div><div class="line">        <span class="keyword">private</span> Editor currentEditor;</div><div class="line"></div><div class="line">        <span class="comment">/**</span></div><div class="line">         * The sequence number of the most recently committed edit to this entry.</div><div class="line">         */</div><div class="line">        <span class="keyword">private</span> <span class="keyword">long</span> sequenceNumber;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">private</span> <span class="title">Entry</span><span class="params">(String key)</span> </span>&#123;</div><div class="line">            <span class="keyword">this</span>.key = key;</div><div class="line">            <span class="keyword">this</span>.lengths = <span class="keyword">new</span> <span class="keyword">long</span>[valueCount];</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getLengths</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">            StringBuilder result = <span class="keyword">new</span> StringBuilder();</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">long</span> size : lengths) &#123;</div><div class="line">                result.append(<span class="string">' '</span>).append(size);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> result.toString();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">/**</span></div><div class="line">         * Set lengths using decimal numbers like "10123".</div><div class="line">         */</div><div class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setLengths</span><span class="params">(String[] strings)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">            <span class="keyword">if</span> (strings.length != valueCount) &#123;</div><div class="line">                <span class="keyword">throw</span> invalidLengths(strings);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strings.length; i++) &#123;</div><div class="line">                    lengths[i] = Long.parseLong(strings[i]);</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</div><div class="line">                <span class="keyword">throw</span> invalidLengths(strings);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">private</span> IOException <span class="title">invalidLengths</span><span class="params">(String[] strings)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"unexpected journal line: "</span> + Arrays.toString(strings));</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> File <span class="title">getCleanFile</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> File(directory, key + <span class="string">"."</span> + i);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> File <span class="title">getDirtyFile</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> File(directory, key + <span class="string">"."</span> + i + <span class="string">".tmp"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>​</p>
<p>首先你要知道，DiskLruCache是不能new出实例的，如果我们要创建一个DiskLruCache的实例，则需要调用它的open()方法，接口如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DiskLruCache <span class="title">open</span><span class="params">(File directory, <span class="keyword">int</span> appVersion, <span class="keyword">int</span> valueCount, <span class="keyword">long</span> maxSize)</span></span></div></pre></td></tr></table></figure>
<h4 id="DiskCache-DiskLruCache"><a href="#DiskCache-DiskLruCache" class="headerlink" title="DiskCache(DiskLruCache )"></a>DiskCache(DiskLruCache )</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.losileeya.imageloader.ImageLoder;</div><div class="line"></div><div class="line"><span class="keyword">import</span> android.content.Context;</div><div class="line"><span class="keyword">import</span> android.graphics.Bitmap;</div><div class="line"><span class="keyword">import</span> android.graphics.BitmapFactory;</div><div class="line"><span class="keyword">import</span> android.os.Environment;</div><div class="line"></div><div class="line"><span class="keyword">import</span> com.losileeya.imageloader.utils.DiskLruCache;</div><div class="line"><span class="keyword">import</span> com.losileeya.imageloader.utils.Md5Encoder;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"><span class="keyword">import</span> java.io.InputStream;</div><div class="line"><span class="keyword">import</span> java.io.OutputStream;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * User: Losileeya (847457332@qq.com)</div><div class="line"> * Date: 2016-08-31</div><div class="line"> * Time: 10:50</div><div class="line"> * 类描述：DiskLruCache</div><div class="line"> *</div><div class="line"> * <span class="doctag">@version</span> :</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DiskCache</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> DiskLruCache mCache;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 打开DiskLruCache。</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">openCache</span><span class="params">(Context context)</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">if</span> (Environment.MEDIA_MOUNTED.equals(Environment.getExternalStorageState())</div><div class="line">                    || !Environment.isExternalStorageRemovable()) &#123;</div><div class="line">                mCache = DiskLruCache.open(context.getExternalCacheDir(), <span class="number">0</span>, <span class="number">1</span>, <span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span>);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                mCache = DiskLruCache.open(context.getCacheDir(), <span class="number">0</span>, <span class="number">1</span>, <span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span>);</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 把图片写入disk内存</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">putBitmapToDisk</span><span class="params">(Bitmap bitmap, String keyCache)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="keyword">if</span> (mCache == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Must call openCache() first!"</span>);</div><div class="line"></div><div class="line">        DiskLruCache.Editor editor = mCache.edit(Md5Encoder.encode(keyCache));</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (editor != <span class="keyword">null</span>) &#123;</div><div class="line">            OutputStream outputStream = editor.newOutputStream(<span class="number">0</span>);</div><div class="line">            <span class="keyword">boolean</span> success = bitmap.compress(Bitmap.CompressFormat.PNG, <span class="number">100</span>, outputStream);</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (success) &#123;</div><div class="line">                editor.commit();</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                editor.abort();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 从disk中获取图片</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Bitmap <span class="title">getBitmapFormDisk</span><span class="params">(String keyCache)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="keyword">if</span> (mCache == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Must call openCache() first!"</span>);</div><div class="line"></div><div class="line">        DiskLruCache.Snapshot snapshot = mCache.get(Md5Encoder.encode(keyCache));</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (snapshot != <span class="keyword">null</span>) &#123;</div><div class="line">            InputStream inputStream = snapshot.getInputStream(<span class="number">0</span>);</div><div class="line">            Bitmap bitmap = BitmapFactory.decodeStream(inputStream);</div><div class="line">            <span class="keyword">return</span> bitmap;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 检查缓存是否存在。</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">hasCache</span><span class="params">(String keyCache)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">return</span> mCache.get(Md5Encoder.encode(keyCache)) != <span class="keyword">null</span>;</div><div class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 同步日志。</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">syncLog</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            mCache.flush();</div><div class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 关闭DiskLruCache。</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">closeCache</span><span class="params">()</span> </span>&#123;</div><div class="line">        syncLog();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>好了缓存代码都手把手的写完了，使用很简单</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.losileeya.imageloader;</div><div class="line"></div><div class="line"><span class="keyword">import</span> android.os.Bundle;</div><div class="line"><span class="keyword">import</span> android.support.v7.app.AppCompatActivity;</div><div class="line"><span class="keyword">import</span> android.widget.ImageView;</div><div class="line"><span class="keyword">import</span> android.widget.LinearLayout;</div><div class="line"><span class="keyword">import</span> android.widget.RelativeLayout;</div><div class="line"></div><div class="line"><span class="keyword">import</span> com.losileeya.imageloader.ImageLoder.ImageLoder;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_main);</div><div class="line">        RelativeLayout rl= (RelativeLayout) findViewById(R.id.bg);</div><div class="line">        ImageView iv=<span class="keyword">new</span> ImageView(<span class="keyword">this</span>);</div><div class="line">        iv.setLayoutParams(<span class="keyword">new</span> LinearLayout.LayoutParams(getWindow().getAttributes().width,getWindow().getAttributes().height));</div><div class="line">        rl.addView(iv);</div><div class="line">        <span class="keyword">new</span> ImageLoder(<span class="keyword">this</span>).disPlayImage(iv,<span class="string">"http://img.my.csdn.net/uploads/201309/01/1378037235_7476.jpg"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>就一句话ImageLoder(this).disPlayImage(iv,”<a href="http://img.my.csdn.net/uploads/201309/01/1378037235_7476.jpg" target="_blank" rel="external">http://img.my.csdn.net/uploads/201309/01/1378037235_7476.jpg</a>“);</p>
<p>好了，demo就不上传了，所有的代码附上面了，看下效果吧：</p>
<p><img src="http://i.imgur.com/bu0KnAT.jpg" alt=""></p>
<p>当然别忘了添加所需权限：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;uses-permission android:name=<span class="string">"android.permission.INTERNET"</span>/&gt;</div><div class="line">&lt;uses-permission android:name=<span class="string">"android.permission.ACCESS_WIFI_STATE"</span>/&gt;</div><div class="line">&lt;uses-permission android:name=<span class="string">"android.permission.ACCESS_NETWORK_STATE"</span>/&gt;</div><div class="line">&lt;uses-permission android:name=<span class="string">"android.permission.CHANGE_WIFI_STATE"</span>/&gt;</div><div class="line">&lt;uses-permission android:name=<span class="string">"android.permission.WRITE_EXTERNAL_STORAGE"</span>/&gt;</div></pre></td></tr></table></figure>
<p>​</p>
<p>​</p>
<p>​</p>
</li>
</ul>
<hr>
<p>未经许可不得转载，转载请注明zilianliuxue的blog,本人保留所有版权。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;现在的Android应用程序中，不可避免的都会使用到图片，如果每次加载图片的时候都要从网络重新拉取，这样不但很耗费用户的流量，而且图片加载的
    
    </summary>
    
      <category term="android" scheme="http://zilianliuxue.github.io/categories/android/"/>
    
    
      <category term="Cache" scheme="http://zilianliuxue.github.io/tags/Cache/"/>
    
  </entry>
  
  <entry>
    <title>Android的线程和线程池</title>
    <link href="http://zilianliuxue.github.io/2016/08/26/Android%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>http://zilianliuxue.github.io/2016/08/26/Android的线程和线程池/</id>
    <published>2016-08-26T06:35:26.963Z</published>
    <updated>2016-08-27T03:17:59.175Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>在操作系统中，线程是操作系统调度的最小单元，当系统中存在大量线程时，系统会通过时间片轮转的方式调度每个线程，当进程中频繁的创建和销毁线程的时候应该采用线程池，线程池会缓存一定数量的线程，避免频繁创建和销毁线程带来的系统开销。</p>
</blockquote>
<h2 id="主线程和子线程"><a href="#主线程和子线程" class="headerlink" title="主线程和子线程"></a>主线程和子线程</h2><p>(1) 在Java中默认情况下一个进程只有一个线程，也就是主线程，其他线程都是子线程，也叫工作线程。Android中的主线程主要处理和界面相关的事情，而子线程则往往用于执行耗时操作。线程的创建和销毁的开销较大，所以如果一个进程要频繁地创建和销毁线程的话，都会采用线程池的方式。</p>
<p>(2) 在Android中除了Thread，还有HandlerThread、AsyncTask以及IntentService等也都扮演着线程的角色，只是它们具有不同的特性和使用场景。AsyncTask封装了线程池和Handler，它主要是为了方便开发者在子线程中更新UI。HandlerThread是一种具有消息循环的线程，在它的内部可以使用Handler。IntentService是一个服务，它内部采用HandlerThread来执行任务，当任务执行完毕后就会自动退出。因为它是服务的缘故，所以和后台线程相比，它比较不容易被系统杀死。</p>
<p>(3). 从Android 3.0开始，系统要求网络访问必须在子线程中进行，否则网络访问将会失败并抛出NetworkOnMainThreadException这个异常，这样做是为了避免主线程由于被耗时操作所阻塞从而出现ANR现象。</p>
<h2 id="Android中的线程形态"><a href="#Android中的线程形态" class="headerlink" title="Android中的线程形态"></a>Android中的线程形态</h2><h3 id="AsyncTask"><a href="#AsyncTask" class="headerlink" title="AsyncTask"></a>AsyncTask</h3><p>AsyncTask是一个抽象泛型类，它提供了Params、Progress、Result三个泛型参数，如果task确实不需要传递具体的参数，那么都可以设置为Void。下面是它的四个核心方法，其中doInBackground不是在主线程执行的。<br>onPreExecute、doInBackground、onProgressUpdate、onPostResult</p>
<h4 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h4><ul>
<li>AsyncTask必须在主线程中加载</li>
<li>必须在主线程中创建</li>
<li>execute必须在UI线程调用</li>
<li>一个AsyncTask对象只能执行一次，即只能调用一次execute方法</li>
<li>在Android1.6的时候线程池是并行任务，在Android3.0为了避免并发错误采用串行执行任务。但是我们仍然可以用过executeOnExecutor方法并行执行任务。</li>
</ul>
<h3 id="HandlerThread"><a href="#HandlerThread" class="headerlink" title="HandlerThread"></a>HandlerThread</h3><p>它继承了Thread，是一种可以使用Handler的Thread.他的实现也很简单，就是在run方法中通过Looper。prepare来创建消息队列，并通过Looper.loop来开启消息循环，这样在使用的时候就可以在HandlerThread中创建Handler了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public void run() &#123;</div><div class="line">    mTid = Process.myTid();</div><div class="line">    Looper.prepare();</div><div class="line">    synchronized (this) &#123;</div><div class="line">        mLooper = Looper.myLooper();</div><div class="line">        notifyAll();</div><div class="line">    &#125;</div><div class="line">    Process.setThreadPriority(mPriority);</div><div class="line">    onLooperPrepared();</div><div class="line">    Looper.loop();</div><div class="line">    mTid = -1;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>HandlerThread在内部创建了消息队列，外界需要通过Handler的消息方式开通知它执行一个具体的任务，它的一个具体实现是IntentService。当我们不需要使用Handler的时候可以通过quit获取quitSafelt方法终结线程的执行。</p>
<h3 id="IntentService"><a href="#IntentService" class="headerlink" title="IntentService"></a>IntentService</h3><p>继承了Service是一个抽象类，必须创建它的子类才可以使用它，IntentService可以执行后台耗时任务，当任务执行完毕之后会自动停止，因为他是服务，所以他的优先级比普通的线程高，比较适合执行一些高优先级的后台任务。</p>
<h2 id="Android中的线程池"><a href="#Android中的线程池" class="headerlink" title="Android中的线程池"></a>Android中的线程池</h2><blockquote>
<p>Android里面，耗时的网络操作，都会开子线程，在程序里面直接开过多的线程会消耗过多的资源，在众多的开源框架中也总能看到线程池的踪影，所以线程池是必须要会把握的一个知识点;</p>
</blockquote>
<h4 id="线程池的优点："><a href="#线程池的优点：" class="headerlink" title="线程池的优点："></a>线程池的优点：</h4><ul>
<li>重用线程池中的线程，避免频繁创建和销毁带来的性能开销</li>
<li>可以有效控制线程池中的最大并发数，避免大量线程之间互相抢占系统资源导致阻塞</li>
<li>可以对线程进行简单管理。</li>
</ul>
<h4 id="线程运行机制"><a href="#线程运行机制" class="headerlink" title="线程运行机制"></a>线程运行机制</h4><ul>
<li>开启线程过多，会消耗<code>cpu资源</code></li>
<li>单核cpu，同一时刻只能处理一个线程，多核cpu同一时刻可以处理多个线程</li>
<li>操作系统为每个运行线程安排一定的CPU时间—-<code>时间片</code>，系统通过一种循环的方式为线程提供时间片，线程在自己的时间内运行，因为时间相当短，多个线程频繁地发生切换，因此给用户的感觉就是好像多个线程同时运行一样，但是如果计算机有多个CPU，线程就能真正意义上的同时运行了.</li>
</ul>
<h4 id="线程池的作用"><a href="#线程池的作用" class="headerlink" title="线程池的作用"></a>线程池的作用</h4><ul>
<li>线程池是预先创建线程的一种技术。线程池在还没有任务到来之前，创建一定数量的线程，放入空闲队列中，然后对这些资源进行复用。<code>减少频繁的创建和销毁对象。</code></li>
<li>频繁创建和销毁线程耗资源，耗时间</li>
<li>因为有的线程执行时间比创建和销毁一个线程的时间还短</li>
</ul>
<h4 id="线程池涉及的类"><a href="#线程池涉及的类" class="headerlink" title="线程池涉及的类"></a>线程池涉及的类</h4><ul>
<li>Executor:Java里面线程池的顶级接口。</li>
<li>ExecutorService:真正的线程池接口。</li>
<li>ScheduledExecutorService:能和Timer/TimerTask类似，解决那些需要任务重复执行的问题。</li>
<li>ThreadPoolExecutor(重点):ExecutorService的默认实现。</li>
<li>ScheduledThreadPoolExecutor:继承ThreadPoolExecutor的ScheduledExecutorService接口实现，周期性任务调度的类实现。</li>
<li>Executors:可以一行代码创建一些常见的线程池。</li>
</ul>
<h3 id="Executors介绍（把握使用，把握常见线程池）"><a href="#Executors介绍（把握使用，把握常见线程池）" class="headerlink" title="Executors介绍（把握使用，把握常见线程池）"></a>Executors介绍（把握使用，把握常见线程池）</h3><blockquote>
<p>Executors:jdk1.5之后的一个新类，<code>提供了一些静态方法，帮助我们方便的生成一些常用的线程池</code>，ThreadPoolExecutor是Executors类的底层实现</p>
</blockquote>
<p>1.newSingleThreadExecutor</p>
<blockquote>
<p>创建一个单线程的线程池。这个线程池只有一个线程在工作，也就是相当于单线程串行执行&gt;所有任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池&gt;保证所有任务的执行顺序按照任务的提交顺序执行。</p>
</blockquote>
<p>2.newFixedThreadPool</p>
<blockquote>
<p>创建固定大小的线程池。每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。</p>
</blockquote>
<p>3.newCachedThreadPool</p>
<blockquote>
<p>创建一个可缓存的线程池。如果线程池的大小超过了处理任务所需要的线程，<br>那么就会回收部分空闲（60秒不执行任务）的线程，当任务数增加时，此线程池又可以智能的添加新线程来处理任务。此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小。</p>
</blockquote>
<p>4.newScheduledThreadPool</p>
<blockquote>
<p>创建一个大小无限的线程池。此线程池支持定时以及周期性执行任务的需求。</p>
</blockquote>
<h4 id="ThreadPoolExecutor介绍"><a href="#ThreadPoolExecutor介绍" class="headerlink" title="ThreadPoolExecutor介绍"></a>ThreadPoolExecutor介绍</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//构造方法</div><div class="line">public ThreadPoolExecutor(int corePoolSize，//核心池的大小</div><div class="line">                              int maximumPoolSize，//线程池最大线程数</div><div class="line">                              long keepAliveTime，//保持时间</div><div class="line">                              TimeUnit unit，//时间单位</div><div class="line">                              BlockingQueue&lt;Runnable&gt; workQueue，//任务队列</div><div class="line">                              ThreadFactory threadFactory，//线程工厂</div><div class="line">                              RejectedExecutionHandler handler) //异常的捕捉器</div></pre></td></tr></table></figure>
<h4 id="构造相关参数解释"><a href="#构造相关参数解释" class="headerlink" title="构造相关参数解释"></a>构造相关参数解释</h4><ul>
<li><p>corePoolSize：<code>核心池的大小</code>，这个参数跟后面讲述的线程池的实现原理有非常大的关系。在创建了线程池后，默认情况下，线程池中并没有任何线程，而是等待有任务到来才创建线程去执行任务，除非调用了prestartAllCoreThreads()或者prestartCoreThread()方法，从这2个方法的名字就可以看出，是预创建线程的意思，即在没有任务到来之前就创建corePoolSize个线程或者一个线程。默认情况下，在创建了线程池后，线程池中的线程数为0，当有任务来之后，就会创建一个线程去执行任务，当线程池中的线程数目达到corePoolSize后，就会把到达的任务放到缓存队列当中；</p>
</li>
<li><p>maximumPoolSize：<code>’线程池最大线程数</code>，<br>这个参数也是一个非常重要的参数，它表示在线程池中最多能创建多少个线程；</p>
</li>
<li><p>keepAliveTime：<code>表示线程没有任务执行时最多保持多久时间会终止</code>。默认情况下，只有当线程池中的线程数大于corePoolSize时，keepAliveTime才会起作用，直到线程池中的线程数不大于corePoolSize，即当线程池中的线程数大于corePoolSize时，如果一个线程空闲的时间达到keepAliveTime，则会终止，直到线程池中的线程数不超过corePoolSize。但是如果调用了allowCoreThreadTimeOut(boolean)方法，在线程池中的线程数不大于corePoolSize时，keepAliveTime参数也会起作用，直到线程池中的线程数为0；</p>
</li>
<li><p>unit：参数keepAliveTime的<code>时间单位</code>，有7种取值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">TimeUnit.DAYS;               //天</div><div class="line">TimeUnit.HOURS;             //小时</div><div class="line">TimeUnit.MINUTES;           //分钟</div><div class="line">TimeUnit.SECONDS;           //秒</div><div class="line">TimeUnit.MILLISECONDS;      //毫秒</div><div class="line">TimeUnit.MICROSECONDS;      //微妙</div><div class="line">TimeUnit.NANOSECONDS;       //纳秒</div></pre></td></tr></table></figure>
</li>
<li><p>workQueue ： <code>任务队列</code>，是一个阻塞队列，用来存储等待执行的任务，这个参数的选择也很重要，会对线程池的运行过程产生重大影响，参考BlockingQueue</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ArrayBlockingQueue</div><div class="line">LinkedBlockingQueue</div><div class="line">SynchronousQueue</div></pre></td></tr></table></figure>
</li>
<li><p>threadFactory : <code>线程工厂</code>，如何去创建线程的</p>
</li>
<li><p>handler ： 任务队列添加<code>异常的捕捉器</code>，参考 RejectedExecutionHandler</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常。 </div><div class="line">ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。 </div><div class="line">ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）</div><div class="line">ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="基础API的介绍"><a href="#基础API的介绍" class="headerlink" title="基础API的介绍"></a>基础API的介绍</h4><ul>
<li>isShutdown() ： 判断线程池是否关闭</li>
<li>isTerminated() : 判断线程池中任务是否执行完成</li>
<li>shutdown() : 调用后不再接收新任务，如果里面有任务，就执行完</li>
<li>shutdownNow() : 调用后不再接受新任务，如果有等待任务，移出队列；有正在执行的，尝试停止之</li>
<li>submit() : 提交执行任务</li>
<li>execute() : 执行任务</li>
</ul>
<h4 id="任务提交给线程池之后的处理策略"><a href="#任务提交给线程池之后的处理策略" class="headerlink" title="任务提交给线程池之后的处理策略"></a>任务提交给线程池之后的处理策略</h4><ol>
<li>如果当前线程池中的线程数目小于corePoolSize，则每来一个任务，就会创建执行这个任务；</li>
<li>如果当前线程池中的线程数目&gt;=corePoolSize，则每来一个任务，会尝试将其添加到任务缓存队列当中<ol>
<li>若添加成功，则该任务会等待空闲线程将其取出去执行；</li>
<li>若添加失败（一般来说是任务缓存队列已满，针对的是有界队列），则会尝试创建新的线程去执行这个任务；</li>
</ol>
</li>
<li>如果当前线程池中的线程数目达到maximumPoolSize，则会采取任务拒绝策略进行处理；</li>
<li>如果线程池中的线程数量大于 corePoolSize时，如果某线程空闲时间超过keepAliveTime，线程将被终止，直至线程池中的线程数目不大于corePoolSize；如果允许为核心池中的线程设置存活时间，那么核心池中的线程空闲时间超过keepAliveTime，线程也会被终止。</li>
</ol>
<h3 id="阻塞队列的介绍（BlockingQueue）"><a href="#阻塞队列的介绍（BlockingQueue）" class="headerlink" title="阻塞队列的介绍（BlockingQueue）"></a>阻塞队列的介绍（BlockingQueue）</h3><p>阻塞队列，如果BlockingQueue是空的，从BlockingQueue取东西的操作将会被阻断进入等待状态，直到BlockingQueue进了东西才会被唤醒，同样，如果BlockingQueue是满的，任何试图往里存东西的操作也会被阻断进入等待状态，直到BlockingQueue里有空间时才会被唤醒继续操作。</p>
<ol>
<li>基础API介绍<ul>
<li>往队列中加元素的方法<ul>
<li>add(E) : 非阻塞方法， 把元素加到BlockingQueue里，如果BlockingQueue可以容纳，则返回true，否则抛出异常。</li>
<li>offer(E) : 非阻塞， 表示如果可能的话，将元素加到BlockingQueue里，即如果BlockingQueue可以容纳，则返回true，否则返回false。</li>
<li>put(E)：阻塞方法， 把元素加到BlockingQueue里，如果BlockingQueue没有空间，则调用此方法的线程被阻断直到BlockingQueue里有空间再继续。</li>
</ul>
</li>
<li>从队列中取元素的方法<ul>
<li>poll(time)： 阻塞方法，取走BlockingQueue里排在首位的元素，若不能立即取出，则可以等time参数规定的时间，取不到时返回null。</li>
<li>take()：取走BlockingQueue里排在首位的对象，若BlockingQueue为空，阻断进入等待状态直到BlockingQueue有新的对象被加入为止。</li>
</ul>
</li>
</ul>
</li>
<li>子类介绍<ul>
<li><code>ArrayBlockingQueue(有界队列)</code>： FIFO 队列，规定大小的BlockingQueue，其构造函数必须带一个int参数来指明其大小</li>
<li><code>LinkedBlockingQueue(无界队列)</code>：FIFO 队列，大小不定的BlockingQueue，若其构造函数带一个规定大小的参数，生成的BlockingQueue有大小限制，若不带大小参数，所生成的BlockingQueue的大小由Integer.MAX_VALUE来决定。</li>
<li><code>PriorityBlockingQueue</code>：优先级队列， 类似于LinkedBlockingQueue，但队列中元素非 FIFO， 依据对象的自然排序顺序或者是构造函数所带的Comparator决定的顺序</li>
<li><code>SynchronousQueue(直接提交策略)</code>: 交替队列，<code>队列中操作时必须是先放进去，接着取出来</code>，交替着去处理元素的添加和移除，这是一个很有意思的阻塞队列，其中每个插入操作必须等待另一个线程的移除操作，同样任何一个移除操作都等待另一个线程的插入操作。因此此队列内部其 实没有任何一个元素，或者说容量是0，严格说并不是一种容器。由于队列没有容量，因此不能调用peek操作，因为只有移除元素时才有元素。</li>
</ul>
</li>
</ol>
<hr>
<p>未经许可不得转载，转载请注明zilianliuxue的blog,本人保留所有版权。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;在操作系统中，线程是操作系统调度的最小单元，当系统中存在大量线程时，系统会通过时间片轮转的方式调度每个线程，当进程中频繁的创建和销毁线程的时候应该采用线程池，线程池会缓存一定数量的线程，避免频繁创建和销毁线程带来的系统开销。&lt;/p&gt;
&lt;/block
    
    </summary>
    
      <category term="android" scheme="http://zilianliuxue.github.io/categories/android/"/>
    
    
      <category term="线程池" scheme="http://zilianliuxue.github.io/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>java 线程池</title>
    <link href="http://zilianliuxue.github.io/2016/08/25/java%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>http://zilianliuxue.github.io/2016/08/25/java线程池/</id>
    <published>2016-08-25T12:30:16.351Z</published>
    <updated>2016-08-26T06:36:04.716Z</updated>
    
    <content type="html"><![CDATA[<p>线程池：基本思想还是一种对象池的思想，开辟一块内存空间，里面存放了众多(未死亡)的线程，池中线程执行调度由池管理器来处理。当有线程任务时，从池中取一个，执行完成后线程对象归池，这样可以避免反复创建线程对象所带来的性能开销，节省了系统的资源。</p>
<h1 id="ExecutorService"><a href="#ExecutorService" class="headerlink" title="ExecutorService"></a><strong>ExecutorService</strong></h1><p>通过上述分析，我们知道了通过new Thread().start()方式创建线程去处理任务的弊端，而为了解决这些问题，Java为我们提供了ExecutorService线程池来优化和管理线程的使用</p>
<h2 id="使用线程池管理线程的优点"><a href="#使用线程池管理线程的优点" class="headerlink" title="使用线程池管理线程的优点"></a><strong>使用线程池管理线程的优点</strong></h2><blockquote>
<p>1、线程的创建和销毁由线程池维护，一个线程在完成任务后并不会立即销毁，而是由后续的任务复用这个线程，从而减少线程的创建和销毁，节约系统的开销</p>
<p>2、线程池旨在线程的复用，这就可以节约我们用以往的方式创建线程和销毁所消耗的时间，减少线程频繁调度的开销，从而节约系统资源，提高系统吞吐量</p>
<p>3、在执行大量异步任务时提高了性能</p>
<p>4、Java内置的一套ExecutorService线程池相关的api，可以更方便的控制线程的最大并发数、线程的定时任务、单线程的顺序执行等</p>
</blockquote>
<h2 id="ExecutorService简介"><a href="#ExecutorService简介" class="headerlink" title="ExecutorService简介"></a><strong>ExecutorService简介</strong></h2><p>通常来说我们说到线程池第一时间想到的就是它：ExecutorService，它是一个接口，其实如果要从真正意义上来说，它可以叫做线程池的服务，因为它提供了众多接口api来控制线程池中的线程，而真正意义上的线程池就是：ThreadPoolExecutor，它实现了ExecutorService接口，并封装了一系列的api使得它具有线程池的特性，其中包括工作队列、核心线程数、最大线程数等。</p>
<h3 id="线程池：ThreadPoolExecutor"><a href="#线程池：ThreadPoolExecutor" class="headerlink" title="线程池：ThreadPoolExecutor"></a><strong>线程池：ThreadPoolExecutor</strong></h3><p>既然线程池就是ThreadPoolExecutor，所以我们要创建一个线程池只需要new ThreadPoolExecutor(…);就可以创建一个线程池，而如果这样创建线程池的话，我们需要配置一堆东西，非常麻烦，我们可以看一下它的构造方法就知道了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public ThreadPoolExecutor(int corePoolSize,</div><div class="line">                              int maximumPoolSize,</div><div class="line">                              long keepAliveTime,</div><div class="line">                              TimeUnit unit,</div><div class="line">                              BlockingQueue&lt;Runnable&gt; workQueue,</div><div class="line">                              ThreadFactory threadFactory,</div><div class="line">                              RejectedExecutionHandler handler) &#123;...&#125;1234567</div></pre></td></tr></table></figure>
<p>所以，官方也不推荐使用这种方法来创建线程池，而是推荐使用<strong>Executors</strong>的工厂方法来创建线程池，<strong>Executors</strong>类是官方提供的一个工厂类，它里面封装好了众多功能不一样的线程池，从而使得我们创建线程池非常的简便，主要提供了如下五种功能不一样的线程池：</p>
<blockquote>
<p><strong>1、newFixedThreadPool() ：</strong><br>作用：该方法返回一个固定线程数量的线程池，该线程池中的线程数量始终不变，即不会再创建新的线程，也不会销毁已经创建好的线程，自始自终都是那几个固定的线程在工作，所以该线程池可以控制线程的最大并发数。<br>栗子：假如有一个新任务提交时，线程池中如果有空闲的线程则立即使用空闲线程来处理任务，如果没有，则会把这个新任务存在一个任务队列中，一旦有线程空闲了，则按FIFO方式处理任务队列中的任务。</p>
<p><strong>2、newCachedThreadPool() ：</strong><br>作用：该方法返回一个可以根据实际情况调整线程池中线程的数量的线程池。即该线程池中的线程数量不确定，是根据实际情况动态调整的。<br>栗子：假如该线程池中的所有线程都正在工作，而此时有新任务提交，那么将会创建新的线程去处理该任务，而此时假如之前有一些线程完成了任务，现在又有新任务提交，那么将不会创建新线程去处理，而是复用空闲的线程去处理新任务。那么此时有人有疑问了，那这样来说该线程池的线程岂不是会越集越多？其实并不会，因为线程池中的线程都有一个“保持活动时间”的参数，通过配置它，如果线程池中的空闲线程的空闲时间超过该“保存活动时间”则立刻停止该线程，而该线程池默认的“保持活动时间”为60s。</p>
<p><strong>3、newSingleThreadExecutor() ：</strong><br>作用：该方法返回一个只有一个线程的线程池，即每次只能执行一个线程任务，多余的任务会保存到一个任务队列中，等待这一个线程空闲，当这个线程空闲了再按FIFO方式顺序执行任务队列中的任务。</p>
<p><strong>4、newScheduledThreadPool() ：</strong><br>作用：该方法返回一个可以控制线程池内线程定时或周期性执行某任务的线程池。</p>
<p><strong>5、newSingleThreadScheduledExecutor() ：</strong><br>作用：该方法返回一个可以控制线程池内线程定时或周期性执行某任务的线程池。只不过和上面的区别是该线程池大小为1，而上面的可以指定线程池的大小。</p>
</blockquote>
<p>好了，写了一堆来介绍这五种线程池的作用，接下来就是获取这五种线程池，通过<strong>Executors</strong>的工厂方法来获取：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ExecutorService fixedThreadPool = Executors.newFixedThreadPool(5);</div><div class="line">ExecutorService singleThreadPool = Executors.newSingleThreadExecutor();</div><div class="line">ExecutorService cachedThreadPool = Executors.newCachedThreadPool();</div><div class="line">ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(5);</div><div class="line">ScheduledExecutorService singleThreadScheduledPool = Executors.newSingleThreadScheduledExecutor();12345</div></pre></td></tr></table></figure>
<p>Executors 提供四种线程池：</p>
<ul>
<li>1）newCachedThreadPool 是一个可根据需要创建新线程的线程池，但是在以前构造的线程可用时将重用它们。对于执行很多短期异步任务的程序而言，这些线程池通常可提高程序性能。调用 execute() 将重用以前构造的线程（如果线程可用）。如果现有线程没有可用的，则创建一个新线程并添加到池中。终止并从缓存中移除那些已有 60 秒钟未被使用的线程。因此，长时间保持空闲的线程池不会使用任何资源。注意，可以使用 ThreadPoolExecutor 构造方法创建具有类似属性但细节不同（例如超时参数）的线程池。</li>
<li>2）newSingleThreadExecutor 创建是一个单线程池，也就是该线程池只有一个线程在工作，所有的任务是串行执行的，如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它，此线程池保证所有任务的执行顺序按照任务的提交顺序执行。</li>
<li>3）newFixedThreadPool 创建固定大小的线程池，每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小，线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。</li>
<li>4）newScheduledThreadPool 创建一个大小无限的线程池，此线程池支持定时以及周期性执行任务的需求。</li>
</ul>
<p>我们可以看到通过<strong>Executors</strong>的工厂方法来创建线程池极其简便，其实它的内部还是通过new ThreadPoolExecutor(…)的方式创建线程池的，我们看一下这些工厂方法的内部实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public static ExecutorService newFixedThreadPool(int nThreads) &#123;</div><div class="line">    return new ThreadPoolExecutor(nThreads, nThreads,</div><div class="line">                                  0L, TimeUnit.MILLISECONDS,</div><div class="line">                                  new LinkedBlockingQueue&lt;Runnable&gt;());</div><div class="line">&#125;</div><div class="line">public static ExecutorService newSingleThreadExecutor() &#123;</div><div class="line">    return new FinalizableDelegatedExecutorService</div><div class="line">        (new ThreadPoolExecutor(1, 1,</div><div class="line">                                0L, TimeUnit.MILLISECONDS,</div><div class="line">                                new LinkedBlockingQueue&lt;Runnable&gt;()));</div><div class="line">&#125;</div><div class="line">public static ExecutorService newCachedThreadPool() &#123;</div><div class="line">    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,</div><div class="line">                                  60L, TimeUnit.SECONDS,</div><div class="line">                                  new SynchronousQueue&lt;Runnable&gt;());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们可以清楚的看到这些方法的内部实现都是通过创建一个ThreadPoolExecutor对象来创建的，正所谓万变不离其宗，所以我们要了解线程池还是得了解ThreadPoolExecutor这个线程池类，其中由于和定时任务相关的线程池比较特殊（newScheduledThreadPool()、newSingleThreadScheduledExecutor()），它们创建的线程池内部实现是由ScheduledThreadPoolExecutor这个类实现的，而ScheduledThreadPoolExecutor是继承于ThreadPoolExecutor扩展而成的，所以本质还是一样的，只不过多封装了一些定时任务相关的api</p>
<h4 id="再撸一撸概念"><a href="#再撸一撸概念" class="headerlink" title="再撸一撸概念"></a>再撸一撸概念</h4><p>Java里面线程池的顶级接口是 Executor，不过真正的线程池接口是 ExecutorService， ExecutorService 的默认实现是 ThreadPoolExecutor；普通类 Executors 里面调用的就是 ThreadPoolExecutor。</p>
<p>照例看一下各个接口的源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">public interface Executor &#123;</div><div class="line">	void execute(Runnable command);</div><div class="line">&#125;</div><div class="line"></div><div class="line">public interface ExecutorService extends Executor &#123;</div><div class="line">	void shutdown();</div><div class="line">	List&lt;Runnable&gt; shutdownNow();</div><div class="line">	</div><div class="line">	boolean isShutdown();</div><div class="line">	boolean isTerminated();</div><div class="line">	</div><div class="line">	&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task);</div><div class="line">	&lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result);</div><div class="line">	Future&lt;?&gt; submit(Runnable task);</div><div class="line">	...</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Executors &#123;</div><div class="line">	public static ExecutorService newCachedThreadPool() &#123;</div><div class="line">    		return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, </div><div class="line">    						new SynchronousQueue&lt;Runnable&gt;());</div><div class="line">	&#125;</div><div class="line">	...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面我创建的一个线程池：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ExecutorService pool = Executors.newCachedThreadPool();</div></pre></td></tr></table></figure>
<p>通过 ThreadPoolExecutor 的构造函数，撸一撸线程池相关参数的概念：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public ThreadPoolExecutor(int corePoolSize,</div><div class="line">                          int maximumPoolSize,</div><div class="line">                          long keepAliveTime,</div><div class="line">                          TimeUnit unit,</div><div class="line">                          BlockingQueue&lt;Runnable&gt; workQueue,</div><div class="line">                          ThreadFactory threadFactory) &#123;</div><div class="line">    this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, </div><div class="line">    	threadFactory, defaultHandler);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>1）corePoolSize：线程池的核心线程数，一般情况下不管有没有任务都会一直在线程池中一直存活，只有在 ThreadPoolExecutor 中的方法 allowCoreThreadTimeOut(boolean value) 设置为 true 时，闲置的核心线程会存在超时机制，如果在指定时间没有新任务来时，核心线程也会被终止，而这个时间间隔由第3个属性 keepAliveTime 指定。</li>
<li>2）maximumPoolSize：线程池所能容纳的最大线程数，当活动的线程数达到这个值后，后续的新任务将会被阻塞。</li>
<li>3）keepAliveTime：控制线程闲置时的超时时长，超过则终止该线程。一般情况下用于非核心线程，只有在 ThreadPoolExecutor 中的方法 allowCoreThreadTimeOut(boolean value) 设置为 true时，也作用于核心线程。</li>
<li>4）unit：用于指定 keepAliveTime 参数的时间单位，TimeUnit 是个 enum 枚举类型，常用的有：TimeUnit.HOURS(小时)、TimeUnit.MINUTES(分钟)、TimeUnit.SECONDS(秒) 和 TimeUnit.MILLISECONDS(毫秒)等。</li>
<li>5）workQueue：线程池的任务队列，通过线程池的 execute(Runnable command) 方法会将任务 Runnable 存储在队列中。</li>
<li>6）threadFactory：线程工厂，它是一个接口，用来为线程池创建新线程的。<br>上面的参数理解起来都比较简单，不过workQueue这个任务队列却要再次说明一下，它是一个<code>BlockingQueue</code>对象，而泛型则限定它是用来存放Runnable对象的，刚刚上面讲了，不同的线程池它的任务队列实现肯定是不一样的，所以，保证不同线程池有着不同的功能的核心就是这个workQueue的实现了，细心的会发现在刚刚的用来创建线程池的工厂方法中，针对不同的线程池传入的workQueue也不一样，下面我总结一下这五种线程池分别用的是什么BlockingQueue：</li>
</ul>
<blockquote>
<p>1、newFixedThreadPool()—&gt;LinkedBlockingQueue<br>2、newSingleThreadExecutor()—&gt;LinkedBlockingQueue<br>3、newCachedThreadPool()—&gt;SynchronousQueue<br>4、newScheduledThreadPool()—&gt;DelayedWorkQueue<br>5、newSingleThreadScheduledExecutor()—&gt;DelayedWorkQueue</p>
</blockquote>
<p>这些队列分别表示：</p>
<blockquote>
<p><strong>LinkedBlockingQueue</strong>：无界的队列<br><strong>SynchronousQueue</strong>：直接提交的队列<br><strong>DelayedWorkQueue</strong>：等待队列</p>
</blockquote>
<p>当然实现了BlockingQueue接口的队列还有：ArrayBlockingQueue（有界的队列）、PriorityBlockingQueue（优先级队列）。这些队列的详细作用就不多介绍了。</p>
<p>线程池的关闭</p>
<p>ThreadPoolExecutor 提供了两个方法，用于线程池的关闭，分别是 shutdown() 和 shutdownNow()。</p>
<p>shutdown()：不会立即的终止线程池，而是要等所有任务缓存队列中的任务都执行完后才终止，但再也不会接受新的任务。<br>shutdownNow()：立即终止线程池，并尝试打断正在执行的任务，并且清空任务缓存队列，返回尚未执行的任务。</p>
<h2 id="线程池ThreadPoolExecutor的使用"><a href="#线程池ThreadPoolExecutor的使用" class="headerlink" title="线程池ThreadPoolExecutor的使用"></a><strong>线程池ThreadPoolExecutor的使用</strong></h2><p>使用线程池，其中涉及到一个极其重要的方法，即：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">execute(Runnable command)</div></pre></td></tr></table></figure>
<p>该方法意为执行给定的任务，该任务处理可能在新的线程、已入池的线程或者正调用的线程，这由ThreadPoolExecutor的实现决定。<br><strong>newFixedThreadPool</strong><br>创建一个固定线程数量的线程池，示例为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">ExecutorService fixedThreadPool = Executors.newFixedThreadPool(3);</div><div class="line">for (int i = 1; i &lt;= 10; i++) &#123;</div><div class="line">    final int index = i;</div><div class="line">    fixedThreadPool.execute(new Runnable() &#123;</div><div class="line">         @Override</div><div class="line">         public void run() &#123;</div><div class="line">             String threadName = Thread.currentThread().getName();</div><div class="line">             Log.v(&quot;zxy&quot;, &quot;线程：&quot;+threadName+&quot;,正在执行第&quot; + index + &quot;个任务&quot;);</div><div class="line">             try &#123;</div><div class="line">                    Thread.sleep(2000);</div><div class="line">             &#125; catch (InterruptedException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">             &#125;</div><div class="line">         &#125;</div><div class="line">     &#125;);</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>上述代码，我们创建了一个线程数为3的固定线程数量的线程池，同理该线程池支持的线程最大并发数也是3，而我模拟了10个任务让它处理，执行的情况则是首先执行前三个任务，后面7个则依次进入任务队列进行等待，执行完前三个任务后，再通过FIFO的方式从任务队列中取任务执行，直到最后任务都执行完毕。<br>为了体现出线程的复用，我特地在Log中加上了当前线程的名称，效果为：<br><img src="http://img.blog.csdn.net/20151116182357008" alt="这里写图片描述"><br><strong>newSingleThreadExecutor</strong><br>创建一个只有一个线程的线程池，每次只能执行一个线程任务，多余的任务会保存到一个任务队列中，等待线程处理完再依次处理任务队列中的任务，示例为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">ExecutorService singleThreadPool = Executors.newSingleThreadExecutor();</div><div class="line">for (int i = 1; i &lt;= 10; i++) &#123;</div><div class="line">    final int index = i;</div><div class="line">    singleThreadPool.execute(new Runnable() &#123;</div><div class="line">        @Override</div><div class="line">        public void run() &#123;</div><div class="line">            String threadName = Thread.currentThread().getName();</div><div class="line">            Log.v(&quot;zxy&quot;, &quot;线程：&quot;+threadName+&quot;,正在执行第&quot; + index + &quot;个任务&quot;);</div><div class="line">            try &#123;</div><div class="line">                Thread.sleep(1000);</div><div class="line">            &#125; catch (InterruptedException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>代码还是差不多，只不过改了线程池的实现方式，效果我想大家都知道，即依次一个一个的处理任务，而且都是复用一个线程，效果为：<br><img src="http://img.blog.csdn.net/20151116182627850" alt="这里写图片描述"></p>
<p>其实我们通过newSingleThreadExecutor()和newFixedThreadPool()的方法发现，创建一个singleThreadExecutorPool实际上就是创建一个核心线程数和最大线程数都为1的fixedThreadPool。<br><strong>newCachedThreadPool</strong><br>创建一个可以根据实际情况调整线程池中线程的数量的线程池，示例为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">ExecutorService cachedThreadPool = Executors.newCachedThreadPool();</div><div class="line">for (int i = 1; i &lt;= 10; i++) &#123;</div><div class="line">    final int index = i;</div><div class="line">    try &#123;</div><div class="line">        Thread.sleep(1000);</div><div class="line">    &#125; catch (InterruptedException e) &#123;</div><div class="line">        e.printStackTrace();</div><div class="line">    &#125;</div><div class="line">    cachedThreadPool.execute(new Runnable() &#123;</div><div class="line">        @Override</div><div class="line">        public void run() &#123;</div><div class="line">            String threadName = Thread.currentThread().getName();</div><div class="line">            Log.v(&quot;zxy&quot;, &quot;线程：&quot; + threadName + &quot;,正在执行第&quot; + index + &quot;个任务&quot;);</div><div class="line">            try &#123;</div><div class="line">                long time = index * 500;</div><div class="line">                Thread.sleep(time);</div><div class="line">            &#125; catch (InterruptedException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>为了体现该线程池可以自动根据实现情况进行线程的重用，而不是一味的创建新的线程去处理任务，我设置了每隔1s去提交一个新任务，这个新任务执行的时间也是动态变化的，所以，效果为：<br><img src="http://img.blog.csdn.net/20151116184528454" alt="这里写图片描述"><br><strong>newScheduledThreadPool</strong><br>创建一个可以定时或者周期性执行任务的线程池，示例为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(3);</div><div class="line">//延迟2秒后执行该任务</div><div class="line">scheduledThreadPool.schedule(new Runnable() &#123;</div><div class="line">    @Override</div><div class="line">    public void run() &#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;, 2, TimeUnit.SECONDS);</div><div class="line">//延迟1秒后，每隔2秒执行一次该任务</div><div class="line">scheduledThreadPool.scheduleAtFixedRate(new Runnable() &#123;</div><div class="line">    @Override</div><div class="line">    public void run() &#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;, 1, 2, TimeUnit.SECONDS);123456789101112131415</div></pre></td></tr></table></figure>
<p><strong>newSingleThreadScheduledExecutor</strong><br>创建一个可以定时或者周期性执行任务的线程池，该线程池的线程数为1，示例为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">ScheduledExecutorService singleThreadScheduledPool = Executors.newSingleThreadScheduledExecutor();</div><div class="line">//延迟1秒后，每隔2秒执行一次该任务</div><div class="line">singleThreadScheduledPool.scheduleAtFixedRate(new Runnable() &#123;</div><div class="line">    @Override</div><div class="line">    public void run() &#123;</div><div class="line">        String threadName = Thread.currentThread().getName();</div><div class="line">        Log.v(&quot;zxy&quot;, &quot;线程：&quot; + threadName + &quot;,正在执行&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;,1,2,TimeUnit.SECONDS);123456789</div></pre></td></tr></table></figure>
<p>实际上这个和上面的没什么太大区别，只不过是线程池内线程数量的不同，效果为：<br><img src="http://img.blog.csdn.net/20151116194526184" alt="这里写图片描述"><br>每隔2秒就会执行一次该任务</p>
<h3 id="自定义线程池ThreadPoolExecutor"><a href="#自定义线程池ThreadPoolExecutor" class="headerlink" title="自定义线程池ThreadPoolExecutor"></a><strong>自定义线程池ThreadPoolExecutor</strong></h3><p>Java内置只为我们提供了五种常用的线程池，一般来说这足够用了，不过有时候我们也可以根据需求来自定义我们自己的线程池，而要自定义不同功能的线程池，上面我们也说了线程池功能的不同归根到底还是内部的BlockingQueue实现不同，所以，我们要实现我们自己相要的线程池，就必须从BlockingQueue的实现上做手脚，而上面也说了BlockingQueue的实现类有多个，那么这次我们就选用PriorityBlockingQueue来实现一个功能是按任务的优先级来处理的线程池。</p>
<h4 id="1、首先我们创建一个基于PriorityBlockingQueue实现的线程池，为了测试方便，我这里把核心线程数量设置为3，如下："><a href="#1、首先我们创建一个基于PriorityBlockingQueue实现的线程池，为了测试方便，我这里把核心线程数量设置为3，如下：" class="headerlink" title="1、首先我们创建一个基于PriorityBlockingQueue实现的线程池，为了测试方便，我这里把核心线程数量设置为3，如下："></a><strong>1、首先我们创建一个基于PriorityBlockingQueue实现的线程池，为了测试方便，我这里把核心线程数量设置为3，如下：</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ExecutorService priorityThreadPool = new ThreadPoolExecutor(3,3,0L,TimeUnit.SECONDS,new PriorityBlockingQueue&lt;Runnable&gt;());1</div></pre></td></tr></table></figure>
<h4 id="2、然后创建一个实现Runnable接口的类，并向外提供一个抽象方法供我们实现自定义功能，并实现Comparable接口，实现这个接口主要就是进行优先级的比较，代码如下："><a href="#2、然后创建一个实现Runnable接口的类，并向外提供一个抽象方法供我们实现自定义功能，并实现Comparable接口，实现这个接口主要就是进行优先级的比较，代码如下：" class="headerlink" title="2、然后创建一个实现Runnable接口的类，并向外提供一个抽象方法供我们实现自定义功能，并实现Comparable接口，实现这个接口主要就是进行优先级的比较，代码如下："></a><strong>2、然后创建一个实现Runnable接口的类，并向外提供一个抽象方法供我们实现自定义功能，并实现Comparable接口，实现这个接口主要就是进行优先级的比较，代码如下：</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">public abstract class PriorityRunnable implements Runnable, Comparable&lt;PriorityRunnable&gt; &#123;</div><div class="line">    private int priority;</div><div class="line"></div><div class="line">    public PriorityRunnable(int priority) &#123;</div><div class="line">        if (priority &lt; 0)</div><div class="line">            throw new IllegalArgumentException();</div><div class="line">        this.priority = priority;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public int compareTo(PriorityRunnable another) &#123;</div><div class="line">        int my = this.getPriority();</div><div class="line">        int other = another.getPriority();</div><div class="line">        return my &lt; other ? 1 : my &gt; other ? -1 : 0;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void run() &#123;</div><div class="line">        doSth();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public abstract void doSth();</div><div class="line"></div><div class="line">    public int getPriority() &#123;</div><div class="line">        return priority;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="3、使用我们自己的PriorityRunnable提交任务，整体代码如下："><a href="#3、使用我们自己的PriorityRunnable提交任务，整体代码如下：" class="headerlink" title="3、使用我们自己的PriorityRunnable提交任务，整体代码如下："></a><strong>3、使用我们自己的PriorityRunnable提交任务，整体代码如下：</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">ExecutorService priorityThreadPool = new ThreadPoolExecutor(3, 3, 0L, TimeUnit.SECONDS, new PriorityBlockingQueue&lt;Runnable&gt;());</div><div class="line">for (int i = 1; i &lt;= 10; i++) &#123;</div><div class="line">    final int priority = i;</div><div class="line">    priorityThreadPool.execute(new PriorityRunnable(priority) &#123;</div><div class="line">        @Override</div><div class="line">        public void doSth() &#123;</div><div class="line">            String threadName = Thread.currentThread().getName();</div><div class="line">            Log.v(&quot;zxy&quot;, &quot;线程：&quot; + threadName + &quot;,正在执行优先级为：&quot; + priority + &quot;的任务&quot;);</div><div class="line">            try &#123;</div><div class="line">                Thread.sleep(2000);</div><div class="line">            &#125; catch (InterruptedException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="测试效果"><a href="#测试效果" class="headerlink" title="测试效果"></a><strong>测试效果</strong></h4><p>我们看下刚刚自定义的线程池是否达到了我们想要的功能，即根据任务的优先级进行优先处理任务，效果如下：<br><img src="http://img.blog.csdn.net/20151116212159326" alt="这里写图片描述"></p>
<p>可以从执行结果中看出，由于核心线程数设置为3，刚开始时，系统有3个空闲线程，所以无须使用任务队列，而是直接运行前三个任务，而后面再提交任务时由于当前没有空闲线程所以加入任务队列中进行等待，此时，由于我们的任务队列实现是由PriorityBlockingQueue实现的，所以进行等待的任务会经过优先级判断，优先级高的放在队列前面先处理。从效果图中也可以看到后面的任务是先执行优先级高的任务，然后依次递减。</p>
<h4 id="优先级线程池的优点"><a href="#优先级线程池的优点" class="headerlink" title="优先级线程池的优点"></a><strong>优先级线程池的优点</strong></h4><p>从上面我们可以得知，创建一个优先级线程池非常有用，它可以在线程池中线程数量不足或系统资源紧张时，优先处理我们想要先处理的任务，而优先级低的则放到后面再处理，这极大改善了系统默认线程池以FIFO方式处理任务的不灵活</p>
<h3 id="扩展线程池ThreadPoolExecutor"><a href="#扩展线程池ThreadPoolExecutor" class="headerlink" title="扩展线程池ThreadPoolExecutor"></a><strong>扩展线程池ThreadPoolExecutor</strong></h3><p>除了内置的功能外，ThreadPoolExecutor也向外提供了三个接口供我们自己扩展满足我们需求的线程池，这三个接口分别是：</p>
<blockquote>
<p>beforeExecute() - 任务执行前执行的方法<br>afterExecute() -任务执行结束后执行的方法<br>terminated() -线程池关闭后执行的方法</p>
</blockquote>
<p>这三个方法在ThreadPoolExecutor内部都没有实现</p>
<p>前面两个方法我们可以在ThreadPoolExecutor内部的runWorker()方法中找到，而runWorker()是ThreadPoolExecutor的内部类Worker实现的方法，Worker它实现了Runnable接口，也正是线程池内处理任务的工作线程，而Worker.runWorker()方法则是处理我们所提交的任务的方法，它会同时被多个线程访问，所以我们看runWorker()方法的实现，由于涉及到多个线程的异步调用，必然是需要使用锁来处理，而这里使用的是Lock来实现的，我们来看看runWorker()方法内主要实现：<br><img src="http://img.blog.csdn.net/20151117141139792" alt="这里写图片描述"></p>
<p>可以看到在task.run()之前和之后分别调用了beforeExecute和afterExecute方法，并传入了我们的任务Runnable对象</p>
<p>而terminated()则是在关闭线程池的方法中调用，而关闭线程池有两个方法，我贴其中一个：<br><img src="http://img.blog.csdn.net/20151117141553421" alt="这里写图片描述"></p>
<p>所以，我们要扩展线程池，只需要重写这三个方法，并实现我们自己的功能即可，这三个方法分别都会在任务执行前调用、任务执行完成后调用、线程池关闭后调用。<br>这里我验证一下，继承自ThreadPoolExecutor 并实现那三个方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">public class MyThreadPoolExecutor extends ThreadPoolExecutor &#123;</div><div class="line">    public MyThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue) &#123;</div><div class="line">        super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void beforeExecute(Thread t, Runnable r) &#123;</div><div class="line">        super.beforeExecute(t, r);</div><div class="line">        String threadName = t.getName();</div><div class="line">        Log.v(&quot;zxy&quot;, &quot;线程：&quot; + threadName + &quot;准备执行任务！&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void afterExecute(Runnable r, Throwable t) &#123;</div><div class="line">        super.afterExecute(r, t);</div><div class="line">        String threadName = Thread.currentThread().getName();</div><div class="line">        Log.v(&quot;zxy&quot;, &quot;线程：&quot; + threadName + &quot;任务执行结束！&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void terminated() &#123;</div><div class="line">        super.terminated();</div><div class="line">        Log.v(&quot;zxy&quot;, &quot;线程池结束！&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>而运行后的结果则是，这正符合刚刚说的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">11-17 05:47:51.184 1602-1619/? V/zxy: 线程：pool-6-thread-1准备执行任务！</div><div class="line">11-17 05:47:51.184 1602-1619/? V/zxy: 线程：pool-6-thread-1正在执行任务！</div><div class="line">11-17 05:47:53.184 1602-1619/? V/zxy: 线程：pool-6-thread-1任务执行结束！</div><div class="line">11-17 05:47:58.896 1602-1619/? V/zxy: 线程池结束！1234</div></pre></td></tr></table></figure>
<p>所以，在上面我们的优先级线程池的代码上，我们再扩展一个具有暂停功能的优先级线程池，代码如下：<br>具有暂时功能的线程池：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">public class PausableThreadPoolExecutor extends ThreadPoolExecutor &#123;</div><div class="line">    private boolean isPaused;</div><div class="line">    private ReentrantLock pauseLock = new ReentrantLock();</div><div class="line">    private Condition unpaused = pauseLock.newCondition();</div><div class="line"></div><div class="line">    public PausableThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue) &#123;</div><div class="line">        super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void beforeExecute(Thread t, Runnable r) &#123;</div><div class="line">        super.beforeExecute(t, r);</div><div class="line">        pauseLock.lock();</div><div class="line">        try &#123;</div><div class="line">            while (isPaused) unpaused.await();</div><div class="line">        &#125; catch (InterruptedException ie) &#123;</div><div class="line">            t.interrupt();</div><div class="line">        &#125; finally &#123;</div><div class="line">            pauseLock.unlock();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void pause() &#123;</div><div class="line">        pauseLock.lock();</div><div class="line">        try &#123;</div><div class="line">            isPaused = true;</div><div class="line">        &#125; finally &#123;</div><div class="line">            pauseLock.unlock();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void resume() &#123;</div><div class="line">        pauseLock.lock();</div><div class="line">        try &#123;</div><div class="line">            isPaused = false;</div><div class="line">            unpaused.signalAll();</div><div class="line">        &#125; finally &#123;</div><div class="line">            pauseLock.unlock();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后结合上面的优先级线程池的实现，创建具有暂停功能的优先级线程池：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">PausableThreadPoolExecutor pausableThreadPoolExecutor = new PausableThreadPoolExecutor(1, 1, 0L, TimeUnit.SECONDS, new PriorityBlockingQueue&lt;Runnable&gt;());</div><div class="line">for (int i = 1; i &lt;= 100; i++) &#123;</div><div class="line">    final int priority = i;</div><div class="line">    pausableThreadPoolExecutor.execute(new PriorityRunnable(priority) &#123;</div><div class="line">        @Override</div><div class="line">        public void doSth() &#123;</div><div class="line">            runOnUiThread(new Runnable() &#123;</div><div class="line">                @Override</div><div class="line">                public void run() &#123;</div><div class="line">                    textView.setText(priority + &quot;&quot;);</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">            try &#123;</div><div class="line">                Thread.sleep(1000);</div><div class="line">            &#125; catch (InterruptedException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里我为了演示效果，把这个线程池设为只有一个线程，然后直接在TextView中显示当前执行的任务的优先级，然后设置个开关，控制线程池的暂停与开始：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">if (isPause) &#123;</div><div class="line">    pausableThreadPoolExecutor.resume();</div><div class="line">    isPause = false;</div><div class="line">&#125; else &#123;</div><div class="line">    pausableThreadPoolExecutor.pause();</div><div class="line">    isPause = true;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>效果为：<br><img src="http://img.blog.csdn.net/20151117144914201" alt="这里写图片描述"></p>
<p>从效果上来看，该线程池和优先级线程一样，而且还多了一个暂停与开始的功能</p>
<h3 id="优化线程池ThreadPoolExecutor"><a href="#优化线程池ThreadPoolExecutor" class="headerlink" title="优化线程池ThreadPoolExecutor"></a><strong>优化线程池ThreadPoolExecutor</strong></h3><p>虽说线程池极大改善了系统的性能，不过创建线程池也是需要资源的，所以线程池内线程数量的大小也会影响系统的性能，大了反而浪费资源，小了反而影响系统的吞吐量，所以我们创建线程池需要把握一个度才能合理的发挥它的优点，通常来说我们要考虑的因素有CPU的数量、内存的大小、并发请求的数量等因素，按需调整。</p>
<p>通常核心线程数可以设为CPU数量+1，而最大线程数可以设为CPU的数量*2+1。</p>
<p>获取CPU数量的方法为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Runtime.getRuntime().availableProcessors();1</div></pre></td></tr></table></figure>
<h3 id="shutdown-和shutdownNow-的区别"><a href="#shutdown-和shutdownNow-的区别" class="headerlink" title="shutdown()和shutdownNow()的区别"></a><strong>shutdown()和shutdownNow()的区别</strong></h3><p>关于线程池的停止，ExecutorService为我们提供了两个方法：shutdown和shutdownNow，这两个方法各有不同，可以根据实际需求方便的运用，如下：</p>
<blockquote>
<p>1、shutdown()方法在终止前允许执行以前提交的任务。<br>2、shutdownNow()方法则是阻止正在任务队列中等待任务的启动并试图停止当前正在执行的任务。</p>
</blockquote>
<h3 id="关于AsyncTask的实现"><a href="#关于AsyncTask的实现" class="headerlink" title="关于AsyncTask的实现"></a><strong>关于AsyncTask的实现</strong></h3><p>大家都知道AsyncTask内部实现其实就是Thread+Handler。其中Handler是为了处理线程之间的通信，而这个Thread到底是指什么呢？通过AsyncTask源码可以得知，其实这个Thread是线程池，AsyncTask内部实现了两个线程池，分别是：串行线程池和固定线程数量的线程池。而这个固定线程数量则是通过CPU的数量决定的。</p>
<p>在默认情况下，我们大都通过AsyncTask::execute()来执行任务的，<br>，而execute()内部则是调用executeOnExecutor(sDefaultExecutor, params)方法执行的，第一个参数就是指定处理该任务的线程池，而默认情况下AsyncTask是传入串行线程池（在这里不讲版本的变化），也就是任务只能单个的按顺序执行，而我们要是想让AsyncTask并行的处理任务，大家都知道调用AsyncTask::executeOnExecutor(sDefaultExecutor, params)方法传入这个参数即可：AsyncTask.THREAD_POOL_EXECUTOR。<br>而这个参数的意义在于为任务指定了一个固定线程数量的线程池去处理，从而达到了并行处理的功能，我们可以在源码中看到AsyncTask.THREAD_POOL_EXECUTOR这个参数就是一个固定线程数量的线程池：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public static final Executor THREAD_POOL_EXECUTOR</div><div class="line">        = new ThreadPoolExecutor(CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE,</div><div class="line">                TimeUnit.SECONDS, sPoolWorkQueue, sThreadFactory);</div></pre></td></tr></table></figure>
<h4 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h4><p>1）什么是 Executor 框架？</p>
<p>Executor框架在Java 5中被引入，Executor 框架是一个根据一组执行策略调用、调度、执行和控制的异步任务的框架。</p>
<p>无限制的创建线程会引起应用程序内存溢出，所以创建一个线程池是个更好的的解决方案，因为可以限制线程的数量并且可以回收再利用这些线程。利用 Executor 框架可以非常方便的创建一个线程池。</p>
<p>2）Executors 类是什么？</p>
<p>Executors为Executor、ExecutorService、ScheduledExecutorService、ThreadFactory 和 Callable 类提供了一些工具方法。Executors 可以用于方便的创建线程池。</p>
<hr>
<p>未经许可不得转载，转载请注明zilianliuxue的blog,本人保留所有版权。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;线程池：基本思想还是一种对象池的思想，开辟一块内存空间，里面存放了众多(未死亡)的线程，池中线程执行调度由池管理器来处理。当有线程任务时，从池中取一个，执行完成后线程对象归池，这样可以避免反复创建线程对象所带来的性能开销，节省了系统的资源。&lt;/p&gt;
&lt;h1 id=&quot;Exec
    
    </summary>
    
      <category term="java" scheme="http://zilianliuxue.github.io/categories/java/"/>
    
    
      <category term="线程池" scheme="http://zilianliuxue.github.io/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>Java-Android并发编程引气入门篇</title>
    <link href="http://zilianliuxue.github.io/2016/08/25/Java-Android%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%BC%95%E6%B0%94%E5%85%A5%E9%97%A8%E7%AF%87/"/>
    <id>http://zilianliuxue.github.io/2016/08/25/Java-Android并发编程引气入门篇/</id>
    <published>2016-08-25T08:04:00.000Z</published>
    <updated>2016-08-25T13:34:31.158Z</updated>
    
    <content type="html"><![CDATA[<p>转自<a href="http://abner-nimengbo.cn/" target="_blank" rel="external">Abner_泥阿布</a></p>
<p>Android的并发编程，即多线程开发，而Android的多线程开发模型也是源于Java中的多线程模型。<br>所以本篇也会先讲一些Java中的多线程理念，再讲解具体涉及的类，最后深入Android中的并发场景和实践。</p>
<h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><h3 id="什么是并发"><a href="#什么是并发" class="headerlink" title="什么是并发"></a>什么是并发</h3><p>举个很简单的栗子，当你一边在撸撸撸，一边在看小视频，同时在做两件事，这就是并发。</p>
<p>咳，年轻人节制啊。</p>
<p>并发的好处</p>
<p>提高资源利用率</p>
<p>当一个任务并没有完全占用系统资源，就可以利用并发来提高资源利用率，同时也能更快地完成任务。</p>
<p>当你的右手在干些什么的时候，左手是不是在没事做呢？那就也用起来呗。<br>(某次聚会，一名骑马的汉子说自己左右互搏(lu)特厉害）。</p>
<p>在程序任务上更加精简</p>
<p>就拿上一个栗子来说，左手做什么，右手做什么，任务明确分配好，又能同时进行，既提高了效率，逻辑又清晰。</p>
<p>更好的响应程序</p>
<p>这个拿Android客户端举个栗子，上传图片时，当前界面还是正常运转没有卡死，图片也正常上传，既保证了界面被响应，又保证图片可以上传。</p>
<h3 id="并发的风险"><a href="#并发的风险" class="headerlink" title="并发的风险"></a>并发的风险</h3><p>###　并发的代价</p>
<p>需要占用更多的资源。<br>设计好一个并发程序并不容易。<br>并发的资源交互问题复杂。<br>并发的隐患</p>
<p>滥用资源导致系统不稳定<br>结果与预期不符<br>出现BUG难以排查</p>
<h3 id="线程篇"><a href="#线程篇" class="headerlink" title="线程篇"></a>线程篇</h3><h3 id="进程是什么"><a href="#进程是什么" class="headerlink" title="进程是什么"></a>进程是什么</h3><p>就拿Android中的App来说，一般来说一个app就是一个进程，（除了特殊的手段开启了多个进程，这里不深入这个话题，就是一个一对多的关系）。</p>
<p>线程是什么</p>
<p>进程只是一个程序、任务的统称，但是却不能执行任务，真正执行任务的是线程，所以线程是由进程创建的，一个进程可以创建多个线程。</p>
<p>线程可以调度资源等等，在这里只需要了解大致的概念就好，如果要深入可以学习一下操作系统。</p>
<h3 id="进程与线程的关系"><a href="#进程与线程的关系" class="headerlink" title="进程与线程的关系"></a>进程与线程的关系</h3><p>人脑就相当于是CPU，想做一件事的时候，这个任务就是一个进程了，需要运用手脚等器官去完成这个任务，而手脚器官就可以理解成一个个线程，去做了不同的事，从而完成任务。</p>
<h3 id="单线程"><a href="#单线程" class="headerlink" title="单线程"></a>单线程</h3><p>还是用Android举栗子，当你在手机上操作的时候，这个被称之为UI线程（之后会详解）。而一个最基本的app，不需要复杂的功能时，就只有一个UI线程和我们交互，那么这个app就是个单线程的。一般的程序面向用户的线程就是UI线程，也称之为主线程，单线程程序，其实就是只有一个主线程的程序。</p>
<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><p>多个进程可以算是并发，但是我们所说的并发场景，大部分是在一个进程中的，而并发就是由线程完成的，多个线程同时执行任务，就称之为并发。</p>
<p>以下为多线程工作示意图：</p>
<p><img src="http://abner-nimengbo.cn/images/%E5%A4%9A%E7%BA%BF%E7%A8%8B.png" alt=""></p>
<h2 id="多线程并发过程中会遇到的问题"><a href="#多线程并发过程中会遇到的问题" class="headerlink" title="多线程并发过程中会遇到的问题"></a>多线程并发过程中会遇到的问题</h2><ol>
<li>资源共享</li>
</ol>
<p>A线程要写文件C，B线程也要写文件C，这个时候就好像你拿着两只笔同时往纸上写东西，写出来的是什么自己也不知道。</p>
<p>这个时候我们需要一个类似于锁的东西，当C被A在写的时候，B不能写，B要等A写完了才能继续写。</p>
<p>至于这个锁到底是什么会在后面继续讲到。</p>
<ol>
<li>死锁问题</li>
</ol>
<p>死锁的四个条件是：</p>
<ul>
<li>禁止抢占：no preemption</li>
</ul>
<ul>
<li>持有和等待：hold and wait</li>
</ul>
<ul>
<li>互斥：mutual exclusion</li>
</ul>
<ul>
<li>循环等待：circular waiting</li>
</ul>
<p>预防死锁就是至少破坏这四个条件其中一项，即破坏“禁止抢占”、破坏“持有等待”、破坏“资源互斥”和破坏“循环等待”。</p>
<p>举个例子：</p>
<p>A在B那边割包皮，B把A割坏了，A占着B的床位，要B赔钱，B要A让出床位才给钱。双方僵持不下。</p>
<h3 id="线程如何去用"><a href="#线程如何去用" class="headerlink" title="线程如何去用"></a>线程如何去用</h3><p>在Java中，线程通常就是指Thread这个类，或者实现了Runnable的类，其实Thread这个类也是实现了Runnable接口的，可以看一下Runnable接口的代码：</p>
<p><img src="http://abner-nimengbo.cn/images/runnable.png" alt=""></p>
<p>里面就是一个run方法需要被实现。</p>
<p>再看一下Thread类的声明：</p>
<p><img src="http://abner-nimengbo.cn/images/Thread.png" alt=""></p>
<p>确实是一个实现了Runnable的类。</p>
<p>那么Thread类中拥有start()方法，和run()方法，下面用run()方法直接调用<br>得到信息：</p>
<p><img src="http://abner-nimengbo.cn/images/threadRun.png" alt=""></p>
<p>发现其实和外面的线程是在同一个线程上。</p>
<p>而调用start()方法得到的信息是：</p>
<p><img src="http://abner-nimengbo.cn/images/threadStart.png" alt=""></p>
<p>发现线程名不一样了，用start会开启一个新的线程，而run还是在当前线程执行。</p>
<p>另外在Java1.5之后，还有Callable、Future和FutureTask，在这里就不详细介绍，还有线程的wait、<br>yield、sleep等在下一章会一起详细介绍。</p>
<h3 id="线程的优先级"><a href="#线程的优先级" class="headerlink" title="线程的优先级"></a>线程的优先级</h3><p>在Java中，线程的优先级有1~10，而默认的是5。1最低，10最高。在Thread类中有三个常量：</p>
<ul>
<li>MIN_PRIORITY = 1</li>
</ul>
<ul>
<li>NORM_PRIORITY = 5</li>
</ul>
<ul>
<li>MAX_PRIORITY = 10</li>
</ul>
<p>在同一个线程池中的线程优先级是相同的。</p>
<p>JVM会根据线程的优先级去抢先调度，然而线程的优先级只能保证抢占资源的概率较大，并不能保障线程的执行顺序，所以不能过于依赖设置线程的优先级。</p>
<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>频繁地创建和销毁线程会导致性能大幅度降低，这肯定不是你希望的。</p>
<p>线程池的出现，就是为了解决这个问题，根据java中提供不同的线程池机制，有效地提高资源利用率。</p>
<p>直接在代码中创建Thread、Runnable去start或者run容易出现不可预测的问题，在java1.5开始，引入了java.util.concurrent包，其中有个并发的框架：Executor，使用ExecutorService替代直接操作线程类，而Executors是用来创建线程池的，内部提供了很多静态方法去创建你想要的线程池，不需要你再手动去创建实现。<br>看一下关于Executor中的类和接口的大致的成员与关系：</p>
<p><img src="http://abner-nimengbo.cn/images/concurrent.png" alt=""></p>
<p>关于这些类如何使用，以及有什么特性，下一章会作介绍。</p>
<h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>在java中提到队列肯定会想起Queue,而线程队列用的是BlockingQueue,这是个接口，在concurrent包中有好几个类实现了这个接口。</p>
<p><img src="http://abner-nimengbo.cn/images/BlockingQueue.png" alt=""></p>
<p>介绍一下BlockingQueue常用的方法</p>
<p><img src="http://i.imgur.com/txrnQN4.png" alt=""></p>
<h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><p>在前面讲过死锁，死锁是由于使用不当引起的一种现象，而这里的锁是人工干预的，让并发按照你的意思走。</p>
<p>在java中的锁有synchonrized、Lock。锁的出现主要是为了解决线程安全问题。</p>
<p>关于线程的状态会在下一章讲锁的机制时候再讲，因为线程的状态会影响到锁。</p>
<p>线程安全的集合</p>
<p>因为多线程访问资源可能会造成数据不一致或者数据污染，而某些集合会用一些锁或者同步机制做了处理。</p>
<p>线程安全的集合有：HashTable、SynchronizedCollection、ConcurrentHashMap、Vector等。</p>
<p>线程安不安全的首要前提是在多线程访问同一个对象的情况下。</p>
<h3 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h3><blockquote>
<p>《Java并发编程实践》</p>
<p>《Thinking in Java》</p>
<p>baoyongzhang(鲍老师)</p>
<hr>
<p>未经许可不得转载，转载请注明zilianliuxue的blog,本人保留所有版权。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转自&lt;a href=&quot;http://abner-nimengbo.cn/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Abner_泥阿布&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Android的并发编程，即多线程开发，而Android的多线程开发模型也是源于Java中的多
    
    </summary>
    
      <category term="java" scheme="http://zilianliuxue.github.io/categories/java/"/>
    
    
      <category term="线程池" scheme="http://zilianliuxue.github.io/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>view事件机制21问21答</title>
    <link href="http://zilianliuxue.github.io/2016/08/23/View%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B621%E9%97%AE21%E7%AD%94/"/>
    <id>http://zilianliuxue.github.io/2016/08/23/View事件机制21问21答/</id>
    <published>2016-08-23T11:48:00.000Z</published>
    <updated>2016-08-25T12:43:53.720Z</updated>
    
    <content type="html"><![CDATA[<p>本文为转载的，作者希尔瓦娜斯女神</p>
<h1 id="Android-View事件机制"><a href="#Android-View事件机制" class="headerlink" title="Android View事件机制"></a>Android View事件机制</h1><p><strong>1.View的坐标参数 主要有哪些？分别有什么注意的要点？</strong></p>
<p>答：Left，Right，top,Bottom 注意这4个值其实就是 view 和 他的父控件的 相对坐标值。 并非是距离屏幕左上角的绝对值，这点要注意。</p>
<p>　此外，X和Y 其实也是相对于父控件的坐标值。 TranslationX,TranslationY 这2个值 默认都为0，是相对于父控件的左上角的偏移量。</p>
<p>　换算关系：</p>
<blockquote>
<p>　x=left+tranX,y=top+tranY.</p>
</blockquote>
<p>  很多人不理解，为什么事这样，其实就是View 如果有移动的话，比如平移这种，你们就要注意了，top和left 这种值 是不会变化的。</p>
<p>   无论你把view怎么拖动，但是 x,y,tranX,tranY 的值是随着拖动平移 而变化的。想明白这点 就行了。</p>
<p><strong>2.onTouchEvent和GestureDetector 在什么时候用哪个比较好？</strong></p>
<p>答：只有滑动需求的时候 就用前者，如果有双击等这种行为的时候 就用后者。</p>
<p><strong>3.Scroller 用来解决什么问题？</strong></p>
<p>答：view的scrollTo和scrollBy 滑动效果太差了，是瞬间完成。而scroller可以配合view的computeScroll 来完成 渐变的滑动效果。体验更好。</p>
<p><strong>4.ScrollTo和ScrollBy 有什么需要注意的？</strong></p>
<p>答：前者是绝对滑动，后者是相对滑动。滑动的是view的内容 而不是view本身。这很重要。比如textview 调用这2个方法  滑动的就是显示出来的字的内容。</p>
<p>一般而言 我们用scrollBy会比较多一些。传值的话 其实 记住几个法则就可以了。 右-左 x为正 否则x为负  上-下 y为负，否则y为正。</p>
<p>可以稍微看一下 这2个的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scrollTo</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (mScrollX != x || mScrollY != y) &#123;</div><div class="line"></div><div class="line">            <span class="keyword">int</span> oldX = mScrollX;</div><div class="line"></div><div class="line">            <span class="keyword">int</span> oldY = mScrollY;</div><div class="line"></div><div class="line">            mScrollX = x;</div><div class="line"></div><div class="line">            mScrollY = y;</div><div class="line"></div><div class="line">            invalidateParentCaches();</div><div class="line"></div><div class="line">            onScrollChanged(mScrollX, mScrollY, oldX, oldY);</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (!awakenScrollBars()) &#123;</div><div class="line"></div><div class="line">                postInvalidateOnAnimation();</div><div class="line"></div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scrollBy</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</div><div class="line"></div><div class="line">        scrollTo(mScrollX + x, mScrollY + y);</div><div class="line"></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>看到里面有2个变量 mScrollX 和mScrollY 这2个东西没，这2个单位的 值是像素，前者代表 view的左边缘和view内容左边缘的距离。 后者代表 view上边缘和view内容上边缘的距离。</p>
<p><strong>5.使用动画来实现view的滑动 有什么后果？</strong></p>
<p>答：实际上view动画 是对view的表面ui 也就是给用户呈现出的视觉效果 来做的移动，动画本身并不能移动view的真正位置。属性动画除外。动画播放结束以后，view最终还是会回到自己的位置的，。当然了你可以设置fillafter 属性 来让动画播放结束以后 view表象停留在 变化以后的位置。所以这会带来一个很严重的后果。比如你的button在屏幕的左边，你现在用个动画 并且设置了fillafter属性让他去了右边。你会发现 点击右边的button 没有click事件触发，但是点击左边的 却可以触发，原因就是右边的button 只是view的表象，真正的button 还在左边没有动过。你一定要这么做的话 可以提前在右边button移动后的位置放一个新的button，当你动画执行结束以后  把右边的enable 左边的让他gone就可以了。</p>
<p>这么做就可以规避上述问题。</p>
<p><strong>6.让view滑动总共有几种方式，分别要注意什么？都适用于那些场景？</strong></p>
<p>答：总共有三种：</p>
<p>a：scrollto，scrollby。这种是最简单的，但是只能滑动view的内容 不可以滑动view本身。</p>
<p>b：动画。动画可以滑动view内容，但是注意非属性动画 就如我们问题5说的内容 会影响到交互，使用的时候要多注意。不过多数复杂的滑动效果都是属性动画来完成的，属于大杀器级别、</p>
<p>c：改变布局参数。这种最好理解了，无非是动态的通过java代码来修改 margin等view的参数罢了。不过用的比较少。我本人不怎么用这种方法。</p>
<p><strong>7.Scroller是干嘛的？原理是什么？</strong></p>
<p>答：Scroller就是用于 让view有滑动渐变效果的。用法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.example.administrator.motioneventtest;</div><div class="line"></div><div class="line"><span class="keyword">import</span> android.content.Context;</div><div class="line"></div><div class="line"><span class="keyword">import</span> android.util.AttributeSet;</div><div class="line"></div><div class="line"><span class="keyword">import</span> android.widget.Scroller;</div><div class="line"></div><div class="line"><span class="keyword">import</span> android.widget.TextView;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"></div><div class="line"> * Created by Administrator on 2016/2/2.</div><div class="line"></div><div class="line"> */</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomTextView</span> <span class="keyword">extends</span> <span class="title">TextView</span></span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> Scroller mScroller;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomTextView</span><span class="params">(Context context)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">super</span>(context);</div><div class="line"></div><div class="line">        mScroller=<span class="keyword">new</span> Scroller(context);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomTextView</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">super</span>(context, attrs);</div><div class="line"></div><div class="line">        mScroller=<span class="keyword">new</span> Scroller(context);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomTextView</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyleAttr)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">super</span>(context, attrs, defStyleAttr);</div><div class="line"></div><div class="line">        mScroller=<span class="keyword">new</span> Scroller(context);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//调用此方法滚动到目标位置</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">smoothScrollTo</span><span class="params">(<span class="keyword">int</span> fx, <span class="keyword">int</span> fy)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> dx = fx - mScroller.getFinalX();</div><div class="line"></div><div class="line">        <span class="keyword">int</span> dy = fy - mScroller.getFinalY();</div><div class="line"></div><div class="line">        smoothScrollBy(dx, dy);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//调用此方法设置滚动的相对偏移</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">smoothScrollBy</span><span class="params">(<span class="keyword">int</span> dx, <span class="keyword">int</span> dy)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="comment">//设置mScroller的滚动偏移量</span></div><div class="line"></div><div class="line">        mScroller.startScroll(mScroller.getFinalX(), mScroller.getFinalY(), dx, dy,<span class="number">4000</span>);</div><div class="line"></div><div class="line">        invalidate();<span class="comment">//这里必须调用invalidate()才能保证computeScroll()会被调用，否则不一定会刷新界面，看不到滚动效果</span></div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//使用scroller最重要不要遗漏这个方法</span></div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">computeScroll</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (mScroller.computeScrollOffset())</div><div class="line"></div><div class="line">        &#123;</div><div class="line"></div><div class="line">            scrollTo(mScroller.getCurrX(),mScroller.getCurrY());</div><div class="line"></div><div class="line">            <span class="comment">//这个方法不要忘记调用。</span></div><div class="line"></div><div class="line">            postInvalidate();</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">super</span>.computeScroll();</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其实上述代码 很多人应该都能搜到。我们这里主要讲一下 他的原理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//参数很好理解 前面滑动起始点 中间滑动距离 最后一个是 渐变时间</span></div><div class="line"></div><div class="line"><span class="comment">//而且我们看到startScroll 这个方法就是设置了一下参数 并没有什么滑动的代码在</span></div><div class="line"></div><div class="line"><span class="comment">//回到前面的demo能看到我们通常调用完这个方法以后 都会马上调用invalidate()方法</span></div><div class="line"></div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startScroll</span><span class="params">(<span class="keyword">int</span> startX, <span class="keyword">int</span> startY, <span class="keyword">int</span> dx, <span class="keyword">int</span> dy, <span class="keyword">int</span> duration)</span> </span>&#123;</div><div class="line"></div><div class="line">        mMode = SCROLL_MODE;</div><div class="line"></div><div class="line">        mFinished = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">        mDuration = duration;</div><div class="line"></div><div class="line">        mStartTime = AnimationUtils.currentAnimationTimeMillis();</div><div class="line"></div><div class="line">        mStartX = startX;</div><div class="line"></div><div class="line">        mStartY = startY;</div><div class="line"></div><div class="line">        mFinalX = startX + dx;</div><div class="line"></div><div class="line">        mFinalY = startY + dy;</div><div class="line"></div><div class="line">        mDeltaX = dx;</div><div class="line"></div><div class="line">        mDeltaY = dy;</div><div class="line"></div><div class="line">        mDurationReciprocal = <span class="number">1.0f</span> / (<span class="keyword">float</span>) mDuration;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line"><span class="comment">//我们都知道invalidate 会触发view的 draw方法 </span></div><div class="line"></div><div class="line"><span class="comment">//我们跟进去看 会发现draw方法里 会调用下面的代码：</span></div><div class="line"></div><div class="line"><span class="comment">//也就是说会调用    computeScroll方法 而view本身这个方法</span></div><div class="line"></div><div class="line"><span class="comment">//是空的所以会留给我们自己实现</span></div><div class="line"></div><div class="line"> <span class="keyword">int</span> sx = <span class="number">0</span>;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> sy = <span class="number">0</span>;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (!drawingWithRenderNode) &#123;</div><div class="line"></div><div class="line">            computeScroll();</div><div class="line"></div><div class="line">            sx = mScrollX;</div><div class="line"></div><div class="line">            sy = mScrollY;</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line"><span class="comment">//然后回到我们的customtextview 可以看到我们实现的    computeScroll方法如下：</span></div><div class="line"></div><div class="line"><span class="comment">//你看在这个方法里 我们调用了scrollTo方法 来实现滑动，滑动结束以后再次触发view的重绘</span></div><div class="line"></div><div class="line"><span class="comment">//然后又会再次触发computeScroll 实现一个循环。</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">computeScroll</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (mScroller.computeScrollOffset())</div><div class="line"></div><div class="line">        &#123;</div><div class="line"></div><div class="line">            scrollTo(mScroller.getCurrX(),mScroller.getCurrY());</div><div class="line"></div><div class="line">            <span class="comment">//这个方法不要忘记调用。</span></div><div class="line"></div><div class="line">            postInvalidate();</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">super</span>.computeScroll();</div><div class="line"></div><div class="line">    &#125; </div><div class="line"></div><div class="line"><span class="comment">//返回true就代表滑动还没结束 false就是结束了</span></div><div class="line"></div><div class="line"><span class="comment">//其实这个方法 就跟属性动画里的插值器一样 你在使用startScroll方法的时候 会传一个事件的值，</span></div><div class="line"></div><div class="line"><span class="comment">//这个方法就是根据这个事件的值来计算你每一次scrollx和scrolly的值</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">computeScrollOffset</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (mFinished) &#123;</div><div class="line"></div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> timePassed = (<span class="keyword">int</span>)(AnimationUtils.currentAnimationTimeMillis() - mStartTime);</div><div class="line"></div><div class="line">    </div><div class="line"></div><div class="line">        <span class="keyword">if</span> (timePassed &lt; mDuration) &#123;</div><div class="line"></div><div class="line">            <span class="keyword">switch</span> (mMode) &#123;</div><div class="line"></div><div class="line">            <span class="keyword">case</span> SCROLL_MODE:</div><div class="line"></div><div class="line">                <span class="keyword">final</span> <span class="keyword">float</span> x = mInterpolator.getInterpolation(timePassed * mDurationReciprocal);</div><div class="line"></div><div class="line">                mCurrX = mStartX + Math.round(x * mDeltaX);</div><div class="line"></div><div class="line">                mCurrY = mStartY + Math.round(x * mDeltaY);</div><div class="line"></div><div class="line">                <span class="keyword">break</span>;</div><div class="line"></div><div class="line">            <span class="keyword">case</span> FLING_MODE:</div><div class="line"></div><div class="line">                <span class="keyword">final</span> <span class="keyword">float</span> t = (<span class="keyword">float</span>) timePassed / mDuration;</div><div class="line"></div><div class="line">                <span class="keyword">final</span> <span class="keyword">int</span> index = (<span class="keyword">int</span>) (NB_SAMPLES * t);</div><div class="line"></div><div class="line">                <span class="keyword">float</span> distanceCoef = <span class="number">1</span>.f;</div><div class="line"></div><div class="line">                <span class="keyword">float</span> velocityCoef = <span class="number">0</span>.f;</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (index &lt; NB_SAMPLES) &#123;</div><div class="line"></div><div class="line">                    <span class="keyword">final</span> <span class="keyword">float</span> t_inf = (<span class="keyword">float</span>) index / NB_SAMPLES;</div><div class="line"></div><div class="line">                    <span class="keyword">final</span> <span class="keyword">float</span> t_sup = (<span class="keyword">float</span>) (index + <span class="number">1</span>) / NB_SAMPLES;</div><div class="line"></div><div class="line">                    <span class="keyword">final</span> <span class="keyword">float</span> d_inf = SPLINE_POSITION[index];</div><div class="line"></div><div class="line">                    <span class="keyword">final</span> <span class="keyword">float</span> d_sup = SPLINE_POSITION[index + <span class="number">1</span>];</div><div class="line"></div><div class="line">                    velocityCoef = (d_sup - d_inf) / (t_sup - t_inf);</div><div class="line"></div><div class="line">                    distanceCoef = d_inf + (t - t_inf) * velocityCoef;</div><div class="line"></div><div class="line">                &#125;</div><div class="line"></div><div class="line">                mCurrVelocity = velocityCoef * mDistance / mDuration * <span class="number">1000.0f</span>;</div><div class="line"></div><div class="line">                </div><div class="line"></div><div class="line">                mCurrX = mStartX + Math.round(distanceCoef * (mFinalX - mStartX));</div><div class="line"></div><div class="line">                <span class="comment">// Pin to mMinX &lt;= mCurrX &lt;= mMaxX</span></div><div class="line"></div><div class="line">                mCurrX = Math.min(mCurrX, mMaxX);</div><div class="line"></div><div class="line">                mCurrX = Math.max(mCurrX, mMinX);</div><div class="line"></div><div class="line">                </div><div class="line"></div><div class="line">                mCurrY = mStartY + Math.round(distanceCoef * (mFinalY - mStartY));</div><div class="line"></div><div class="line">                <span class="comment">// Pin to mMinY &lt;= mCurrY &lt;= mMaxY</span></div><div class="line"></div><div class="line">                mCurrY = Math.min(mCurrY, mMaxY);</div><div class="line"></div><div class="line">                mCurrY = Math.max(mCurrY, mMinY);</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (mCurrX == mFinalX &amp;&amp; mCurrY == mFinalY) &#123;</div><div class="line"></div><div class="line">                    mFinished = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="keyword">break</span>;</div><div class="line"></div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line"></div><div class="line">            mCurrX = mFinalX;</div><div class="line"></div><div class="line">            mCurrY = mFinalY;</div><div class="line"></div><div class="line">            mFinished = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line"></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p><strong>8.view的滑动渐变效果总共有几种方法？</strong></p>
<p>答：三种，第一种是scroller 也是使用最多的。问题7里有解释。还有一种就是动画，动画我就不多说了，不属于本文范畴。最后一种也是我们经常使用的就是用handler ，每隔一个时间间隔 来更新view的状态。</p>
<p>代码不写了很简单。 自行体会。</p>
<p><strong>9.view的事件传递机制 如何用伪代码来表示？</strong></p>
<p>答：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"></div><div class="line">     * 对于一个root viewgroup来说，如果接受了一个点击事件，那么首先会调用他的dispatchTouchEvent方法。</div><div class="line"></div><div class="line">     * 如果这个viewgroup的onInterceptTouchEvent 返回true，那就代表要拦截这个事件。接下来这个事件就</div><div class="line"></div><div class="line">     * 给viewgroup自己处理了，从而viewgroup的onTouchEvent方法就会被调用。如果如果这个viewgroup的onInterceptTouchEvent</div><div class="line"></div><div class="line">     * 返回false就代表我不拦截这个事件，然后就把这个事件传递给自己的子元素，然后子元素的dispatchTouchEvent</div><div class="line"></div><div class="line">     * 就会被调用，就是这样一个循环直到 事件被处理。</div><div class="line"></div><div class="line">     *</div><div class="line"></div><div class="line">     */</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span>　<span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span></span></div><div class="line"></div><div class="line">&#123;</div><div class="line"></div><div class="line">    <span class="keyword">boolean</span> consume=<span class="keyword">false</span>;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (onInterceptTouchEvent(ev)) &#123;</div><div class="line"></div><div class="line">        consume=onTouchEvent(ev);</div><div class="line"></div><div class="line">    &#125;<span class="keyword">else</span></div><div class="line"></div><div class="line">    &#123;</div><div class="line"></div><div class="line">        consume=child.dispatchTouchEvent(ev);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> consume;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>10.view的onTouchEvent，OnClickListerner和OnTouchListener的onTouch方法 三者优先级如何？</strong></p>
<p>答：onTouchListener优先级最高，如果onTouch方法返回 false ，那onTouchEvent就被调用了，返回true 就不会被调用。至于onClick 优先级最低。</p>
<p><strong>11.点击事件的传递顺序如何？</strong></p>
<p>答：Activity-Window-View。从上到下依次传递，当然了如果你最低的那个view onTouchEvent返回false 那就说明他不想处理 那就再往上抛，都不处理的话</p>
<p>最终就还是让Activity自己处理了。举个例子，pm下发一个任务给leader，leader自己不做 给架构师a，小a也不做 给程序员b，b如果做了那就结束了这个任务。</p>
<p>b如果发现自己搞不定，那就找a做，a要是也搞不定 就会不断向上发起请求，最终可能还是pm做。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//activity的dispatchTouchEvent 方法 一开始就是交给window去处理的</span></div><div class="line"></div><div class="line"><span class="comment">//win的superDispatchTouchEvent 返回true 那就直接结束了 这个函数了。返回false就意味</span></div><div class="line"></div><div class="line"><span class="comment">//这事件没人处理，最终还是给activity的onTouchEvent 自己处理 这里的getwindow 其实就是phonewindow</span></div><div class="line"></div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (ev.getAction() == MotionEvent.ACTION_DOWN) &#123;</div><div class="line"></div><div class="line">            onUserInteraction();</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (getWindow().superDispatchTouchEvent(ev)) &#123;</div><div class="line"></div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> onTouchEvent(ev);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line"><span class="comment">//来看phonewindow的这个函数 直接把事件传递给了mDecor</span></div><div class="line"></div><div class="line"> <span class="meta">@Override</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">superDispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> mDecor.superDispatchTouchEvent(event);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line"><span class="comment">//devorview就是 我们的rootview了 就是那个framelayout 我们的setContentView里面传递的那个layout</span></div><div class="line"></div><div class="line"><span class="comment">//就是这个decorview的 子view了</span></div><div class="line"></div><div class="line">     <span class="meta">@Override</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> View <span class="title">getDecorView</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (mDecor == <span class="keyword">null</span>) &#123;</div><div class="line"></div><div class="line">            installDecor();</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> mDecor;</div><div class="line"></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p><strong>12.事件分为几个步骤？</strong></p>
<p>答：down事件开头，up事件结尾，中间可能会有数目不定的move事件。</p>
<p><strong>13.ViewGroup如何对点击事件分发？</strong></p>
<p>答：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">viewgroup就是在actionMasked == MotionEvent.ACTION_DOWN 和 mFirstTouchTarget != <span class="keyword">null</span> 这两种情况来判断是否会进入拦截事件的流程</div><div class="line"></div><div class="line">看代码可以知道 如果是ACTION_DOWN事件  那就肯定进入 是否要拦截事件的流程</div><div class="line"></div><div class="line">如果不是ACTION_DOWN事件 那就要看mFirstTouchTarget != <span class="keyword">null</span> 这个条件是否成立</div><div class="line"></div><div class="line">这个地方有点绕但是也好理解，其实就是 对于一个事件序列来说 down是事件的开头 所以肯定进入了这个事件是否拦截的流程 也就是<span class="keyword">if</span> 括号内。</div><div class="line"></div><div class="line">mFirstTouchTarget其实是一个单链表结构他指向的是 成功处理事件的子元素。</div><div class="line"></div><div class="line">也就是说 如果有子元素成功处理了 事件，那这个值就不为NULL。反过来说</div><div class="line"></div><div class="line">只要viewgroup拦截了事件，mFirstTouchTarget就不为NULL，所以括号内就不会执行，也就侧面说明了一个结论：</div><div class="line"></div><div class="line">某个view 一旦决定拦截事件，那么这个事件所属的事件序列 都只能由他来执行。并且onInterceptTouchEvent 这个方法不会被调用了</div><div class="line"></div><div class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> intercepted;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN</div><div class="line"></div><div class="line">                    || mFirstTouchTarget != <span class="keyword">null</span>) &#123;</div><div class="line"></div><div class="line">                <span class="keyword">final</span> <span class="keyword">boolean</span> disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != <span class="number">0</span>;</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (!disallowIntercept) &#123;</div><div class="line"></div><div class="line">                    intercepted = onInterceptTouchEvent(ev);</div><div class="line"></div><div class="line">                    ev.setAction(action); <span class="comment">// restore action in case it was changed</span></div><div class="line"></div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line"></div><div class="line">                    intercepted = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">                &#125;</div><div class="line"></div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line"></div><div class="line">                <span class="comment">// There are no touch targets and this action is not an initial down</span></div><div class="line"></div><div class="line">                <span class="comment">// so this view group continues to intercept touches.</span></div><div class="line"></div><div class="line">                intercepted = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">            &#125;</div></pre></td></tr></table></figure>
<p><strong>14.如果某个view 处理事件的时候 没有消耗down事件 会有什么结果？</strong></p>
<p>答：假如一个view，在down事件来的时候 他的onTouchEvent返回false， 那么这个down事件 所属的事件序列 就是他后续的move 和up 都不会给他处理了，全部都给他的父view处理。</p>
<p><strong>15.如果view 不消耗move或者up事件 会有什么结果？</strong></p>
<p>答：那这个事件所属的事件序列就消失了，父view也不会处理的，最终都给activity 去处理了。</p>
<p><strong>16.ViewGroup 默认拦截事件吗？</strong></p>
<p>答：默认不拦截任何事件，onInterceptTouchEvent返回的是false。</p>
<p><strong>17.一旦有事件传递给view，view的onTouchEvent一定会被调用吗？</strong></p>
<p>答：是的，因为view 本身没有onInterceptTouchEvent方法，所以只要事件来到view这里 就一定会走onTouchEvent方法。</p>
<p>并且默认都是消耗掉，返回true的。除非这个view是不可点击的，所谓不可点击就是clickable和longgclikable同时为fale</p>
<p>Button的clickable就是true 但是textview是false。</p>
<p><strong>18.enable是否影响view的onTouchEvent返回值？</strong></p>
<p>答：不影响，只要clickable和longClickable有一个为真，那么onTouchEvent就返回true。</p>
<p><strong>19.requestDisallowInterceptTouchEvent 可以在子元素中干扰父元素的事件分发吗？如果可以，是全部都可以干扰吗？</strong></p>
<p>答：肯定可以，但是down事件干扰不了。</p>
<p><strong>20.dispatchTouchEvent每次都会被调用吗？</strong></p>
<p>答：是的，onInterceptTouchEvent则不会。</p>
<p><strong>21.滑动冲突问题如何解决 思路是什么？</strong></p>
<p>答。要解决滑动冲突 其实最主要的就是有一个核心思想。你到底想在一个事件序列中，让哪个view 来响应你的滑动？比如 从上到下滑，是哪个view来处理这个事件，从左到右呢？</p>
<p>用业务需求 来想明白以后 剩下的 其实就很好做了。核心的方法 就是2个 外部拦截也就是父亲拦截，另外就是内部拦截，也就是子view拦截法。 学会这2种 基本上所有的滑动冲突</p>
<p>都是这2种的变种，而且核心代码思想都一样。</p>
<p>外部拦截法：思路就是重写父容器的onInterceptTouchEvent即可。子元素一般不需要管。可以很容易理解，因为这和android自身的事件处理机制 逻辑是一模一样的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onInterceptTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">boolean</span> intercepted = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> x = (<span class="keyword">int</span>) ev.getX();</div><div class="line"></div><div class="line">        <span class="keyword">int</span> y = (<span class="keyword">int</span>) ev.getY();</div><div class="line"></div><div class="line">        <span class="keyword">switch</span> (ev.getAction()) &#123;</div><div class="line"></div><div class="line">            <span class="comment">//down事件肯定不能拦截 拦截了后面的就收不到了</span></div><div class="line"></div><div class="line">            <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</div><div class="line"></div><div class="line">                intercepted = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">                <span class="keyword">break</span>;</div><div class="line"></div><div class="line">            <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (你的业务需求) &#123;</div><div class="line"></div><div class="line">                    <span class="comment">//如果确定拦截了 就去自己的onTouchEvent里 处理拦截之后的操作和效果 即可了</span></div><div class="line"></div><div class="line">                    intercepted = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line"></div><div class="line">                    intercepted = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="keyword">break</span>;</div><div class="line"></div><div class="line">            <span class="keyword">case</span> MotionEvent.ACTION_UP:</div><div class="line"></div><div class="line">                <span class="comment">//up事件 我们一般都是返回false的 一般父容器都不会拦截他。 因为up是事件的最后一步。这里返回true也没啥意义</span></div><div class="line"></div><div class="line">                <span class="comment">//唯一的意义就是因为 父元素 up被拦截。导致子元素 收不到up事件，那子元素 就肯定没有onClick事件触发了，这里的</span></div><div class="line"></div><div class="line">                <span class="comment">//小细节 要想明白</span></div><div class="line"></div><div class="line">                intercepted = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">                <span class="keyword">break</span>;</div><div class="line"></div><div class="line">            <span class="keyword">default</span>:</div><div class="line"></div><div class="line">                <span class="keyword">break</span>;</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> intercepted;</div><div class="line"></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>内部拦截法：内部拦截法稍微复杂一点，就是事件到来的时候，父容器不管，让子元素自己来决定是否处理。如果消耗了 就最好，没消耗 自然就转给父容器处理了。</p>
<p>子元素代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> x = (<span class="keyword">int</span>) event.getX();</div><div class="line"></div><div class="line">        <span class="keyword">int</span> y = (<span class="keyword">int</span>) event.getY();</div><div class="line"></div><div class="line">        <span class="keyword">switch</span> (event.getAction()) &#123;</div><div class="line"></div><div class="line">            <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</div><div class="line"></div><div class="line">                getParent().requestDisallowInterceptTouchEvent(<span class="keyword">true</span>);</div><div class="line"></div><div class="line">                <span class="keyword">break</span>;</div><div class="line"></div><div class="line">            <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (如果父容器需要这个点击事件) &#123;</div><div class="line"></div><div class="line">                    getParent().requestDisallowInterceptTouchEvent(<span class="keyword">false</span>);</div><div class="line"></div><div class="line">                &#125;<span class="comment">//否则的话 就交给自己本身view的onTouchEvent自动处理了</span></div><div class="line"></div><div class="line">                <span class="keyword">break</span>;</div><div class="line"></div><div class="line">            <span class="keyword">case</span> MotionEvent.ACTION_UP:</div><div class="line"></div><div class="line">                <span class="keyword">break</span>;</div><div class="line"></div><div class="line">            <span class="keyword">default</span>:</div><div class="line"></div><div class="line">                <span class="keyword">break</span>;</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.dispatchTouchEvent(event);</div><div class="line"></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>父亲容器代码也要修改一下，其实就是保证父亲别拦截down：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onInterceptTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (ev.getAction() == MotionEvent.ACTION_DOWN) &#123;</div><div class="line"></div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line"></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<hr>
<p>未经许可不得转载，转载请注明zilianliuxue的blog,本人保留所有版权。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为转载的，作者希尔瓦娜斯女神&lt;/p&gt;
&lt;h1 id=&quot;Android-View事件机制&quot;&gt;&lt;a href=&quot;#Android-View事件机制&quot; class=&quot;headerlink&quot; title=&quot;Android View事件机制&quot;&gt;&lt;/a&gt;Android View事件
    
    </summary>
    
      <category term="android" scheme="http://zilianliuxue.github.io/categories/android/"/>
    
    
      <category term="view事件机制" scheme="http://zilianliuxue.github.io/tags/view%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>git命令使用大全</title>
    <link href="http://zilianliuxue.github.io/2016/08/20/git%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8%E5%A4%A7%E5%85%A8/"/>
    <id>http://zilianliuxue.github.io/2016/08/20/git命令使用大全/</id>
    <published>2016-08-19T22:48:00.000Z</published>
    <updated>2016-08-19T23:21:00.740Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ADD-AND-COMMIT"><a href="#ADD-AND-COMMIT" class="headerlink" title="ADD AND COMMIT"></a>ADD AND COMMIT</h2><pre><code>1. git init    
</code></pre><p>初始化一个 Git 仓库（repository），即把当前所在目录变成 Git 可以管理的仓库。</p>
<pre><code>2. git add 文件
</code></pre><p>把文件添加到 暂存区（stage），可被 track 追踪纪录下来。可多次使用来添加多个文件。</p>
<pre><code>3. git add * 
</code></pre><p>添加所有修改到暂存区，效果同 git add all，待验证。</p>
<pre><code>4. git add -A
</code></pre><p>暂存所有的文件，包括新增加的、修改的和删除的文件。</p>
<pre><code>5. git add .
</code></pre><p>暂存新增加的和修改的文件，不包括已删除的文件。即当前目录下所有文件。</p>
<pre><code>6. git add -u
</code></pre><p>暂存修改的和删除的文件，不包括新增加的文件。</p>
<pre><code>7. git add -i
</code></pre><p>交互式添加文件到暂存区。</p>
<pre><code>8. git add -p
</code></pre><p>暂存文件的一部分。</p>
<pre><code>9. git commit -m &quot;本次提交说明&quot;
</code></pre><p>一次性把暂存区所有文件修改提交到仓库的当前分支。注意：提交信息可为中文也可为英文，若为英文则通常用一般现在时。如果不加参数 -m 则会跳转到编辑器强制填写提交说明信息。</p>
<pre><code>10. git commit -am &quot;本次提交说明&quot;
</code></pre><p>使用该命令，Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 git add 步骤，参数 -am 也可写成 -a -m。“在 oh-my-zsh 下，直接用 gcam “message” 就搞定了”，—魔都三帅语。</p>
<pre><code>11. git commit --amend
</code></pre><p>重新提交，最终只会有一个提交，第二次提交将代替第一次提交的结果。尤其适用于提交完了才发现漏掉了几个文件没有添加，或者提交信息写错了的情况。</p>
<pre><code>12. git commit --amend --reset-author
</code></pre><p>在上一次 commit 之后想重新更新一下时间。amend 实际上修改了上一个 commit。所以如果已经 push 了上一个 commit，请尽量不要 amend。如果一定要 amend 已经 push 了的 commit，请确保这个 commit 所在的 branch 只有你一个人使用（否则会给其他人带来灾难），然后在 amend 之后使用 git push –force。只要多加小心，该命令貌似没什么卵用。</p>
<pre><code>13. git commit -p
</code></pre><p>commit 文件的一部分，适合工作量比较大的情况。之后，Git 会对每块修改弹出一个提示，询问你是否 stage，按 y/n 来选择是否 commit 这块修改，? 可以查看其他操作的说明。</p>
<h2 id="DIFF-AND-SHOW"><a href="#DIFF-AND-SHOW" class="headerlink" title="DIFF AND SHOW"></a>DIFF AND SHOW</h2><pre><code>1. git status
</code></pre><p>显示当前仓库的最新状态。提交之后，工作区就是“干净的”，即没有新的修改；有未提交文件时，最上面显示的是在 staging area，即将被 commit 的文件；中间显示没有 stage 的修改了的文件，最下面是新的还没有被 Git track 的文件。“在 oh-my-zsh 下，输入 gst 就出来了，谁用谁知道，装逼利器，效率杠杠的”，—魔都三帅语。</p>
<pre><code>2. git status -s 或 git status --short
</code></pre><p>状态简览。输入此命令后，有如下几种情况（总共5种情况）：新添加的未跟踪文件前面有 ?? 标记，新添加到暂你可能注意到了 M 有两个可以出现的位置，出现在右边的 M 表示该文件被修改了但是还没放入暂存区，出现在靠左边的 M 表示该文件被修改了并放入了暂存区。</p>
<pre><code>3. git diff
</code></pre><p>查看工作区中的修改。</p>
<pre><code>4. git diff --staged 或 git diff --cached
</code></pre><p>查看暂存区中的修改。</p>
<pre><code>5. git diff &lt;commit id1&gt; &lt;commit id2&gt;
</code></pre><p>比较两次 commit 之间的差异。</p>
<pre><code>6. git diff &lt;branch1&gt; &lt;branch2&gt;
</code></pre><p>在两个 branch 之间比较。</p>
<pre><code>7. git diff 文件
</code></pre><p>查看指定文件具体修改了哪些内容。</p>
<pre><code>8. git diff HEAD -- 文件
</code></pre><p>查看版本库最新版本和工作区之间的区别，貌似没什么卵用。</p>
<pre><code>9. git difftool --tool-help
</code></pre><p>查看系统支持哪些 Git Diff 插件，貌似没什么卵用。</p>
<pre><code>10. git show
</code></pre><p>查看最后一个 commit 的修改。</p>
<pre><code>11. git show HEAD~3
</code></pre><p>查看倒数第四个 commit 的修改，HEAD~3 就是向前数三个的 commit，即倒数第四个 commit。</p>
<pre><code>12. git show deadbeef
</code></pre><p>查看 hash 为 deadbeef 的 commit 的修改。</p>
<pre><code>13. git blame 文件
</code></pre><p>查看谁什么时间改了哪些文件。</p>
<h2 id="LOG-AND-RESET"><a href="#LOG-AND-RESET" class="headerlink" title="LOG AND RESET"></a>LOG AND RESET</h2><pre><code>1. git log
</code></pre><p>显示从最近到最远的提交日志，包括每个提交的 SHA-1 校验和、作者的名字和电子邮件地址、提交时间以及提交说明等基本信息。</p>
<pre><code>2. git log -p -2
</code></pre><p>除显示基本信息之外，还显示每次提交的内容差异，-2 意思是仅显示最近两次提交。特别适用于进行代码审查，或者快速浏览某个搭档提交的 commit 所带来的变化。</p>
<pre><code>3. git log --start
</code></pre><p>显示每次提交的简略的统计信息，貌似不太好用。</p>
<pre><code>4. git log --graph
</code></pre><p>查看分支合并图。</p>
<pre><code>5. git log --pretty=oneline
</code></pre><p>简化日志信息，将每个提交放在一行显示，查看的提交数很大时非常有用，也可带有 –graph 参数，效果同 git config format.pretty oneline。</p>
<pre><code>6. git log --graph --pretty=oneline --abbrev-commit
</code></pre><p>查看分支的合并情况，包括分支合并图、一行显示、提交校验码缩略显示。</p>
<pre><code>7. git log --oneline --decorate
</code></pre><p>查看各个分支当前所指的提交对象（commit object）。Git 仓库中有五个对象：三个 blob 对象（保存着文件快照）、一个树对象（记录着目录结构和 blob 对象索引）以及一个提交对象（包含着指向前述树对象的指针和所有提交信息）。</p>
<pre><code>8. git log --oneline --decorate --graph --all
</code></pre><p>查看分叉历史，包括：提交历史、各个分支的指向以及项目的分支分叉情况。</p>
<pre><code>9. git reset --hard HEAD^
</code></pre><p>回退到上一个版本。同理，回退到上上个版本为：HEAD^ ^， 回退到上100个版本为：HEAD-100，貌似波浪号 ~ 也可以，变成倒数第101个。</p>
<pre><code>10. git reflog
</code></pre><p>纪录每一次命令，可用于查找某一提交版本的 commit id。</p>
<pre><code>11. git reset --hard &lt;commit id&gt;
</code></pre><p>回退到某一提交过的版本，如果已经 push，则回退的意义不大了。恢复一个彻底删掉的 commit，见链接：<a href="https://github.com/xhacker/GitProTips/blob/master/zh_CN.md#别人-push-了修改我无法-push-了怎么办。" target="_blank" rel="external">https://github.com/xhacker/GitProTips/blob/master/zh_CN.md#别人-push-了修改我无法-push-了怎么办。</a></p>
<h2 id="WORKING-AREA-AND-REPO-AREA"><a href="#WORKING-AREA-AND-REPO-AREA" class="headerlink" title="WORKING AREA AND REPO AREA"></a>WORKING AREA AND REPO AREA</h2><pre><code>1. 工作区（Working Directory）
</code></pre><p>项目所在的文件目录。</p>
<pre><code>2. 版本库（Repository）
</code></pre><p>工作区有一个隐藏目录文件 .git（可通过命令 ls -ah 查看隐藏文件），这就是 Git 的版本库。版本库里主要有称为 stage 的暂存区、Git 自动创建的 master 分支，以及指向 master 的一个指针 HEAD，表示版本库的最新版本。</p>
<h2 id="RESET-AND-REVERT"><a href="#RESET-AND-REVERT" class="headerlink" title="RESET AND REVERT"></a>RESET AND REVERT</h2><pre><code>1. git checkout -- 文件
</code></pre><p>丢弃工作区的修改，包括修改后还没有放到暂存区和添加到暂存区后又作了修改两种情况。总之，让该文件回到最近一次 git commit 或 git add 之后的状态。注意：没有 – ，就变成了切换分支的命令了。郭神的书 P195 没有 – 符号，可能是笔误。</p>
<pre><code>2. git reset HEAD 文件
</code></pre><p>把暂存区的修改撤销（unstage），回退到工作区。注意：在 Git 中任何已提交的东西几乎总是可以恢复的。甚至那些被删除的分支中的提交或使用 –amend 选项覆盖的提交也可以恢复。然而，任何未提交的东西丢失后很可能再也找不到了。</p>
<pre><code>3. git reset --hard
</code></pre><p>重置所有文件到未修改的状态。</p>
<pre><code>4. git reset &lt;commit SHA&gt;
</code></pre><p>重置到某个 commit。</p>
<pre><code>5. git reset HEAD~1
</code></pre><p>将当前 branch 重置为倒数第二个 commit（即丢弃最后一个 commit）。git reset 有三个参数可以选择，–soft、–mixed 和 –hard。</p>
<pre><code>6. git reset --soft
</code></pre><p>修改最后一个 commit。貌似没什么卵用。</p>
<pre><code>7. git revert &lt;commit id&gt;
</code></pre><p>还原某个 commit。还原（revert）的实质是产生一个新的 commit，内容和要还原的 commit 完全相反。比如，A commit 在 main.c 中增加了三行，revert A 产生的 commit 就会删除这三行。如果我们非常确定之前的某个 commit 产生了 bug，最好的办法就是 revert 它。git revert 后 git 会提示写一些 commit message，此处最好简单描述为什么要还原；而重置（reset）会修改历史，常用于还没有 push 的本地 commits。</p>
<pre><code>8. git revert HEAD
</code></pre><p>还原到上次 commit。</p>
<h2 id="REMOVE"><a href="#REMOVE" class="headerlink" title="REMOVE"></a>REMOVE</h2><pre><code>1. git rm 文件
</code></pre><p>把文件从版本库中删除，不会再追踪到。</p>
<pre><code>2. git rm -f 文件
</code></pre><p>强制删除版本库中有修改的文件。</p>
<pre><code>3. git rm --cached 文件
</code></pre><p>把文件从版本库中删除，但让文件保留在工作区且不被 Git 继续追踪（track），通常适用于在 rm 之后把文件添加到 .gitignore 中的情况。</p>
<pre><code>4. git rm log/\*.log
</code></pre><p>删除 log/ 目录下扩展名为 .log 的所有文件。</p>
<pre><code>5. git rm \*~
</code></pre><p>删除以 ~ 结尾的所有文件。</p>
<h2 id="REMOTE-REPO"><a href="#REMOTE-REPO" class="headerlink" title="REMOTE REPO"></a>REMOTE REPO</h2><h2 id="REMOTE-AND-PUSH"><a href="#REMOTE-AND-PUSH" class="headerlink" title="REMOTE AND PUSH"></a>REMOTE AND PUSH</h2><pre><code>1. git remote
</code></pre><p>查看已经配置的远程仓库服务器，效果同 git remote show。</p>
<pre><code>2. git remote -v
</code></pre><p>显示需要读写远程仓库使用的 Git 保存的简写与其对应的 URL。</p>
<pre><code>3. git ls-remote &lt;remote-name&gt;
</code></pre><p>显示获得远程引用的完整列表。</p>
<pre><code>4. git remote show &lt;remote-name&gt;
</code></pre><p>参数 remote-name 通常都是缩写名 origin，可以得到远程分支更为详细的信息以及 pull 和 push 相关提示信息。</p>
<pre><code>5. git remote add &lt;shortname&gt; &lt;url&gt;
</code></pre><p>添加并关联一个远程库。其中，shortname 一般是 origin，也可以是其他字符串，用来代替整个 url。</p>
<pre><code>6. git push
</code></pre><p>推送本地修改到 origin。</p>
<pre><code>7. git push -u origin master
</code></pre><p>关联后，使用该命令第一次推送 master 分支的所有内容，后续再推送的时候就可以省略后面三个参数了，其中参数 u 代表上游（upstream）的意思。</p>
<pre><code>8. git push origin 远程分支（通常是 master）
</code></pre><p>推送最新修改。注意：多人协作时，除了 merge 可能会发生冲突之外，推送时也有可能发生冲突。在他人推送之后是不能立即推送自己的修改的，想想也是，因为可能会覆盖他人的工作，所以必须先拉取（pull）别人的修改合并（merge）之后才能推送。如果不是第一次推送，后面的参数可省略。</p>
<pre><code>9. git push &lt;remote-name&gt; &lt;commit SHA&gt;:&lt;remote-branch_name&gt;
</code></pre><p>push 一部分 commit。例如：git push origin 9790eff:master 即为 push 9790eff 之前的所有 commit 到 master。</p>
<pre><code>10. git remote rename old_name new_name
</code></pre><p>重命名一个远程仓库的简写名。</p>
<pre><code>11. git remote rm &lt;remote-name&gt;
</code></pre><p>移除一个远程仓库。</p>
<pre><code>12. git remote add origin http://github.com/username/&lt;repo name&gt;.git
</code></pre><p>Create a remote repo named origin pointing at your Github repo (after you’ve already created the repo on Github) (used if you git init since the repo you created locally isn’t linked to a remote repo yet).</p>
<pre><code>13. git remote add origin git@github.com:username/&lt;repo name&gt;.git
</code></pre><p>Create a remote repo named origin pointing at your Github repo (using SSH url instead of HTTP url).</p>
<h2 id="CLONE"><a href="#CLONE" class="headerlink" title="CLONE"></a>CLONE</h2><pre><code>1. git clone git@github.com:username/&lt;repo name&gt;.git
</code></pre><p>从远程库（origin）克隆一份到本地，仓库名同远程仓库名。</p>
<pre><code>2. git clone https://github.com/username/repo name.git
</code></pre><p>作用同上。但不建议使用 https 协议，原因有二：一是速度慢；二是每次推送必须输入口令，麻烦。但在某些只开放 http 端口的公司内部就无法使用原生的 ssh 协议而只能用 https，仓库名同远程仓库名。</p>
<pre><code>3. git clone &lt;repo url&gt; &lt;folder name&gt;
</code></pre><p>克隆一个仓库到指定文件夹。</p>
<pre><code>4. git clone &lt;repo url&gt; .
</code></pre><p>克隆一个仓库到当前文件夹（应该是空的）。</p>
<h2 id="BRANCH"><a href="#BRANCH" class="headerlink" title="BRANCH"></a>BRANCH</h2><h2 id="BRANCH-AND-MERGE"><a href="#BRANCH-AND-MERGE" class="headerlink" title="BRANCH AND MERGE"></a>BRANCH AND MERGE</h2><pre><code>1. git branch
</code></pre><p>列出本地当前所有分支，方便查看。当前分支前面会标有一个 * 号。</p>
<pre><code>2. git branch -r
</code></pre><p>查看远程分支列表。</p>
<pre><code>3. git branch -a
</code></pre><p>显示所有分支，包括本地和远程。</p>
<pre><code>4. git branch -v
</code></pre><p>查看每一次分支的最后一次提交。</p>
<pre><code>5. git branch -vv
</code></pre><p>查看设置的所有跟踪分支。将所有的本地分支列出来并且包含更多的信息，如每一个分支正在跟踪哪个远程分支与本地分支是否是领先、落后或是都有。</p>
<pre><code>6. git branch --merged
</code></pre><p>查看所有已经被 merge 的 branch。</p>
<pre><code>7. git branch --no-merged
</code></pre><p>查看所有还没被 merge 的 branch。</p>
<pre><code>8. git branch --merged | xargs git branch -d
</code></pre><p>删除所有已经被 merge 的 branch。</p>
<pre><code>9. git checkout -b 分支
</code></pre><p>创建并切换到新的分支，相当于下面两条命令：git branch 分支 + git checkout 分支。</p>
<pre><code>10. git checkout -
</code></pre><p>切换到上一个 branch。</p>
<pre><code>11. git cherry-pick &lt;commit id&gt;
</code></pre><p>假如我们在某个 branch 做了一大堆 commit，而当前 branch 想应用其中的一个，可以使用该命令。</p>
<pre><code>12. git merge 分支
</code></pre><p>合并指定分支到当前所在的分支。</p>
<pre><code>13. git merge --no-ff -m &quot;提交说明信息&quot; 分支
</code></pre><p>参数 –no-ff 表示禁用 Fast forward 快进模式，用普通模式合并，这样合并后的历史有分支，能看出来曾经做过合并，而 fast forwad 合并就看不出来曾经做过合并。</p>
<pre><code>14. git branch -d 分支
</code></pre><p>普通删除分支（相对强制删除而言）。一般情况下，先合并完分支，然后再删除，否则会删除失败，除非使用 -D 参数强制删除。注意：因为创建、合并和删除分支非常快，所以 Git 鼓励使用分支完成某个任务，合并后再删除分支，这个直接在 master 分支上工作效果是一样的，但过程更安全。</p>
<pre><code>15. git branch -D 分支
</code></pre><p>强行删除分支，尤其适用分支内容有了新的修改但还没有被合并的情况。</p>
<pre><code>16. git push origin --delete 远程分支 或 git push origin:远程分支
</code></pre><p>删除一个远程分支。基本上这个命令做的只是从服务器上移除这个指针。 Git 服务器通常会保留数据一段时间直到垃圾回收运行，所以如果不小心删除掉了，通常是很容易恢复的。</p>
<pre><code>17. git push origin -delete 分支
</code></pre><p>在本地和远程同步删除分支。</p>
<pre><code>18. git rebase 目标分支（通常是 master）
</code></pre><p>在本地 master 上进行变基操作。注意：merge 与 rebase 都是整合来自不同分支的修改。</p>
<p>merge 会把两个分支的最新快照以及二者最近的共同祖先进行三方合并，合并的结果是生成一个新的快照（并提交）。<br>rebase 会把提交到某一分支（当前分支）上的所有修改都转移至另一分支（目标分支）上，就好像“重新播放”一样。<br>变基是将一系列提交按照原有次序依次应用到另一分支上，而合并是把最终结果合在一起。简言之：这两种整合方法的最终结果没有任何区别，但是变基使得提交历史更加整洁。<br>采用变基操作后，项目的最终维护者就不再需要进行整合工作，只需要快进合并便可。</p>
<pre><code>git rebase –ongo
</code></pre><p>目标分支 第一分支 第二分支：选中在第二分支里但不在第一分支里的修改，将它们在目标分支（通常是 master）上重演。<br>变基有风险，需要遵守的准则是：不要对在你的仓库外有副本的分支执行变基。否则，会导致混乱。总的原则是，只对尚未推送或分享给别人的本地修改执行变基操作清理历史，从不对已推送至别处的提交执行变基操作，这样才能享受到两种方式带来的便利。<br>还可以有这样的命令：</p>
<pre><code>git rebase -i master，git rebase -i 22e21f2，git rebase -i HEAD~3。
</code></pre><p>STASH</p>
<ol>
<li><p>git stash<br>把当前分支的工作现场储存起来，等以后恢复现场后继续工作。一般适用于还没有 commit 的分支代码。</p>
</li>
<li><p>git stash list<br>查看储存的工作现场纪录列表。</p>
</li>
<li><p>git stash apply + git stash drop<br>用 git stash apply 命令恢复最近 stash 过的工作现场，但是恢复后，stash 内容并不删除，用 git stash drop 命令来删除。apply 和 drop 后面都可以加上某一指定的 stash_id。</p>
</li>
<li><p>git stash pop<br>相当于上面两条命令，恢复回到工作现场的同时把 stash 内容也删除了。</p>
</li>
<li><p>git stash clear<br>清空所有暂存区的 stash 纪录。drop 是只删除一条，当然后面可以跟 stash_id 参数来删除指定的某条纪录，不跟参数就是删除最近的。</p>
</li>
<li><p>git stash apply stash@{0}<br>上面命令中大括号中的数字不是固定的，因为可以多次 stash，恢复的时候，先用 git stash list 命令查看，然后恢复指定的 stash。</p>
</li>
<li><p>git biselect<br>发现了一个 bug，用该命令知道是哪个 commit 导致的，貌似不太好用。</p>
</li>
</ol>
<p>PULL AND PUSH</p>
<ol>
<li><p>git push origin 分支<br>把该分支上的所有本地提交推送到远程库对应的远程分支上。</p>
</li>
<li><p>git checkout 分支 origin/分支<br>如果远程有某一个分支而本地没有，怎用该命令把远程的这个分支迁到本地。</p>
</li>
<li><p>git checkout -b 分支 origin/分支<br>把远程分支迁到本地顺便切换到该分支。</p>
</li>
<li><p>git pull<br>抓取远程库最新提交，拉取并合并。</p>
</li>
<li><p>git fetch<br>没有 merge 的 pull。</p>
</li>
<li><p>git branch –set-upstream 分支 origin/分支<br>建立本地分支和远程分支的关联。</p>
</li>
<li><p>git submodule update –recursive<br>第三方依赖与远程同步，还可以在最后添加 -f 参数。</p>
</li>
</ol>
<h2 id="TAG"><a href="#TAG" class="headerlink" title="TAG"></a>TAG</h2><h2 id="INIT-TAG"><a href="#INIT-TAG" class="headerlink" title="INIT TAG"></a>INIT TAG</h2><pre><code>1. git tag
</code></pre><p>查看所有标签。注意：标签不是按照时间列出，而是按照字母排序，但这并不重要。</p>
<pre><code>2. git show &lt;tag-name&gt;
</code></pre><p>查看标签信息。</p>
<pre><code>3. git tag -l &apos;tag-name&apos;
</code></pre><p>使用特定的模式查找标签。</p>
<pre><code>4. git checkout &lt;tag-name&gt;
</code></pre><p>切换 tag。</p>
<pre><code>5. git tag &lt;tag name&gt; &lt;commit id&gt;
</code></pre><p>在需要打标签的分支上创建一个轻量标签（lightweight），默认为 HEAD，也可以指定一个 commit id。</p>
<pre><code>6. git tag -a &lt;tag-name&gt; -m &quot;标签说明文字&quot; &lt;commit id&gt;
</code></pre><p>创建附注标签（annotated），用 -a 指定标签名，-m 指定说明文字，也可以指定一个 commit id。</p>
<pre><code>7. git tag -a &lt;tag-name&gt; 提交的校验和或部分校验和
</code></pre><p>后期打标签，即对过去的提交打标签。校验和（checksum）：长度为 40位的16进制数的 SHA-1 值字符串。然而，只要没有冲突，通常可以用一个比较短的前缀来表示一个 commit。</p>
<pre><code>8. git tag -s &lt;tag-name&gt; -m &quot;标签说明文字&quot; &lt;commit id&gt;
</code></pre><p>通过 -s 用私钥签名一个标签。签名采用 GPG 签名，因此，必须首先按照 pgp（GnuPG），如果没有找到 gpg，或者没有 gpg 秘钥对，就会报错。如果报错，请参考 GnuPG 帮助文档配置 Key。</p>
<h2 id="MANIPULATE-TAG"><a href="#MANIPULATE-TAG" class="headerlink" title="MANIPULATE TAG"></a>MANIPULATE TAG</h2><pre><code>1. git tag -d &lt;tag-name&gt;
</code></pre><p>删除一个本地标签。因为创建的标签都只存储在本地，不会自动推送到远程。所以，打错的标签可以在本地安全删除。</p>
<pre><code>2. git push origin &lt;tag-name&gt;
</code></pre><p>推送本地某个标签到远程，默认情况下，git push 命令并不会推送标签到远程，必须显示推送。</p>
<pre><code>3. git push origin --tags
</code></pre><p>参数 –tags 表示一次性推送全部未推送到远程的本地标签，当其他人从仓库中克隆或拉取，他们也能得到那些标签。</p>
<pre><code>4. git push origin :refs/tags/&lt;tag-name&gt;
</code></pre><p>删除一个远程标签，先从本地删除，再用该命令从远程删除。</p>
<pre><code>5. git checkout -b &lt;branch-name&gt; &lt;tag-name&gt;
</code></pre><p>在特定的标签上创建一个新分支，貌似没什么卵用。</p>
<h2 id="CUSTOM-GIT"><a href="#CUSTOM-GIT" class="headerlink" title="CUSTOM GIT"></a>CUSTOM GIT</h2><h2 id="IGNORE"><a href="#IGNORE" class="headerlink" title="IGNORE"></a>IGNORE</h2><pre><code>1. git add -f 文件
</code></pre><p>使用 -f 参数，强制添加被 .gitignore 忽略的文件到 Git。</p>
<pre><code>2. git check-ignore -v 文件
</code></pre><p>可能是 .gitignore 写得有问题，使用该命令找出到底哪个命令写错了。</p>
<pre><code>3. https://github.com/github/gitignore
</code></pre><p>GitHub 上的一个十分详细的针对数十种项目及语言的 .gitignore 文件列表。</p>
<p>注意：</p>
<p>忽略某些文件时，需要编写 .gitignore 文件；<br>.gitignore 文件本身要放到版本库里，并且可以对 .gitignore 做版本管理。<br>ALIAS</p>
<pre><code>1. git config --global alias.st status
</code></pre><p>使用 git st 代替 git status 命令。</p>
<pre><code>2. git config --global alias.co checkout
</code></pre><p>使用 git co 代替 git checkout 命令。</p>
<pre><code>3. git config --global alias.cm commit
</code></pre><p>使用 git cm 代替 git commit 命令。</p>
<pre><code>4. git config --global alias.br branch
</code></pre><p>使用 git br 代替 git branch 命令。</p>
<pre><code>5. git config --global alias.unstage &apos;reset HEAD --&apos;
</code></pre><p>使用 git unstage 文件 命令代替 git reset HEAD – 文件 命令。</p>
<pre><code>6. git config --global alias.last &apos;log -1&apos;
</code></pre><p>配置一个 git last 命令，让其显示最近一次的提交信息。</p>
<pre><code>`7. git config --global alias.lg &quot;log --color --graph --`pretty=format:&apos;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&apos; --abbrev-commit&quot;
</code></pre><p>丧心病狂地配置 git lg 命令，让显示 log 更加优雅，逼格更高。</p>
<ol>
<li>git config –global alias.visual ‘!gitk’<br>Git 只是简单地将别名替换为对应的命令。，如果想要执行外部命令而不是一个 Git 子命令，可以在命令前面加入 ! 符号。 如果自己要写一些与 Git 仓库协作的工具的话，那会很有用。貌似没什么卵用。</li>
</ol>
<h2 id="HELP"><a href="#HELP" class="headerlink" title="HELP"></a>HELP</h2><blockquote>
<ol>
<li>git help <key></key></li>
<li>git <key> –help</key></li>
<li>man git-<key> </key></li>
<li>git –help<h2 id="OTHERS"><a href="#OTHERS" class="headerlink" title="OTHERS"></a>OTHERS</h2></li>
</ol>
</blockquote>
<pre><code>1. git config -l 或 git config --list
</code></pre><p>列举所有 Git 能找到的配置，如果有重复的变量名，Git 会使用它找到的每一个变量的最后一个配置。</p>
<pre><code>2. git config &lt;key&gt;
</code></pre><p>检查 Git 的某一项配置。</p>
<pre><code>3. git config --glabal core.editor &lt;vim/emacs/...&gt;
</code></pre><p>配置默认文本编辑器。</p>
<pre><code>4. git config --global color.ui true 
</code></pre><p>让 Git 显示颜色，使命令输出看起来更醒目。</p>
<pre><code>5. git config core.ignorecase false
</code></pre><p>Git 是大小写不敏感的，如果要大小写敏感需要执行此命令。</p>
<pre><code>6. git config --global core.quotepath false
</code></pre><p>设置显示中文文件名。</p>
<pre><code>7. it config --global credential.helper cache
</code></pre><p>如果正在使用 HTTPS URL 来推送，Git 服务器会询问用户名与密码。 默认情况下它会在终端中提示服务器是否允许你进行推送。如果不想在每一次推送时都输入用户名与密码，可以设置一个 “credential cache”。 最简单的方式就是将其保存在内存中几分钟，使用该命令即可，貌似没什么卵用。</p>
<pre><code>8. git config --global user.name &quot;your name&quot;
   git config --global user.email &quot;your email&quot;
</code></pre><p>设置 commit 中的姓名和 email，去掉 –global 参数则为针对每个 repo 单独设定姓名和邮箱。</p>
<pre><code>9. git commit --author &quot;your name &lt;your email&gt;&quot;
</code></pre><p>以其他身份 commit。</p>
<pre><code>10. git mv old_filename new_filename
</code></pre><p>重命名文件。相当于下面三条命令：</p>
<ul>
<li>mv old_filename new_filename</li>
<li>git rm old_filename<ul>
<li>git add new_filename</li>
</ul>
</li>
</ul>
<hr>
<pre><code>11. git log 常用选项
</code></pre><ul>
<li><p>-p — 按补丁格式显示每个更新之间的差异。</p>
</li>
<li><p>-stat — 显示每次更新的文件修改统计信息。</p>
</li>
<li><p>-shortstat — 只显示 –stat 中最后的行数修改添加移除统计。</p>
</li>
<li><p>-name-only — 仅在提交信息后显示已修改的文件清单。</p>
</li>
<li><p>-name-status – 显示新增、修改、删除的文件清单。</p>
</li>
<li><p>-abbrev-commit — 仅显示 SHA-1 的前几个字符，而非所有的 40 个字符。</p>
</li>
<li><p>-relative-date — 使用较短的相对时间显示（比如，“2 weeks ago”）。</p>
</li>
<li><p>-graph — 显示 ASCII 图形表示的分支合并历史。</p>
</li>
<li><p>-pretty — 使用其他格式显示历史提交信息。可用的选项包括 oneline，short，full，fuller 和 format（后跟指定格式）。</p>
</li>
</ul>
<hr>
<pre><code>12. git log --pretty=format：&quot;%h - %an, %ar : %s&quot;
</code></pre><p>自定义 log 显示样式，也可带有 –graph 参数。常用的格式占位符写法及其代表的意义：</p>
<ul>
<li><p>%H — 提交对象（commit）的完整哈希字串</p>
</li>
<li><p>%h — 提交对象的简短哈希字串</p>
</li>
<li><p>%T — 树对象（tree）的完整哈希字串</p>
</li>
<li><p>%t — 树对象的简短哈希字串</p>
</li>
<li><p>%P — 父对象（parent）的完整哈希字串</p>
</li>
<li><p>%p — 父对象的简短哈希字串</p>
</li>
<li><p>%an — 作者（author）的名字</p>
</li>
<li><p>%ae — 作者的电子邮件地址</p>
</li>
<li><p>%ad — 作者修订日期（可以用 –date= 选项定制格式）</p>
</li>
<li><p>%ar — 作者修订日期，按多久以前的方式显示</p>
</li>
<li><p>%cn — 提交者(committer)的名字</p>
</li>
<li><p>%ce — 提交者的电子邮件地址</p>
</li>
<li><p>%cd — 提交日期</p>
</li>
<li><p>%cr — 提交日期，按多久以前的方式显示</p>
</li>
<li><p>%s — 提交说明</p>
</li>
</ul>
<hr>
<pre><code>13. git log --since=2.weeks
</code></pre><p>显示按照时间限制的 log 信息，这个时间格式可以是：“2008-01-15” 或 “2 years 1 day 3 minutes ago” 等。可用的参数还有：–until，–author，–grep(提交说明中的关键字)等。注意：如果要得到同时满足这两个选项搜索条件的提交，就必须用 –all-match 选项。否则，满足任意一个条件的提交都会被匹配出来。</p>
<pre><code>14. git log -Sfunction_name
</code></pre><p>显示添加或移除某一个特定函数的引用（字符串）的提交。</p>
<pre><code>15. 限制 git log 输出的选项
</code></pre><ul>
<li><p>-(n) — 仅显示最近的 n 条提交</p>
</li>
<li><p>–since, –after — 仅显示指定时间之后的提交。</p>
</li>
<li><p>–until, –before — 仅显示指定时间之前的提交。</p>
</li>
<li><p>–author — 仅显示指定作者相关的提交。</p>
</li>
<li><p>–committer — 仅显示指定提交者相关的提交。</p>
</li>
<li><p>–grep — 仅显示含指定关键字的提交</p>
</li>
<li><p>-S — 仅显示添加或移除了某个关键字的提交</p>
</li>
</ul>
<p>For example，git log –pretty=”%h - %s” –author=gitster –since=”2008-10-01” \ –before=”2008-11-01” –no-merges – t/，即为：查看 Git 仓库中，2008 年 10 月期间，作者提交的但未合并的测试文件。</p>
<h1 id="git"><a href="#git" class="headerlink" title="git"></a>git</h1><hr>
<p>未经许可不得转载，转载请注明zilianliuxue的blog,本人保留所有版权。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;ADD-AND-COMMIT&quot;&gt;&lt;a href=&quot;#ADD-AND-COMMIT&quot; class=&quot;headerlink&quot; title=&quot;ADD AND COMMIT&quot;&gt;&lt;/a&gt;ADD AND COMMIT&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;1. git init   
    
    </summary>
    
      <category term="git" scheme="http://zilianliuxue.github.io/categories/git/"/>
    
    
      <category term="git" scheme="http://zilianliuxue.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>安卓实战开发之JNI再深入了解</title>
    <link href="http://zilianliuxue.github.io/2016/08/06/%E5%AE%89%E5%8D%93%E5%AE%9E%E6%88%98%E5%BC%80%E5%8F%91%E4%B9%8BJNI%E5%86%8D%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3/"/>
    <id>http://zilianliuxue.github.io/2016/08/06/安卓实战开发之JNI再深入了解/</id>
    <published>2016-08-06T04:22:00.000Z</published>
    <updated>2016-08-06T04:22:52.891Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JNI重新认识"><a href="#JNI重新认识" class="headerlink" title="JNI重新认识"></a>JNI重新认识</h2><h3 id="头文件："><a href="#头文件：" class="headerlink" title="头文件："></a>头文件：</h3><p>1.头文件中存放的是对某个库中所定义的函数、宏(define)、类型、全局变量等进行声明，它类似于一份仓库清单。若用户程序中需要使用某个库中的函数，则只需要将该库所对应的头文件include到程序中即可。</p>
<p>2.头文件中定义的是库中所有函数的函数原型。而函数的具体实现则是在库文件中。</p>
<p>3.在连接器连接程序时，会依据用户程序中导入的头文件，将对应的库函数导入到程序中。头文件以.h为后缀名。 </p>
<p>头文件是给编译器用的，库文件是给连接器用的</p>
<p>###　函数库：</p>
<p>1.动态库：在编译用户程序时不会将用户程序内使用的库函数连接到用户程序的目标代码中，只有在运行时，且用户程序执行到相关函数时才会调用该函数库里的相应函数，因此动态函数库所产生的可执行文件比较小。</p>
<p>2.静态库：在编译用户程序时会将其内使用的库函数连接到目标代码中，程序运行时不再需要静态库。使用静态库生成可执行文件比较大。</p>
<p>为什么要进行交互?</p>
<p>首先，java语言提供的类库无法满足要求,且在数学运算,实时渲染的游戏上,音视频处理等方面上与c/c++相比效率稍低。然后，java语言无法直接操作硬件，c/c++代码不仅能操作硬件而且还能发挥硬件最佳性能。接着，使用java调用本地的c/c++代码所写的库，省去了重复开发的麻烦，并且可以利用很多开源的库提高程序效率。</p>
<h3 id="java-call-c"><a href="#java-call-c" class="headerlink" title="java  call c"></a>java  call c</h3><p>Java调用C/C++大概有这样几个步骤</p>
<ol>
<li>编写带有native方法的Java类, 使用javac工具编译Java类</li>
<li>使用javah来生成与native方法对应的头文件</li>
<li>实现相应的头文件, 并编译为动态链接库</li>
</ol>
<p>我们对这个还是很清楚的，看代码：</p>
<p>c代码：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line">//</div><div class="line">// Created by Administrator on 2016/8/1.</div><div class="line">//</div><div class="line">#include "JNIUtils.h"</div><div class="line">#include &lt;string.h&gt;</div><div class="line">#include&lt;stdio.h&gt;</div><div class="line">#include&lt;stdlib.h&gt;</div><div class="line">#include &lt;android/log.h&gt;</div><div class="line">/**</div><div class="line"> * 把一个jstring转换成一个c语言的char* 类型.</div><div class="line"> */</div><div class="line">char* _JString2CStr(JNIEnv* env, jstring jstr) &#123;</div><div class="line">char* rtn = NULL;</div><div class="line">jclass clsstring = (*env)-&gt;FindClass(env, "java/lang/String");</div><div class="line">jstring strencode = (*env)-&gt;NewStringUTF(env,"GB2312");</div><div class="line">jmethodID mid = (*env)-&gt;GetMethodID(env, clsstring, "getBytes", "(Ljava/lang/String;)[B");</div><div class="line">jbyteArray barr = (jbyteArray)(*env)-&gt;CallObjectMethod(env, jstr, mid, strencode); // String .getByte("GB2312");</div><div class="line">jsize alen = (*env)-&gt;GetArrayLength(env, barr);</div><div class="line">jbyte* ba = (*env)-&gt;GetByteArrayElements(env, barr, JNI_FALSE);</div><div class="line">if(alen &gt; 0) &#123;</div><div class="line">rtn = (char*)malloc(alen+1); //"\0"</div><div class="line">memcpy(rtn, ba, alen);</div><div class="line">rtn[alen]=0;</div><div class="line">&#125;</div><div class="line">(*env)-&gt;ReleaseByteArrayElements(env, barr, ba,0);</div><div class="line">return rtn;</div><div class="line">&#125;</div><div class="line"></div><div class="line">JNIEXPORT jint JNICALL Java_com_losileeya_jnimaster_JNIUtils_intMethod</div><div class="line">                         (JNIEnv *env, jclass jobj,jint num)&#123;</div><div class="line">            return num*num;</div><div class="line">   &#125;</div><div class="line">JNIEXPORT jboolean JNICALL Java_com_losileeya_jnimaster_JNIUtils_booleanMethod</div><div class="line">                             (JNIEnv * env, jclass jobj,jboolean boolean)&#123;</div><div class="line">            return !boolean;</div><div class="line">     &#125;</div><div class="line">JNIEXPORT jstring JNICALL Java_com_losileeya_jnimaster_JNIUtils_stringMethod</div><div class="line">                            (JNIEnv * env, jclass jobj,jstring jstr)&#123;</div><div class="line">//jstring jstr--&gt;char*</div><div class="line">char* fromJava = _JString2CStr(env,jstr);</div><div class="line">char* fromC = "add I am from C!! ";</div><div class="line">//字符串的拼接函数，会把拼接后的结果放在第一个参数里面</div><div class="line">strcat(fromJava,fromC);</div><div class="line"></div><div class="line">return (*env)-&gt;NewStringUTF(env,fromJava);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">JNIEXPORT jint JNICALL Java_com_losileeya_jnimaster_JNIUtils_intArrayMethod</div><div class="line">      (JNIEnv * env, jclass jobj,jintArray array)&#123;</div><div class="line">int i, sum = 0;</div><div class="line">jsize len = (*env)-&gt;GetArrayLength(env, array);</div><div class="line">jint *body = (*env)-&gt;GetIntArrayElements(env, array, 0);</div><div class="line"></div><div class="line">for (i = 0; i &lt; len; ++i)</div><div class="line">&#123;</div><div class="line">sum += body[i];</div><div class="line">&#125;</div><div class="line">(*env)-&gt;ReleaseIntArrayElements(env, array, body, 0);</div><div class="line">return sum;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>c++代码：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">/</div><div class="line">// Created by Administrator on 2016/8/1.</div><div class="line">//</div><div class="line">#include "JNIUtils.h"</div><div class="line">#include &lt;string.h&gt;</div><div class="line">#include&lt;stdlib.h&gt;</div><div class="line">#include&lt;stdio.h&gt;</div><div class="line">#include &lt;android/log.h&gt;</div><div class="line">/**</div><div class="line"> * 把一个jstring转换成一个c++语言的char* 类型.</div><div class="line"> */</div><div class="line">char* _JString2CStr(JNIEnv* env, jstring jstr) &#123;</div><div class="line">char* rtn = NULL;</div><div class="line">jclass clsstring = env-&gt;FindClass( "java/lang/String");</div><div class="line">jstring strencode = env-&gt;NewStringUTF("GB2312");</div><div class="line">jmethodID mid = env-&gt;GetMethodID( clsstring, "getBytes", "(Ljava/lang/String;)[B");</div><div class="line">jbyteArray barr = (jbyteArray)env-&gt;CallObjectMethod(jstr, mid, strencode); // String .getByte("GB2312");</div><div class="line">jsize alen = env-&gt;GetArrayLength( barr);</div><div class="line">jbyte* ba = env-&gt;GetByteArrayElements( barr, JNI_FALSE);</div><div class="line">if(alen &gt; 0) &#123;</div><div class="line">rtn = (char*)malloc(alen+1); //"\0"</div><div class="line">memcpy(rtn, ba, alen);</div><div class="line">rtn[alen]=0;</div><div class="line">&#125;</div><div class="line">env-&gt;ReleaseByteArrayElements(barr, ba,0);</div><div class="line">return rtn;</div><div class="line">&#125;</div><div class="line"></div><div class="line">JNIEXPORT jint JNICALL Java_com_losileeya_jnimaster_JNIUtils_intMethod(JNIEnv * env, jclass jobj,jint num)&#123;</div><div class="line">return num *num;</div><div class="line">&#125;</div><div class="line">JNIEXPORT jboolean JNICALL Java_com_losileeya_jnimaster_JNIUtils_booleanMethod(JNIEnv * env, jclass jobj,jboolean boolean)&#123;</div><div class="line">return !boolean;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">JNIEXPORT jstring JNICALL Java_com_losileeya_jnimaster_JNIUtils_stringMethod</div><div class="line">        (JNIEnv *env , jclass jobj, jstring jstr)&#123;</div><div class="line">//jstring jstr--&gt;char*</div><div class="line">char* fromJava = _JString2CStr(env,jstr);</div><div class="line">char* fromC = "add I am from C!! ";</div><div class="line">//字符串的拼接函数，会把拼接后的结果放在第一个参数里面</div><div class="line">strcat(fromJava,fromC);</div><div class="line">return env-&gt;NewStringUTF(fromJava);</div><div class="line">&#125;</div><div class="line">JNIEXPORT jint JNICALL Java_com_losileeya_jnimaster_JNIUtils_intArrayMethod(JNIEnv * env, jclass jobj,jintArray array)&#123;</div><div class="line">int sum = 0;</div><div class="line">jsize len = env-&gt;GetArrayLength(array);</div><div class="line">jint *arr = env-&gt;GetIntArrayElements(array, 0);</div><div class="line">for(int i = 0;i&lt;len; i++)&#123;</div><div class="line">sum+=arr[i];</div><div class="line">&#125;</div><div class="line">env-&gt;ReleaseIntArrayElements(array, arr,0);</div><div class="line">return sum;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从上面Native函数的命名上我们可以了解到JNI函数的命名规则： Java代码中的函数声明需要添加native 关键 字；Native的对应函数名要以“Java”开头，后面依次跟上Java的“package名”、“class名”、“函数名”，中间以下划线“” 分割，在package名中的“.”也要改为“_”。此外，关于函数的参数和返回值也有相应的规则。对于Java中的基本类型如int 、double 、char 等，在Native端都有相对应的类型来表示，如jint 、jdouble 、jchar 等；其他的对象类型则统统由jobject 来表示（String 是个例外，由于其使用广泛，故在Native代码中有jstring 这个类型来表示，正如在上例中返回值String 对应到Native代码中的返回值jstring ）。而对于Java中的数组，在Native中由jarray 对应，具体到基本类型和一般对象类型的数组则有jintArray 等和jobjectArray 分别对应（String 数组在这里没有例外，同样用jobjectArray 表示）。还有一点需要注意的是，在JNI的Native函数中，其前两个参数JNIEnv 和jobject<em> 是必需的——前者是一个JNIEnv 结构体的指针，这个结构体中定义了很多JNI的接口函数指针，使开发者可以使用JNI所定义的接口功能；后者指代的是调用这个JNI函数的Java对象，有点类似于C++中的this 指针。在上述两个参数之后，还需要根据Java端的函数声明依次对应添加参数。在上例中，Java中声明的JNI函数没有参数，则Native的对应函数只有类型为JNIEnv 和jobject</em> 的两个参数。</p>
<p>效果图：</p>
<p><img src="http://img.blog.csdn.net/20160806111333746" alt="这里写图片描述"></p>
<h3 id="c-call-java"><a href="#c-call-java" class="headerlink" title="c call java"></a>c call java</h3><p>一般来说，要在Native代码中访问Java对象，有如下几个步骤：</p>
<ol>
<li><p>得到该Java对象的类定义。JNI定义了jclass 这个类型来表示Java的类的定义，并提供了FindClass接口，根据类的完整的包路径即可得到其jclass 。</p>
</li>
<li><p>根据jclass 创建相应的对象实体，即jobject 。在Java中，创建一个新对象只需要使用new 关键字即可，但在Native代码中创建一个对象则需要两步：首先通过JNI接口GetMethodID得到该类的构造函数，然后利用NewObject接口构造出该类的一个实例对象。</p>
</li>
<li><p>访问jobject 中的成员变量或方法。访问对象的方法是先得到方法的Method ID，然后使用Call<type>Method 接口调用，这里Type对应相应方法的返回值——返回值为基本类型的都有相对应的接口，如CallIntMethod；其他的返回值（包括String） 则为CallObjectMethod。可以看出，创建对象实质上是调用对象的一个特殊方法，即构造函数。访问成员变量的步骤一样：首先 GetFieldID得到成员变量的ID，然后Get/Set<type>Field读/写变量值。</type></type></p>
</li>
</ol>
<p>寻找class对象, 并实例化</p>
<p>JVM在Java中都是自己启动的, 在C/C++中只能自己来启动了, 启动完之后的事情就和在Java中一样了, 不过要使用C/C++的语法.</p>
<p>获取class对象比较简单, FindClass(env, className).</p>
<pre><code>cls = (*env)-&gt;FindClass(env, &quot;xxxx&quot;);  
</code></pre><p>在Java中的类名格式是java.lang.String, 但是className的格式有点不同, 不是使用’.’作为分割, 而是’/‘, 即java/lang/String.</p>
<p>我们知道Java中构造函数有两种, 一种是默认的没有参数的, 一种是自定义的带有参数的. 对应的在C/C++中, 有两种调用构造函数的方法.</p>
<p>调用默认构造函数</p>
<pre><code>// 调用默认构造函数  obj = (*env)-&gt;AllocObjdect(env, cls);   
</code></pre><p>构造函数也是方法, 类似调用方法的方式.</p>
<pre><code>// 调用指定的构造函数, 构造函数的名字叫做&lt;init&gt;  mid = (*env)-&gt;GetMethodID(env, cls, &quot;&lt;init&gt;&quot;, &quot;()V&quot;);  obj = (*env)-&gt;NewObject(env, cls, mid);  
</code></pre><p>调用方法和修改属性</p>
<p>关于方法和属性是有两个ID与之对应, 这两个ID用来标识方法和属性.</p>
<pre><code>jmethodID mid;  jfieldID fid; 
</code></pre><p>方法分为静态和非静态的, 所以对应的有</p>
<pre><code>mid = (*env)-&gt;GetStaticMethodID(env, cls, &quot;sayHello&quot;, &quot;(Ljava/lang/String;)Ljava/lang/String;&quot;);     mid = (*env)-&gt;GetMethodID(env, cls, &quot;sayHello&quot;, &quot;()Ljava/lang/String;&quot;);   
</code></pre><p>上面两个方法是同名的, 都叫sayHello, 但是签名不同, 所以可以区分两个方法.</p>
<p>JNI的函数都是有一定规律的, Static就表示是静态, 没有表示非静态.</p>
<p>方法的调用如下</p>
<pre><code>jstring result = (jstring)(*env)-&gt;CallStaticObjectMethod(env, cls, mid, arg);     jstring result = (jstring)(*env)-&gt;CallObjectMethod(env, obj, mid);   
</code></pre><p>我们可以看到静态方法是只需要class对象, 不需要实例的, 而非静态方法需要使用我们之前实例化的对象.</p>
<p>属性也有静态和非静态, 示例中只有非静态的.</p>
<p>获取属性ID</p>
<pre><code>fid = (*env)-&gt;GetFieldID(env, cls, &quot;name&quot;, &quot;Ljava/lang/String;&quot;);   
</code></pre><p>改属性的值</p>
<pre><code>(*env)-&gt;SetObjectField(env, obj, fid, arg); // 修改属性  
</code></pre><p>关于jstring的说明</p>
<p>java的String都是使用了unicode, 是双字节的字符, 而C/C++中使用的单字节的字符。</p>
<p>从C转换为java的字符, 使用NewStringUTF方法</p>
<pre><code>jstring arg = (*env)-&gt;NewStringUTF(env, name);  
</code></pre><p>从java转换为C的字符, 使用GetStringUTFChars</p>
<pre><code>const char* str = (*env)-&gt;GetStringUTFChars(env, result, 0); 
</code></pre><p>下面我们来看代码：</p>
<p>c代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * Class:     com_losileeya_jnimaster_JNIUtils</div><div class="line"> * Method:    ccallJava_helloFromJava</div><div class="line"> * Signature: ()V</div><div class="line"> */</div><div class="line"><span class="function">JNIEXPORT <span class="keyword">void</span> JNICALL <span class="title">Java_com_losileeya_jnimaster_JNIUtils_ccallJava_1helloFromJava</span></span></div><div class="line">  <span class="params">(JNIEnv *env, jobject jobj)</span>&#123;</div><div class="line">    jclass jclazz=(*env)-&gt;FindClass(env,<span class="string">"com/losileeya/jnimaster/JNIUtils"</span>);</div><div class="line">    jmethodID jmethodid=(*env)-&gt;GetMethodID(env,jclazz,<span class="string">"helloFromJava"</span>,<span class="string">"()V"</span>);</div><div class="line">    jobject jobjs=(*env)-&gt;AllocObject(env,jclazz);</div><div class="line">    (*env)-&gt;CallVoidMethod(env,jobjs,jmethodid);</div><div class="line">  &#125;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"> * Class:     com_losileeya_jnimaster_JNIUtils</div><div class="line"> * Method:    ccallJava_add</div><div class="line"> * Signature: ()V</div><div class="line"> */</div><div class="line"><span class="function">JNIEXPORT <span class="keyword">void</span> JNICALL <span class="title">Java_com_losileeya_jnimaster_JNIUtils_ccallJava_1add</span></span></div><div class="line">  <span class="params">(JNIEnv *env, jobject jobj)</span>&#123;</div><div class="line"><span class="comment">//1.得到类对应的字节码</span></div><div class="line">    <span class="comment">//全类名，把.改成/</span></div><div class="line">    <span class="comment">//jclass      (*FindClass)(JNIEnv*, const char*);</span></div><div class="line">    jclass jclazz = (*env)-&gt;FindClass(env, <span class="string">"com/losileeya/jnimaster/JNIUtils"</span>);</div><div class="line"></div><div class="line">    <span class="comment">//2.得到要调用的方法名</span></div><div class="line">    <span class="comment">//第三个参数：方法名</span></div><div class="line">    <span class="comment">//第四个但是：方法签名</span></div><div class="line">    <span class="comment">//jmethodID   (*GetMethodID)(JNIEnv*, jclass, const char*, const char*);</span></div><div class="line">    jmethodID jmethodid = (*env)-&gt;GetMethodID(env, jclazz, <span class="string">"add"</span>,</div><div class="line">            <span class="string">"(II)I"</span>);</div><div class="line"></div><div class="line">    <span class="comment">//3.得到要调用的方法对应的类的实例</span></div><div class="line">    <span class="comment">// jobject     (*AllocObject)(JNIEnv*, jclass);</span></div><div class="line">    jobject jobjs = (*env)-&gt;AllocObject(env, jclazz);</div><div class="line">    <span class="comment">//4.调用方法</span></div><div class="line">    <span class="comment">// jint        (*CallIntMethod)(JNIEnv*, jobject, jmethodID, ...);</span></div><div class="line">      <span class="keyword">int</span> reuslt =  (*env)-&gt;CallIntMethod(env,jobjs,jmethodid,<span class="number">99</span>,<span class="number">1</span>);</div><div class="line"></div><div class="line"></div><div class="line">  &#125;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"> * Class:     com_losileeya_jnimaster_JNIUtils</div><div class="line"> * Method:    ccallJava_printString</div><div class="line"> * Signature: ()V</div><div class="line"> */</div><div class="line"><span class="function">JNIEXPORT <span class="keyword">void</span> JNICALL <span class="title">Java_com_losileeya_jnimaster_JNIUtils_ccallJava_1printString</span></span></div><div class="line">  <span class="params">(JNIEnv *env, jobject jobj)</span>&#123;</div><div class="line"> <span class="comment">//1.得到类对应的字节码</span></div><div class="line">        <span class="comment">//全类名，把.改成/</span></div><div class="line">        <span class="comment">//jclass      (*FindClass)(JNIEnv*, const char*);</span></div><div class="line">        jclass jclazz = (*env)-&gt;FindClass(env, <span class="string">"com/losileeya/jnimaster/JNIUtils"</span>);</div><div class="line"></div><div class="line">        <span class="comment">//2.得到要调用的方法名</span></div><div class="line">        <span class="comment">//第三个参数：方法名</span></div><div class="line">        <span class="comment">//第四个但是：方法签名</span></div><div class="line">        <span class="comment">//jmethodID   (*GetMethodID)(JNIEnv*, jclass, const char*, const char*);</span></div><div class="line">        jmethodID jmethodid = (*env)-&gt;GetMethodID(env, jclazz, <span class="string">"printString"</span>,</div><div class="line">                <span class="string">"(Ljava/lang/String;)V"</span>);</div><div class="line"></div><div class="line">        <span class="comment">//3.得到要调用的方法对应的类的实例</span></div><div class="line">        <span class="comment">// jobject     (*AllocObject)(JNIEnv*, jclass);</span></div><div class="line">        jobject jobjs = (*env)-&gt;AllocObject(env, jclazz);</div><div class="line">        <span class="comment">//4.调用方法</span></div><div class="line">        <span class="comment">// void        (*CallVoidMethod)(JNIEnv*, jobject, jmethodID, ...);</span></div><div class="line">        jstring text = (*env)-&gt;NewStringUTF(env,<span class="string">"I am from C!!"</span>);</div><div class="line">        (*env)-&gt;CallVoidMethod(env, jobjs, jmethodid,text); <span class="comment">//成功调用了Java中JNI里面的printString(String s);</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"> * Class:     com_losileeya_jnimaster_JNIUtils</div><div class="line"> * Method:    ccallJava_sayHello</div><div class="line"> * Signature: ()V</div><div class="line"> */</div><div class="line"><span class="function">JNIEXPORT <span class="keyword">void</span> JNICALL <span class="title">Java_com_losileeya_jnimaster_JNIUtils_ccallJava_1sayHello</span></span></div><div class="line">  <span class="params">(JNIEnv * env, jobject jobj)</span>&#123;</div><div class="line">     <span class="comment">//1.得到字节码</span></div><div class="line">     jclass jclazz = (*env)-&gt;FindClass(env,<span class="string">"com/losileeya/jnimaster/JNIUtils"</span>);</div><div class="line">     <span class="comment">//2.得到方法</span></div><div class="line">     jmethodID  jmethodid = (*env)-&gt;GetStaticMethodID(env,jclazz,<span class="string">"sayHello"</span>,<span class="string">"(Ljava/lang/String;)V"</span>);</div><div class="line"></div><div class="line">     <span class="comment">//3.调用</span></div><div class="line">     <span class="comment">//void        (*CallStaticVoidMethod)(JNIEnv*, jclass, jmethodID, ...);</span></div><div class="line">        jstring text = (*env)-&gt;NewStringUTF(env,<span class="string">"I am from C!! I am static method !!!"</span>);</div><div class="line">     (*env)-&gt;CallStaticVoidMethod(env,jclazz,jmethodid,text);<span class="comment">//成功调用了Java中JNI类的静态方法sayHello(String text)</span></div><div class="line"></div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>c++代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * Class:     com_losileeya_jnimaster_JNIUtils</div><div class="line"> * Method:    ccallJava_helloFromJava</div><div class="line"> * Signature: ()V</div><div class="line"> */</div><div class="line"><span class="function">JNIEXPORT <span class="keyword">void</span> JNICALL <span class="title">Java_com_losileeya_jnimaster_JNIUtils_ccallJava_1helloFromJava</span><span class="params">(JNIEnv*env,jobject jobj)</span></span>&#123;</div><div class="line">jclass jclazz = env-&gt;FindClass(<span class="string">"com/losileeya/jnimaster/JNIUtils"</span>);</div><div class="line">jmethodID jmethodid = env-&gt;GetMethodID(jclazz, <span class="string">"helloFromJava"</span>, <span class="string">"()V"</span>);</div><div class="line">jobject jobjs = env-&gt;AllocObject(jclazz);</div><div class="line">env-&gt;CallVoidMethod(jobjs, jmethodid);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"> * Class:     com_losileeya_jnimaster_JNIUtils</div><div class="line"> * Method:    ccallJava_add</div><div class="line"> * Signature: ()V</div><div class="line"> */</div><div class="line"><span class="function">JNIEXPORT <span class="keyword">void</span> JNICALL <span class="title">Java_com_losileeya_jnimaster_JNIUtils_ccallJava_1add</span><span class="params">(JNIEnv*env,jobject jobj)</span></span>&#123;</div><div class="line"><span class="comment">//1.得到类对应的字节码</span></div><div class="line"><span class="comment">//全类名，把.改成/</span></div><div class="line"><span class="comment">//jclass      (*FindClass)(JNIEnv*, const char*);</span></div><div class="line">jclass jclazz = env-&gt;FindClass( <span class="string">"com/losileeya/jnimaster/JNIUtils"</span>);</div><div class="line"></div><div class="line"><span class="comment">//2.得到要调用的方法名</span></div><div class="line"><span class="comment">//第三个参数：方法名</span></div><div class="line"><span class="comment">//第四个但是：方法签名</span></div><div class="line"><span class="comment">//jmethodID   (*GetMethodID)(JNIEnv*, jclass, const char*, const char*);</span></div><div class="line">jmethodID jmethodid = env-&gt;GetMethodID(jclazz, <span class="string">"add"</span>,</div><div class="line">                                          <span class="string">"(II)I"</span>);</div><div class="line"></div><div class="line"><span class="comment">//3.得到要调用的方法对应的类的实例</span></div><div class="line"><span class="comment">// jobject     (*AllocObject)(JNIEnv*, jclass);</span></div><div class="line">jobject jobjs = env-&gt;AllocObject(jclazz);</div><div class="line"><span class="comment">//4.调用方法</span></div><div class="line"><span class="comment">// jint        (*CallIntMethod)(JNIEnv*, jobject, jmethodID, ...);</span></div><div class="line"><span class="keyword">int</span> reusle =  env-&gt;CallIntMethod(jobjs,jmethodid,<span class="number">99</span>,<span class="number">1</span>);</div><div class="line"></div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"> * Class:     com_losileeya_jnimaster_JNIUtils</div><div class="line"> * Method:    ccallJava_printString</div><div class="line"> * Signature: ()V</div><div class="line"> */</div><div class="line"><span class="function">JNIEXPORT <span class="keyword">void</span> JNICALL <span class="title">Java_com_losileeya_jnimaster_JNIUtils_ccallJava_1printString</span><span class="params">(JNIEnv*env,jobject jobj)</span></span>&#123;</div><div class="line"><span class="comment">//1.得到类对应的字节码</span></div><div class="line"><span class="comment">//全类名，把.改成/</span></div><div class="line"><span class="comment">//jclass      (*FindClass)(JNIEnv*, const char*);</span></div><div class="line">jclass jclazz = env-&gt;FindClass( <span class="string">"com/losileeya/jnimaster/JNIUtils"</span>);</div><div class="line"></div><div class="line"><span class="comment">//2.得到要调用的方法名</span></div><div class="line"><span class="comment">//第三个参数：方法名</span></div><div class="line"><span class="comment">//第四个但是：方法签名</span></div><div class="line"><span class="comment">//jmethodID   (*GetMethodID)(JNIEnv*, jclass, const char*, const char*);</span></div><div class="line">jmethodID jmethodid = env-&gt;GetMethodID( jclazz, <span class="string">"printString"</span>,</div><div class="line">                                          <span class="string">"(Ljava/lang/String;)V"</span>);</div><div class="line"></div><div class="line"><span class="comment">//3.得到要调用的方法对应的类的实例</span></div><div class="line"><span class="comment">// jobject     (*AllocObject)(JNIEnv*, jclass);</span></div><div class="line">jobject jobjs = env-&gt;AllocObject(jclazz);</div><div class="line"><span class="comment">//4.调用方法</span></div><div class="line"><span class="comment">// void        (*CallVoidMethod)(JNIEnv*, jobject, jmethodID, ...);</span></div><div class="line">jstring text = env-&gt;NewStringUTF(<span class="string">"I am from C!!"</span>);</div><div class="line">env-&gt;CallVoidMethod( jobjs, jmethodid,text); <span class="comment">//成功调用了Java中JNI里面的printString(String s);</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"> * Class:     com_losileeya_jnimaster_JNIUtils</div><div class="line"> * Method:    ccallJava_sayHello</div><div class="line"> * Signature: ()V</div><div class="line"> */</div><div class="line"><span class="function">JNIEXPORT <span class="keyword">void</span> JNICALL <span class="title">Java_com_losileeya_jnimaster_JNIUtils_ccallJava_1sayHello</span><span class="params">(JNIEnv*env,jobject jobj)</span></span>&#123;</div><div class="line"><span class="comment">//1.得到字节码</span></div><div class="line">jclass jclazz = env-&gt;FindClass(<span class="string">"com/losileeya/jnimaster/JNIUtils"</span>);</div><div class="line"><span class="comment">//2.得到方法</span></div><div class="line">jmethodID  jmethodid = env-&gt;GetStaticMethodID(jclazz,<span class="string">"sayHello"</span>,<span class="string">"(Ljava/lang/String;)V"</span>);</div><div class="line"></div><div class="line"><span class="comment">//3.调用</span></div><div class="line"><span class="comment">//void        (*CallStaticVoidMethod)(JNIEnv*, jclass, jmethodID, ...);</span></div><div class="line">jstring text = env-&gt;NewStringUTF(<span class="string">"I am from C!! I am static method !!!"</span>);</div><div class="line">env-&gt;CallStaticVoidMethod(jclazz,jmethodid,text);<span class="comment">//成功调用了Java中JNI类的静态方法sayHello(String text)</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，上述代码和前面讲到的步骤完全相符。这里提一下编程时要注意的要点：1、FindClass要写明Java类的完整包路径，并将 “.”以“/”替换；2、GetMethodID的第三个参数是方法名（对于构造函数一律用“<init>”表示），第四个参数是方法的“签 名”，需要用一个字符串序列表示方法的参数（依声明顺序）和返回值信息。由于篇幅所限，这里不再具体说明如何根据方法的声明构造相应的“签名”，请参考 JNI的相关文档。</init></p>
<p>关于上面谈到的步骤再补充说明一下：在JNI规范中，如上这种使用NewObject创建的对象实例被称为“Local Reference”，它仅在创建它的Native代码作用域内有效，因此应避免在作用域外使用该实例及任何指向它的指针。如果希望创建的对象实例在作用 域外也能使用，则需要使用NewGlobalRef接口将其提升为“Global Reference”——需要注意的是，当Global Reference不再使用后，需要显式的释放，以便通知JVM进行垃圾收集。</p>
<p>顺便看下截图：<br><img src="http://i.imgur.com/vaS8Rb2.png" alt=""></p>
<h3 id="JNI-更新UI"><a href="#JNI-更新UI" class="headerlink" title="JNI 更新UI"></a>JNI 更新UI</h3><p>在Android使用Jni时，为了能够使UI线程即主线程与工作线程分开，经常要创建工作线程，然后在工作线程中调用C/C++函数.为了在C/C++ 函数中更新Android的UI，又时常使用回调。jni更新ui的话，我们就要注重jobject的使用了。</p>
<p>看代码：(使用)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> &#123;</div><div class="line">       System.loadLibrary(<span class="string">"CCallJavaForUI"</span>);</div><div class="line">   &#125;</div><div class="line">   <span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">       <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">       setContentView(R.layout.activity_main);</div><div class="line">   &#125;</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">CCallJavaForUI</span><span class="params">(View view)</span></span>&#123;</div><div class="line">       <span class="keyword">this</span>.callShowToast();</div><div class="line"></div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showToast</span><span class="params">()</span></span>&#123;</div><div class="line">       <span class="comment">//this - Activity的实例</span></div><div class="line">       <span class="comment">//startActitity();--&gt;</span></div><div class="line">       <span class="comment">//new MainActivity();</span></div><div class="line">       System.out.println(<span class="string">"showToast()----------"</span>);</div><div class="line">       Toast.makeText(<span class="keyword">this</span>, <span class="string">"showToast()---------"</span>, Toast.LENGTH_LONG).show();</div><div class="line">   &#125;</div><div class="line"></div><div class="line"></div><div class="line">   <span class="comment">/**</span></div><div class="line">    * 调用MainActivity中的showToast()方法</div><div class="line">    */</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">callShowToast</span><span class="params">()</span></span>;</div></pre></td></tr></table></figure>
<p>c代码 ：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">//</div><div class="line">// Created by Administrator on 2016/8/6.</div><div class="line">//</div><div class="line">#include "JNIUtils.h"</div><div class="line">#include&lt;stdio.h&gt;</div><div class="line">#include&lt;stdlib.h&gt;</div><div class="line">/**</div><div class="line"> * 调用java 中MainActivity中的showToast()方法</div><div class="line"> * jobject jobj:谁调用就是谁的实例，当前是JNI.this---&gt;MainActivity.this</div><div class="line"> */</div><div class="line">JNIEXPORT void JNICALL Java_com_losileeya_jniupdateui_MainActivity_callShowToast</div><div class="line">(JNIEnv * env, jobject jobj)&#123;</div><div class="line"></div><div class="line">//1.得到字节码</div><div class="line">jclass   jclazz = (*env)-&gt;FindClass(env,"com/losileeya/jniupdateui/MainActivity");</div><div class="line">//2.得到方法</div><div class="line">//jmethodID   (*GetMethodID)(JNIEnv*, jclass, const char*, const char*);</div><div class="line">jmethodID jmethodid = (*env)-&gt;GetMethodID(env,jclazz,"showToast","()V");</div><div class="line">//3.得到对象</div><div class="line">//      jobject jobjs = (*env)-&gt;AllocObject(env,jclazz);</div><div class="line">//4.调用方法</div><div class="line">//void        (*CallVoidMethod)(JNIEnv*, jobject, jmethodID, ...);</div><div class="line">(*env)-&gt;CallVoidMethod(env,jobj,jmethodid);//成功调用了中MainActivity中的showToast()方法</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>c++代码：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">//</div><div class="line">// Created by Administrator on 2016/8/6.</div><div class="line">//</div><div class="line">#include "JNIUtils.h"</div><div class="line">#include&lt;stdio.h&gt;</div><div class="line">#include&lt;stdlib.h&gt;</div><div class="line">/**</div><div class="line"> * 调用java 中MainActivity中的showToast()方法</div><div class="line"> * jobject jobj:谁调用就是谁的实例，当前是JNI.this---&gt;MainActivity.this</div><div class="line"> */</div><div class="line">JNIEXPORT void JNICALL Java_com_losileeya_jniupdateui_MainActivity_callShowToast</div><div class="line">(JNIEnv * env, jobject jobj)&#123;</div><div class="line"></div><div class="line">//1.得到字节码</div><div class="line">jclass   jclazz = (*env)-&gt;FindClass(env,"com/losileeya/jniupdateui/MainActivity");</div><div class="line">//2.得到方法</div><div class="line">//jmethodID   (*GetMethodID)(JNIEnv*, jclass, const char*, const char*);</div><div class="line">jmethodID jmethodid = (*env)-&gt;GetMethodID(env,jclazz,"showToast","()V");</div><div class="line">//3.得到对象</div><div class="line">//      jobject jobjs = (*env)-&gt;AllocObject(env,jclazz);</div><div class="line">//4.调用方法</div><div class="line">//void        (*CallVoidMethod)(JNIEnv*, jobject, jmethodID, ...);</div><div class="line">(*env)-&gt;CallVoidMethod(env,jobj,jmethodid);//成功调用了中MainActivity中的showToast()方法</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>效果图：<br><img src="http://img.blog.csdn.net/20160806120606952" alt="这里写图片描述"></p>
<h3 id="C和C-函数时的JNI使用区别"><a href="#C和C-函数时的JNI使用区别" class="headerlink" title="C和C++函数时的JNI使用区别"></a>C和C++函数时的JNI使用区别</h3><p>Java调用C和C++函数时的JNI使用区别:</p>
<p>注意：jni.h头文件中对于<em>.c  &amp;  </em>.cpp采用不同的定义</p>
<p>在C的定义中,env是一个两级指针,而在C++的定义中,env是个一级指针</p>
<p>C形式需要对env指针进行双重deferencing，而且须将env作为第一个参数传给jni函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">jclass (JNICALL *GetObjectClass)   (JNIEnv *env, jobject obj);</div><div class="line"></div><div class="line"><span class="function">jclass <span class="title">GetObjectClass</span><span class="params">(jobject obj)</span> </span></div><div class="line"></div><div class="line">&#123;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> functions-&gt;GetObjectClass(<span class="keyword">this</span>,obj);</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对于*.c</p>
<p>1.jclass test_class = (*env)-&gt;GetObjectClass(env, obj);</p>
<p>2.jfieldID id_num = (*env)-&gt;GetFieldID(env, test_class, “num”, “I”);</p>
<p>对于 *.cpp</p>
<p>1.jclass test_class = env-&gt;GetObjectClass(obj); </p>
<p>2.jfieldID id_num = env-&gt;GetFieldID(test_class, “num”, “I”);</p>
<p>在 C 中，</p>
<p>JNI 函数调用由“(*env)-&gt;”作前缀，目的是为了取出函数指针所引用的值。</p>
<p>在 C++ 中，</p>
<p>JNIEnv 类拥有处理函数指针查找的内联成员函数。</p>
<p>下面将说明这个细微的差异，其中，这两行代码访问同一函数，但每种语言都有各自的语法。</p>
<p>C 语法：jsize len = (*env)-&gt;GetArrayLength(env,array);</p>
<p>C++ 语法：jsize len =env-&gt;GetArrayLength(array);</p>
<pre><code>1、jni 可以调用本地C函数。
2、jni 调用C++库时，首先要将C++库提供的功能封装成纯C格式的函数接口，然后jni里面调用这些C接口。

总结，没什么区别。一个是 jni调用c。另一个是jni调用c，c调用c++。
</code></pre><p> 传送门：<a href="http://download.csdn.net/detail/u013278099/9596655" target="_blank" rel="external">jnimaster</a></p>
<p>##总结</p>
<p>JNI使用c和cpp的基本使用和了解就讲的差不多了，更多的学习可以去看jni的使用安全手册。</p>
<hr>
<p>未经许可不得转载，转载请注明zilianliuxue的blog,本人保留所有版权。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;JNI重新认识&quot;&gt;&lt;a href=&quot;#JNI重新认识&quot; class=&quot;headerlink&quot; title=&quot;JNI重新认识&quot;&gt;&lt;/a&gt;JNI重新认识&lt;/h2&gt;&lt;h3 id=&quot;头文件：&quot;&gt;&lt;a href=&quot;#头文件：&quot; class=&quot;headerlink&quot; titl
    
    </summary>
    
      <category term="android" scheme="http://zilianliuxue.github.io/categories/android/"/>
    
    
      <category term="jni ndk" scheme="http://zilianliuxue.github.io/tags/jni-ndk/"/>
    
  </entry>
  
  <entry>
    <title>Android 面试题（一）</title>
    <link href="http://zilianliuxue.github.io/2016/07/31/Android%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://zilianliuxue.github.io/2016/07/31/Android面试题（一）/</id>
    <published>2016-07-31T14:10:00.000Z</published>
    <updated>2016-09-05T04:54:07.179Z</updated>
    
    <content type="html"><![CDATA[<h2 id="面试所遇到的问题："><a href="#面试所遇到的问题：" class="headerlink" title="面试所遇到的问题："></a>面试所遇到的问题：</h2><h3 id="1-显示Intent与隐式Intent的区别"><a href="#1-显示Intent与隐式Intent的区别" class="headerlink" title="1.显示Intent与隐式Intent的区别"></a>1.显示Intent与隐式Intent的区别</h3><blockquote>
<p>对明确指出了目标组件名称的Intent，我们称之为“<strong>显式Intent</strong>”。</p>
<p>对于没有明确指出目标组件名称的Intent，则称之为“<strong>隐式 Intent</strong>”。</p>
<p>对于隐式意图，在定义Activity时，指定一个intent-filter，当一个隐式意图对象被一个意图过滤器进行匹配时，将有三个方面会被参考到：</p>
<p>动作(Action)</p>
<p>类别(Category <em>[‘kætɪg(ə)rɪ]</em> )</p>
<p>数据(Data )</p>
</blockquote>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&lt;activity android:name=".MainActivity"  android:label="@string/app_name"&gt;</div><div class="line"></div><div class="line">            &lt;intent-filter&gt;</div><div class="line"></div><div class="line">                &lt;action android:name="com.wpc.test" /&gt;</div><div class="line"></div><div class="line">                &lt;category android:name="android.intent.category.DEFAULT" /&gt;</div><div class="line"></div><div class="line">                &lt;data android:mimeType="image/gif"/&gt;</div><div class="line"></div><div class="line">            &lt;/intent-filter&gt;</div><div class="line"></div><div class="line">&lt;/activity&gt;</div></pre></td></tr></table></figure>
<h3 id="2-什么是线程池，线程池的作用是什么"><a href="#2-什么是线程池，线程池的作用是什么" class="headerlink" title="2.什么是线程池，线程池的作用是什么"></a>2.什么是线程池，线程池的作用是什么</h3><p><strong>1.线程池 </strong></p>
<blockquote>
<p>答：线程池的基本思想还是一种对象池的思想，开辟一块内存空间，里面存放了众多(未死亡)的线程，池中线程执行调度由池管理器来处理。当有线程任务时，从池中取一个，执行完成后线程对象归池，这样可以避免反复创建线程对象所带来的性能开销，节省了系统的资源。就好比原来去食堂打饭是每个人看谁抢的赢，谁先抢到谁先吃，有了线程池之后，就是排好队形，今天我跟你关系好，你先来吃饭。比如：一个应用要和网络打交道，有很多步骤需要访问网络，为了不阻塞主线程，每个步骤都创建个线程，在线程中和网络交互，用线程池就变的简单，线程池是对线程的一种封装，让线程用起来更加简便，只需要创一个线程池，把这些步骤像任务一样放进线程池，在程序销毁时只要调用线程池的销毁函数即可。</p>
<p>单个线程的弊端：a. 每次new Thread新建对象性能差b. 线程缺乏统一管理，可能无限制新建线程，相互之间竞争，及可能占用过多系统资源导致死机或者OOM,c. 缺乏更多功能，如定时执行、定期执行、线程中断。</p>
</blockquote>
<p><strong>2、Java 线程池</strong></p>
<p>Java通过Executors提供四种线程池，分别为：</p>
<p>newCachedThreadPool创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。</p>
<p>newFixedThreadPool 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。</p>
<p>newScheduledThreadPool 创建一个定长线程池，支持定时及周期性任务执行。</p>
<p>newSingleThreadExecutor 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。</p>
<blockquote>
<p><strong>(1). newCachedThreadPool</strong></p>
<p><strong>创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。线程池为无限大，当执行第二个任务时第一个任务已经完成，会复用执行第一个任务的线程，而不用每次新建线程。</strong></p>
<p><strong>(2). newFixedThreadPool</strong></p>
<p><strong>创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。</strong></p>
<p><strong>(3) newScheduledThreadPool</strong></p>
<p><strong>创建一个定长线程池，支持定时及周期性任务执行。ScheduledExecutorService比Timer更安全，功能更强大</strong></p>
<p><strong>(4)、newSingleThreadExecutor</strong></p>
<p><strong>创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行</strong></p>
</blockquote>
<h3 id="3-多任务多线程下载用到那些Android的技术"><a href="#3-多任务多线程下载用到那些Android的技术" class="headerlink" title="3.多任务多线程下载用到那些Android的技术"></a>3.多任务多线程下载用到那些Android的技术</h3><blockquote>
<p>答：</p>
<p>这道面试题，主要是考察对多线程的理解和使用，还涉及到网络请求和文件操作，使用的技术多种多样，一般可以回答： 使用Handler（可以看No.8Handler的原理），AsyncTask的处理原理，没写过去百度一下，网上一堆教你怎么做的，不必死扣代码，只需要明白逻辑流程，能够完整流畅的说清楚为什么，这个题目也就回答到点子上了。</p>
</blockquote>
<h3 id="4-IntentService的用法"><a href="#4-IntentService的用法" class="headerlink" title="4.IntentService的用法"></a>4.IntentService的用法</h3><blockquote>
<p>一、IntentService简介 </p>
<p>IntentService是Service的子类，比普通的Service增加了额外的功能。先看Service本身存在两个问题：  </p>
<ul>
<li>Service不会专门启动一条单独的进程，Service与它所在应用位于同一个进程中；  </li>
<li>Service也不是专门一条新线程，因此不应该在Service中直接处理耗时的任务；  </li>
</ul>
<p>二、IntentService特征 </p>
<ul>
<li>会创建独立的worker线程来处理所有的Intent请求；  </li>
<li>会创建独立的worker线程来处理onHandleIntent()方法实现的代码，无需处理多线程问题；  </li>
<li>所有请求处理完成后，IntentService会自动停止，无需调用stopSelf()方法停止Service；  </li>
<li>为Service的onBind()提供默认实现，返回null；  </li>
<li>为Service的onStartCommand提供默认实现，将请求Intent添加到队列中； </li>
</ul>
<ul>
<li>IntentService不会阻塞UI线程，而普通Serveice会导致ANR异常</li>
</ul>
<ul>
<li>Intentservice若未执行完成上一次的任务，将不会新开一个线程，是等待之前的任务完成后，再执行新的任务，等任务完成后再次调用stopSelf</li>
</ul>
</blockquote>
<h3 id="5-监听系统联系人列表状态变化"><a href="#5-监听系统联系人列表状态变化" class="headerlink" title="5.监听系统联系人列表状态变化"></a>5.监听系统联系人列表状态变化</h3><blockquote>
<p>答：通过ContentObserver的方式进行数据变化监听，要说清楚ContentObserver怎么用的，面试官有可能会问你观察者模式。最好是写一编观察者模式。理解后就好说明用法或者原理</p>
</blockquote>
<h3 id="6-serveice中如何通知Activity改变视图"><a href="#6-serveice中如何通知Activity改变视图" class="headerlink" title="6.serveice中如何通知Activity改变视图"></a>6.serveice中如何通知Activity改变视图</h3><blockquote>
<p>答：</p>
<p>通过<strong>Binder</strong>对象</p>
<p>  当Activity通过调用bindService(Intent service, ServiceConnection conn,int flags),我们可以得到一个Service的一个对象实例，然后我们就可以访问Service中的方法，从而根据数据不同来更新</p>
<p>通过<strong>BroadCast</strong>(广播)的形式</p>
<p>   当我们的进度发生变化的时候我们发送一条广播，然后在Activity的注册广播接收器，接收到广播之后更新视图</p>
<p>参考博客：<a href="http://blog.csdn.net/xiaanming/article/details/9750689" target="_blank" rel="external">http://blog.csdn.net/xiaanming/article/details/9750689</a> </p>
</blockquote>
<h3 id="7-Acitivity后台闲置退出或异常退出，如何保存数据"><a href="#7-Acitivity后台闲置退出或异常退出，如何保存数据" class="headerlink" title="7.Acitivity后台闲置退出或异常退出，如何保存数据"></a>7.Acitivity后台闲置退出或异常退出，如何保存数据</h3><blockquote>
<p>答：</p>
<p>通过 onSaveInstanceState() 和 onRestoreInstanceState() 保存和重启非持久化数据。</p>
</blockquote>
<h3 id="8-Handler的实现原理"><a href="#8-Handler的实现原理" class="headerlink" title="8.Handler的实现原理"></a>8.Handler的实现原理</h3><blockquote>
<p>答：</p>
<p><strong>handler</strong>干了些什么：</p>
<p><strong>运行在某个线程上，共享线程的消息队列；</strong></p>
<p><strong>接收消息、调度消息，派发消息和处理消息；</strong></p>
<p><strong>实现消息的异步处理；</strong></p>
<p><strong>建立消息处理模型/系统</strong></p>
<p><strong>参考博客</strong></p>
</blockquote>
<h3 id="9-Android-Holo主题与MD主题的理念，以及你的看法"><a href="#9-Android-Holo主题与MD主题的理念，以及你的看法" class="headerlink" title="9.Android Holo主题与MD主题的理念，以及你的看法"></a>9.Android Holo主题与MD主题的理念，以及你的看法</h3><blockquote>
<p>答：</p>
<p>Holo Theme</p>
<p>Holo Theme 是 Android Design 的最基础的呈现方式。因为是最为基础的 Android Design 呈现形式，每一台 Android 4.X 的手机系统内部都有集成 Holo Theme 需要的控件，即开发者不需要自己设计控件，而是直接从系统里调用相应的控件。在 UI 方面没有任何的亮点，和 Android4.X 的设置/电话的视觉效果极度统一。由此带来的好处显而易见，这个应用作为 Android 应用的辨识度极高，且完全不可能与系统风格产生冲突。</p>
<p>Material Design</p>
<p>Material design其实是单纯一种设计语言，它包含了系统界面风格、交互、UI,更加专注拟真,更加大胆丰富的用色,更加丰富的交互形式,更加灵活的布局形式</p>
<p>1.鲜明、形象的界面风格，</p>
<p>2.色彩搭配使得应用看起来非常的大胆、充满色彩感，凸显内容</p>
<p>3.Material design对于界面的排版非常的重视</p>
<p>4.Material design的交互设计上采用的是响应式交互，这样的交互设计能把一个应用从简单展现用户所请求的信息，提升至能与用户产生更强烈、更具体化交互的工具。</p>
</blockquote>
<h3 id="10-String，StringBuffer，StringBuilder有哪些不同"><a href="#10-String，StringBuffer，StringBuilder有哪些不同" class="headerlink" title="10.String，StringBuffer，StringBuilder有哪些不同"></a>10.String，StringBuffer，StringBuilder有哪些不同</h3><blockquote>
<p>答：</p>
<p>三者在执行速度方面的比较：<strong>StringBuilder &gt;  StringBuffer  &gt;  String</strong></p>
<p><strong>String</strong>每次变化一个值就会开辟一个新的内存空间</p>
<p><strong>StringBuilder：</strong>线程非安全的</p>
<p><strong>StringBuffer：</strong>线程安全的</p>
<p><strong>对于三者使用的总结： </strong></p>
<p><strong>1.如果要操作少量的数据用 = String</strong></p>
<p><strong>2.单线程操作字符串缓冲区 下操作大量数据 = StringBuilder</strong></p>
<p><strong>3.多线程操作字符串缓冲区 下操作大量数据 = StringBuffer</strong></p>
</blockquote>
<h3 id="11-浮点数的精准计算"><a href="#11-浮点数的精准计算" class="headerlink" title="11.浮点数的精准计算"></a>11.浮点数的精准计算</h3><blockquote>
<p>答：BigDecimal类进行商业计算，Float和Double只能用来做科学计算或者是工程计算</p>
</blockquote>
<h3 id="12-如何通过JNI传递String对象"><a href="#12-如何通过JNI传递String对象" class="headerlink" title="12.如何通过JNI传递String对象"></a>12.如何通过JNI传递String对象</h3><blockquote>
<p>答：</p>
<p>Java的String和C++的string是不能对等起来的，所以当我们拿到.h文件下面的jstring对象，会做一次转换我们把jstring转换为C下面的char*类型，</p>
<p>constchar* str;</p>
<p>str = env-&gt;GetStringUTFChars(prompt,false); 获取值</p>
<p>char* tmpstr =”return string succeeded”;</p>
<p>jstring rtstr = env-&gt;NewStringUTF(tmpstr);赋予值</p>
</blockquote>
<h3 id="13-Context与ApplicationContext的区别，分别用在什么情况下"><a href="#13-Context与ApplicationContext的区别，分别用在什么情况下" class="headerlink" title="13.Context与ApplicationContext的区别，分别用在什么情况下"></a>13.Context与ApplicationContext的区别，分别用在什么情况下</h3><blockquote>
<p>答：</p>
<p>Application的Context是一个全局静态变量，SDK的说明是只有当你引用这个context的生命周期超过了当前activity的生命周期，而和整个应用的生命周期挂钩时，才去使用这个application的context。</p>
<p>在android中context可以作很多操作，但是最主要的功能是加载和访问资源。在android中有两种context，一种是 application context，一种是activity context，通常我们在各种类和方法间传递的是activity context。</p>
</blockquote>
<h3 id="14-View的绘制流程"><a href="#14-View的绘制流程" class="headerlink" title="14.View的绘制流程"></a>14.View的绘制流程</h3><blockquote>
<p>答：</p>
<p>1.onmesarue() 为整个View树计算实际的大小</p>
<p>2.onlayout() 为将整个根据子视图的大小以及布局参数将View树放到合适的位置上</p>
<p>3.ondraw() </p>
<p>1 、绘制该View的背景</p>
<p>2 、为显示渐变框做一些准备操作(见5，大多数情况下，不需要改渐变框)</p>
<p>3、调用onDraw()方法绘制视图本身   (每个View都需要重载该方法，ViewGroup不需要实现该方法)</p>
<p>4、调用dispatchDraw ()方法绘制子视图(如果该View类型不为ViewGroup，即不包含子视图，不需要重载该方法)</p>
</blockquote>
<h3 id="15-触摸屏幕的分发机制"><a href="#15-触摸屏幕的分发机制" class="headerlink" title="15.触摸屏幕的分发机制"></a>15.触摸屏幕的分发机制</h3><blockquote>
<p>答：</p>
<p><strong>1、基础知识</strong></p>
<p>(1) 所有Touch事件都被封装成了MotionEvent对象，包括Touch的位置、时间、历史记录以及第几个手指(多指触摸)等。</p>
<p>(2) 事件类型分为ACTION_DOWN, ACTION_UP, ACTION_MOVE, ACTION_POINTER_DOWN, ACTION_POINTER_UP, ACTION_CANCEL，每个事件都是以ACTION_DOWN开始ACTION_UP结束。</p>
<p>(3) 对事件的处理包括三类，分别为</p>
<p>传递——dispatchTouchEvent()函数、</p>
<p>拦截——onInterceptTouchEvent()函数、</p>
<p>消费——onTouchEvent()函数和OnTouchListener</p>
<p><strong>2、传递流程</strong></p>
<p>(1) 事件从Activity.dispatchTouchEvent()开始传递，只要没有被停止或拦截，从最上层的View(ViewGroup)开始一直往下(子View)传递。子View可以通过onTouchEvent()对事件进行处理。</p>
<p>(2) 事件由父View(ViewGroup)传递给子View，ViewGroup可以通过onInterceptTouchEvent()对事件做拦截，停止其往下传递。</p>
<p>(3) 如果事件从上往下传递过程中一直没有被停止，且最底层子View没有消费事件，事件会反向往上传递，这时父View(ViewGroup)可以进行消费，如果还是没有被消费的话，最后会到Activity的onTouchEvent()函数。</p>
<p>(4) 如果View没有对ACTION_DOWN进行消费，之后的其他事件不会传递过来。</p>
<p>(5) OnTouchListener优先于onTouchEvent()对事件进行消费。</p>
<p>上面的消费即表示相应函数返回值为true。</p>
<p>(1) View不处理事件流程图</p>
<p><img src="https://farm6.staticflickr.com/5529/13927155020_73bdfab805_o.jpg" alt=""></p>
<p>(2) View处理事件流程图</p>
<p><img src="https://farm8.staticflickr.com/7062/14110505861_6569e33985_o.jpg" alt=""></p>
</blockquote>
<h3 id="16-Android系统提供了那些动画机制"><a href="#16-Android系统提供了那些动画机制" class="headerlink" title="16.Android系统提供了那些动画机制"></a>16.Android系统提供了那些动画机制</h3><blockquote>
<p>答：</p>
<p>1.逐帧动画</p>
<p>  逐帧动画的工作原理很简单，其实就是将一个完整的动画拆分成一张张单独的图片，然后再将它们连贯起来进行播放，类似于动画片的工作原理</p>
<p>2.补间动画</p>
<p>  补间动画则是可以对View进行一系列的动画操作，包括淡入淡出、缩放、平移、旋转四种</p>
<p>  缺陷：补间动画是只能够作用在View上，它只能够实现移动、缩放、旋转和淡入淡出这四种动画操作，补间动画还有一个致命的缺陷，就是它只是改变了View的显示效果而已，而不会真正去改变View的属性</p>
<p>  逐帧动画和补间动画它们的技术已经比较老了，而且网上资料也非常多</p>
<p>3.属性动画</p>
<p>  ValueAnimator</p>
<p>  ValueAnimator是整个属性动画机制当中最核心的一个类</p>
<p>  ObjectAnimator</p>
<p>  相比于ValueAnimator，ObjectAnimator可能才是我们最常接触到的类，因为ValueAnimator只不过是对值进行了一个平滑的动画过渡，但我们实际使用到这种功能的场景好像并不多。而ObjectAnimator则就不同了，它是可以直接对任意对象的任意属性进行动画操作的，比如说View的alpha属性</p>
</blockquote>
<h3 id="17-java为什么跨平台"><a href="#17-java为什么跨平台" class="headerlink" title="17.java为什么跨平台"></a>17.java为什么跨平台</h3><blockquote>
<p>答：<br>因为Java程序编译之后的代码不是能被硬件系统直接运行的代码，而是一种“中间码”——字节码。然后不同的硬件平台上安装有不同的Java虚拟机(JVM)，由JVM来把字节码再“翻译”成所对应的硬件平台能够执行的代码。因此对于Java编程者来说，不需要考虑硬件平台是什么。所以Java可以跨平台。</p>
</blockquote>
<h3 id="18-Https与http"><a href="#18-Https与http" class="headerlink" title="18.Https与http"></a>18.Https与http</h3><blockquote>
<p>HTPPS和HTTP的概念</p>
<p>HTTPS（全称：Hypertext Transfer Protocol over Secure Socket Layer），是以安全为目标的HTTP通道，简单讲是HTTP的安全版。即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。 它是一个URI scheme（抽象标识符体系），句法类同http:体系。用于安全的HTTP数据传输。https:URL表明它使用了HTTP，但HTTPS存在不同于HTTP的默认端口及一个加密/身份验证层（在HTTP与TCP之间）。这个系统的最初研发由网景公司进行，提供了身份验证与加密通讯方法，现在它被广泛用于万维网上安全敏感的通讯，例如交易支付方面。</p>
<p>超文本传输协议 (HTTP-Hypertext transfer protocol) 是一种详细规定了浏览器和万维网服务器之间互相通信的规则，通过因特网传送万维网文档的数据传送协议。</p>
<p>https协议需要到ca申请证书，一般免费证书很少，需要交费。http是超文本传输协议，信息是明文传输，https 则是具有安全性的ssl加密传输协议http和https使用的是完全不同的连接方式用的端口也不一样,前者是80,后者是443。http的连接很简单,是无状态的HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议 要比http协议安全HTTPS解决的问题：1 . 信任主机的问题. 采用https 的server 必须从CA 申请一个用于证明服务器用途类型的证书. 改证书只有用于对应的server 的时候,客户度才信任次主机2 . 防止通讯过程中的数据的泄密和被窜改</p>
</blockquote>
<h3 id="19-Post与Get请求的区别"><a href="#19-Post与Get请求的区别" class="headerlink" title="19.Post与Get请求的区别"></a>19.Post与Get请求的区别</h3><blockquote>
<p><em>GET</em>- 从指定的资源请求数据。</p>
<p><em>POST</em>- 向指定的资源提交要被处理的数据</p>
</blockquote>
<h3 id="20-Java-GC-原理"><a href="#20-Java-GC-原理" class="headerlink" title="20.Java GC 原理"></a>20.Java GC 原理</h3><blockquote>
<p>JVM的堆是Java对象的活动空间，程序中的类的对象从中分配空间，其存储着正在运行着的应用程序用到的所有对象。这些对象的建立方式就是那些new一类的操作，当对象无用后，是GC来负责这个无用的对象</p>
<p>GC的工作目的很明确：在堆中，找到已经无用的对象，并把这些对象占用的空间收回使其可以重新利用.大多数垃圾回收的 算法思路都是一致的：把所有对象组成一个集合，或可以理解为树状结构，从树根开始找，只要可以找到的都是活动对象，如果找不到，应该被回收了。</p>
</blockquote>
<h3 id="21-移动端跨平台开发"><a href="#21-移动端跨平台开发" class="headerlink" title="21.移动端跨平台开发"></a>21.移动端跨平台开发</h3><blockquote>
<p>Web 流：也被称为 Hybrid 技术，它基于 Web 相关技术来实现界面及功能：PhoneGap</p>
<p>虚拟机流：通过将某个语言的虚拟机移植到不同平台上来运行 Android</p>
<p>代码转换流：将某个语言转成 Objective-C、Java 或 C#，然后使用不同平台下的官方工具来开发</p>
</blockquote>
<hr>
<p>未经许可不得转载，转载请注明zilianliuxue的blog,本人保留所有版权。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;面试所遇到的问题：&quot;&gt;&lt;a href=&quot;#面试所遇到的问题：&quot; class=&quot;headerlink&quot; title=&quot;面试所遇到的问题：&quot;&gt;&lt;/a&gt;面试所遇到的问题：&lt;/h2&gt;&lt;h3 id=&quot;1-显示Intent与隐式Intent的区别&quot;&gt;&lt;a href=&quot;#1-显
    
    </summary>
    
      <category term="android" scheme="http://zilianliuxue.github.io/categories/android/"/>
    
    
      <category term="面试" scheme="http://zilianliuxue.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>window和windowManager</title>
    <link href="http://zilianliuxue.github.io/2016/06/20/Window%E4%B8%8EWindowManager/"/>
    <id>http://zilianliuxue.github.io/2016/06/20/Window与WindowManager/</id>
    <published>2016-06-20T09:58:00.000Z</published>
    <updated>2016-08-27T04:51:13.182Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>Window是一个窗口的概念，是一个抽象类，具体实现是PhoneWindow。<br>通过WindowManager来创建Window。<br>Window的具体实现位于WindowManagerService，WindowsManager和WindowMannagerService的交互是一个IPC的过程。</p>
</blockquote>
<h2 id="Window与WindowManager"><a href="#Window与WindowManager" class="headerlink" title="Window与WindowManager"></a>Window与WindowManager</h2><p>(1). 使用WindowManager添加一个Window的过程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">Button button = new Button(this);</div><div class="line">button.setText(&quot;button&quot;);</div><div class="line">WindowManager.LayoutParams params = new WindowManager.LayoutParams(</div><div class="line">        WindowManager.LayoutParams.WRAP_CONTENT,</div><div class="line">        WindowManager.LayoutParams.WRAP_CONTENT,</div><div class="line">        0, 0, PixelFormat.TRANSPARENT);</div><div class="line">params.flags = WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE</div><div class="line">        | WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL</div><div class="line">        | WindowManager.LayoutParams.FLAG_SHOW_WHEN_LOCKED;</div><div class="line">params.gravity = Gravity.LEFT | Gravity.TOP;</div><div class="line">params.x = 100;</div><div class="line">params.y = 300;</div><div class="line">WindowManager windowManager = (WindowManager) getSystemService(WINDOW_SERVICE);</div><div class="line">windowManager.addView(button,params);</div></pre></td></tr></table></figure>
<p>上面的代码将一个Button添加到屏幕坐标为（100，300）的位置.<br>(2).WindowManager.LayoutParams中的flag参数表示Window的属性，下面是几个比较常用的属性。</p>
<ul>
<li>FLAG_NOT_FOCUSABLE</li>
</ul>
<p>表示window不需要获取焦点，也不需要接收各种输入事件。此标记会同时启用FLAG_NOT_TOUCH_MODAL，最终事件会直接传递给下层的具有焦点的window；</p>
<ul>
<li>FLAG_NOT_TOUCH_MODAL：</li>
</ul>
<p>在此模式下，系统会将window区域外的单击事件传递给底层的window，当前window区域内的单击事件则自己处理，一般都需要开启这个标记；</p>
<ul>
<li>FLAG_SHOW_WHEN_LOCKED</li>
</ul>
<p>开启此模式可以让Window显示在锁屏的界面上</p>
<p>(3).TYPE参数表示Window的类型，有三种，分别是应用Window，子Window和系统Window。</p>
<p>应用window对应着一个Activity，子window不能独立存在，需要附属在特定的父window之上，比如Dialog就是子window。系统window是需要声明权限才能创建的window，比如Toast和系统状态栏这些都是系统window，需要声明的权限是。</p>
<p>(4). window是分层的，每个window都对应着z-ordered，层级大的会覆盖在层级小的上面，应用window的层级范围是1~99，子window的层级范围是1000~1999，系统window的层级范围是2000~2999。<br>[注意，应用window的层级范围并不是1~999哟]</p>
<p>(5).WindowManager继承自ViewManager，常用的只有三个方法：addView、updateView和removeView。</p>
<h2 id="Window的内部机制"><a href="#Window的内部机制" class="headerlink" title="Window的内部机制"></a>Window的内部机制</h2><p>(1).Window是一个抽象的概念，不是实际存在的，它也是以View的形式存在。在实际使用中无法直接访问Window，只能通过WindowManager才能访问Window。每个Window都对应着一个View和一个ViewRootImpl，Window和View通过ViewRootImpl来建立联系。</p>
<p>(2). Window的添加、删除和更新过程都是IPC过程，以Window的添加为例，WindowManager的实现类对于addView、updateView和removeView方法都是委托给WindowManagerGlobal类，该类保存了很多数据列表，例如所有window对应的view集合mViews、所有window对应的ViewRootImpl的集合mRoots等，之后添加操作交给了ViewRootImpl来处理，接着会通过WindowSession来完成Window的添加过程，这个过程是一个IPC调用，因为最终是通过WindowManagerService来完成window的添加的。</p>
<h2 id="Window的添加过程"><a href="#Window的添加过程" class="headerlink" title="Window的添加过程"></a>Window的添加过程</h2><p>(1)Activity的window创建过程</p>
<p>1.Activity的启动过程很复杂，最终会由ActivityThread中的performLaunchActivity来完成整个启动过程，在这个方法内部会通过类加载器创建Activity的实例对象，并调用它的attach方法为其关联运行过程中所依赖的一系列上下文环境变量；</p>
<p>2.Activity实现了Window的Callback接口，当window接收到外界的状态变化时就会回调Activity的方法，例如onAttachedToWindow、onDetachedFromWindow、dispatchTouchEvent等；</p>
<p>3.Activity的Window是由PolicyManager来创建的，它的真正实现是Policy类，它会新建一个PhoneWindow对象，Activity的setContentView的实现是由PhoneWindow来实现的；</p>
<p>4.Activity的顶级View是DecorView，它本质上是一个FrameLayout。如果没有DecorView，那么PhoneWindow会先创建一个DecorView，然后加载具体的布局文件并将view添加到DecorView的mContentParent中，最后就是回调Activity的onContentChanged通知Activity视图已经发生了变化；</p>
<p>5.还有一个步骤是让WindowManager能够识别DecorView，在ActivityThread调用handleResumeActivity方法时，首先会调用Activity的onResume方法，然后会调用makeVisible方法，这个方法中DecorView真正地完成了添加和显示过程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ViewManager vm = getWindowManager();</div><div class="line">vm.addView(mDecor, getWindow().getAttributes());</div><div class="line">mWindowAdded = true;</div></pre></td></tr></table></figure>
<p>(2)Dialog的Window创建过程</p>
<p>1.过程与Activity的Window创建过程类似，普通的Dialog的有一个特别之处，即它必须采用Activity的Context，如果采用Application的Context会报错。原因是Application没有应用token，应用token一般是Activity拥有的。</p>
<p>(3)Toast的Window创建过程</p>
<p>1.Toast属于系统Window，它内部的视图由两种方式指定：一种是系统默认的演示；另一种是通过setView方法来指定一个自定义的View。</p>
<p>2.Toast具有定时取消功能，所以系统采用了Handler。Toast的显示和隐藏是IPC过程，都需要NotificationManagerService来实现。在Toast和NMS进行IPC过程时，NMS会跨进程回调Toast中的TN类中的方法，TN类是一个Binder类，运行在Binder线程池中，所以需要通过Handler将其切换到当前发送Toast请求所在的线程，所以Toast无法在没有Looper的线程中弹出。</p>
<p>3.对于非系统应用来说，mToastQueue最多能同时存在50个ToastRecord，这样做是为了防止DOS(Denial of Service，拒绝服务)。因为如果某个应用弹出太多的Toast会导致其他应用没有机会弹出Toast。</p>
<h2 id="Window的删除过程"><a href="#Window的删除过程" class="headerlink" title="Window的删除过程"></a>Window的删除过程</h2><p>（1）Window的删除过程和添加过程一样，都是先通过WindowManagerImpl后，再进一步通过WindowManagerGlobal来实现的。</p>
<p>（2）WindowManagerGlobal.java中的removeView方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*** </span></div><div class="line"> * WindowManager的removeView的最终源头： </div><div class="line"> * <span class="doctag">@param</span> view </div><div class="line"> * <span class="doctag">@param</span> immediate </div><div class="line"> */  </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeView</span><span class="params">(View view, <span class="keyword">boolean</span> immediate)</span> </span>&#123;  </div><div class="line">    <span class="keyword">if</span> (view == <span class="keyword">null</span>) &#123;  </div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"view must not be null"</span>);  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="keyword">synchronized</span> (mLock) &#123;  </div><div class="line">    <span class="comment">// 首先查找待删除的View的索引，查找过程就是遍历建立的数组：  </span></div><div class="line">        <span class="keyword">int</span> index = findViewLocked(view, <span class="keyword">true</span>);  </div><div class="line">        View curView = mRoots.get(index).getView();  </div><div class="line">        <span class="comment">// 然后调用这个方法进一步删除：  </span></div><div class="line">        removeViewLocked(index, immediate);  </div><div class="line">        <span class="keyword">if</span> (curView == view) &#123;  </div><div class="line">            <span class="keyword">return</span>;  </div><div class="line">        &#125;  </div><div class="line">  </div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Calling with view "</span> + view  </div><div class="line">                + <span class="string">" but the ViewAncestor is attached to "</span> + curView);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>（3）removeViewLocked是通过ViewRootImpl来完成删除操作的。在WindowManager中提供了两种删除接口removeView和removeViewImmediate，它们分别表示异步删除和同步删除，其中removeViewImmediate使用起来需要特别注意，一般来说不需要使用此方法来删除Window以免发生意外的错误。具体的删除操作由ViewRootImpl的die方法来完成。在die的内部会判断是异步删除还是同步删除。在异步删除的情况下，die方法只是发送了一个请求删除的消息后就立刻返回了，这个时候View并没有完成删除操作，所以最后会将其添加到mDyingViews中，mDyingViews表示待删除的View列表。</p>
<p>WindowManagerGlobal.java中的removeViewLocked方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* </span></div><div class="line"> * 根据待删除View的index来做进一步删除View， </div><div class="line"> * removeViewLocked是通过ViewRootImpl来完成删除操作的。 </div><div class="line"> * */  </div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeViewLocked</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">boolean</span> immediate)</span> </span>&#123;  </div><div class="line">    ViewRootImpl root = mRoots.get(index);  </div><div class="line">    View view = root.getView();  </div><div class="line">  </div><div class="line">    <span class="keyword">if</span> (view != <span class="keyword">null</span>) &#123;  </div><div class="line">        InputMethodManager imm = InputMethodManager.getInstance();  </div><div class="line">        <span class="keyword">if</span> (imm != <span class="keyword">null</span>) &#123;  </div><div class="line">            imm.windowDismissed(mViews.get(index).getWindowToken());  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="keyword">boolean</span> deferred = root.die(immediate);  </div><div class="line">    <span class="keyword">if</span> (view != <span class="keyword">null</span>) &#123;  </div><div class="line">        view.assignParent(<span class="keyword">null</span>);  </div><div class="line">        <span class="keyword">if</span> (deferred) &#123;  </div><div class="line">            mDyingViews.add(view);  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>（4）具体的删除操作由ViewRootImpl的die方法来完成。 在die的内部会判断是异步删除还是同步删除。在异步删除的情况下，die方法只是发送了一个请求删除的消息后就立刻返回了，这个时候View并没有完成删除操作。doDie内部会调用dispatchDetachedFromWindow方法，真正删除View的逻辑在dispatchDetachedFromWindow方法的内部实现。</p>
<p>ViewRootImpl.java中die方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">die</span><span class="params">(<span class="keyword">boolean</span> immediate)</span> </span>&#123;  </div><div class="line">    <span class="comment">// Make sure we do execute immediately if we are in the middle of a traversal or the damage  </span></div><div class="line">    <span class="comment">// done by dispatchDetachedFromWindow will cause havoc on return.  </span></div><div class="line">    <span class="comment">/* </span></div><div class="line">     * 如果是同步删除（立即删除），那么就不发送消息直接调用doDie方法。 </div><div class="line">     * */  </div><div class="line">    <span class="keyword">if</span> (immediate &amp;&amp; !mIsInTraversal) &#123;  </div><div class="line">        doDie();  </div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="keyword">if</span> (!mIsDrawing) &#123;  </div><div class="line">        destroyHardwareRenderer();  </div><div class="line">    &#125; <span class="keyword">else</span> &#123;  </div><div class="line">        Log.e(TAG, <span class="string">"Attempting to destroy the window while drawing!\n"</span> +  </div><div class="line">                <span class="string">"  window="</span> + <span class="keyword">this</span> + <span class="string">", title="</span> + mWindowAttributes.getTitle());  </div><div class="line">    &#125;  </div><div class="line">    <span class="comment">/* </span></div><div class="line">     * 如果是异步操作，那么就发送一个MSG_DIE的消息， </div><div class="line">     * ViewRootImpl中的Handler会处理此消息并调用doDie方法。 </div><div class="line">     * */  </div><div class="line">    mHandler.sendEmptyMessage(MSG_DIE);  </div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>（5）ViewRootImpl.java中doDie方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* </span></div><div class="line"> * 在Die方法中会判断是用异步删除还是同步删除， </div><div class="line"> * 但归根结底还是要用doDie来完成删除View的操作。 </div><div class="line"> * 在doDie的内部会调用dispatchDetachedFromWindow方法， </div><div class="line"> * 真正删除View的逻辑在dispatchDetachedFromWindow方法的内部实现。 </div><div class="line"> * */  </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">doDie</span><span class="params">()</span> </span>&#123;  </div><div class="line">    checkThread();  </div><div class="line">    <span class="keyword">if</span> (LOCAL_LOGV) Log.v(TAG, <span class="string">"DIE in "</span> + <span class="keyword">this</span> + <span class="string">" of "</span> + mSurface);  </div><div class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;  </div><div class="line">        <span class="keyword">if</span> (mRemoved) &#123;  </div><div class="line">            <span class="keyword">return</span>;  </div><div class="line">        &#125;  </div><div class="line">        mRemoved = <span class="keyword">true</span>;  </div><div class="line">        <span class="keyword">if</span> (mAdded) &#123;  </div><div class="line">            <span class="comment">/* </span></div><div class="line">             * 这儿才是重点呢： </div><div class="line">             * */  </div><div class="line">            dispatchDetachedFromWindow();  </div><div class="line">        &#125;  </div><div class="line">  </div><div class="line">        <span class="keyword">if</span> (mAdded &amp;&amp; !mFirst) &#123;  </div><div class="line">            invalidateDisplayLists();  </div><div class="line">            destroyHardwareRenderer();  </div><div class="line">  </div><div class="line">            <span class="keyword">if</span> (mView != <span class="keyword">null</span>) &#123;  </div><div class="line">                <span class="keyword">int</span> viewVisibility = mView.getVisibility();  </div><div class="line">                <span class="keyword">boolean</span> viewVisibilityChanged = mViewVisibility != viewVisibility;  </div><div class="line">                <span class="keyword">if</span> (mWindowAttributesChanged || viewVisibilityChanged) &#123;  </div><div class="line">                    <span class="comment">// If layout params have been changed, first give them  </span></div><div class="line">                    <span class="comment">// to the window manager to make sure it has the correct  </span></div><div class="line">                    <span class="comment">// animation info.  </span></div><div class="line">                    <span class="keyword">try</span> &#123;  </div><div class="line">                        <span class="keyword">if</span> ((relayoutWindow(mWindowAttributes, viewVisibility, <span class="keyword">false</span>)  </div><div class="line">                                &amp; WindowManagerGlobal.RELAYOUT_RES_FIRST_TIME) != <span class="number">0</span>) &#123;  </div><div class="line">                            mWindowSession.finishDrawing(mWindow);  </div><div class="line">                        &#125;  </div><div class="line">                    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;  </div><div class="line">                    &#125;  </div><div class="line">                &#125;  </div><div class="line">  </div><div class="line">                mSurface.release();  </div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">  </div><div class="line">        mAdded = <span class="keyword">false</span>;  </div><div class="line">    &#125;  </div><div class="line">    WindowManagerGlobal.getInstance().doRemoveView(<span class="keyword">this</span>);  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>（5）doDie方法中调用的dispatchDetachedFromWindow是真正删除View的逻辑。</p>
<p>在doDie方法中调用，实现真正的删除View的逻辑。在这个方法中主要做四件事情：<br>（1）垃圾回收相关的工作，比如清除数据和消息、移除回调。<br>（2）通过Session的remove方法删除Window：mWindowSession.remove(mWindow)，这同样是一个IPC过程， 最终会调用WindowManagerService的removeWindow方法。<br>（3）调用View的dispatchDetachedFromWindow方法：</p>
<pre><code>* 在内部会调用View的onDetachedFromWindow()以及onDetachedFromWindowInternal（）。
* 对于onDetachedFromWindow()大家一定不陌生，当View从Window中移除时，这个方法就会被调用，
* 可以在这个方法内部做一些资源回收的工作，
* 比如终止动画、停止线程等。
</code></pre><p>（4）调用WindowManagerGlobal的doRemoveView方法刷新数据，包括mRoots、mParams以及mDyingViews， 需要将当前Window所关联的这三类对象从列表中删除。</p>
<p>ViewRootImpl.java中dispatchDetachedFromWindow方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatchDetachedFromWindow</span><span class="params">()</span> </span>&#123;  </div><div class="line">    <span class="keyword">if</span> (mView != <span class="keyword">null</span> &amp;&amp; mView.mAttachInfo != <span class="keyword">null</span>) &#123;  </div><div class="line">        <span class="keyword">if</span> (mAttachInfo.mHardwareRenderer != <span class="keyword">null</span> &amp;&amp;  </div><div class="line">                mAttachInfo.mHardwareRenderer.isEnabled()) &#123;  </div><div class="line">            mAttachInfo.mHardwareRenderer.validate();  </div><div class="line">        &#125;  </div><div class="line">        mAttachInfo.mTreeObserver.dispatchOnWindowAttachedChange(<span class="keyword">false</span>);  </div><div class="line">        mView.dispatchDetachedFromWindow();  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    mAccessibilityInteractionConnectionManager.ensureNoConnection();  </div><div class="line">    mAccessibilityManager.removeAccessibilityStateChangeListener(  </div><div class="line">            mAccessibilityInteractionConnectionManager);  </div><div class="line">    removeSendWindowContentChangedCallback();  </div><div class="line">  </div><div class="line">    destroyHardwareRenderer();  </div><div class="line">  </div><div class="line">    setAccessibilityFocus(<span class="keyword">null</span>, <span class="keyword">null</span>);  </div><div class="line">  </div><div class="line">    mView.assignParent(<span class="keyword">null</span>);  </div><div class="line">    mView = <span class="keyword">null</span>;  </div><div class="line">    mAttachInfo.mRootView = <span class="keyword">null</span>;  </div><div class="line">    mAttachInfo.mSurface = <span class="keyword">null</span>;  </div><div class="line">  </div><div class="line">    mSurface.release();  </div><div class="line">  </div><div class="line">    <span class="keyword">if</span> (mInputQueueCallback != <span class="keyword">null</span> &amp;&amp; mInputQueue != <span class="keyword">null</span>) &#123;  </div><div class="line">        mInputQueueCallback.onInputQueueDestroyed(mInputQueue);  </div><div class="line">        mInputQueue.dispose();  </div><div class="line">        mInputQueueCallback = <span class="keyword">null</span>;  </div><div class="line">        mInputQueue = <span class="keyword">null</span>;  </div><div class="line">    &#125;  </div><div class="line">    <span class="keyword">if</span> (mInputEventReceiver != <span class="keyword">null</span>) &#123;  </div><div class="line">        mInputEventReceiver.dispose();  </div><div class="line">        mInputEventReceiver = <span class="keyword">null</span>;  </div><div class="line">    &#125;  </div><div class="line">    <span class="keyword">try</span> &#123;  </div><div class="line">        mWindowSession.remove(mWindow);  </div><div class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="comment">// Dispose the input channel after removing the window so the Window Manager  </span></div><div class="line">    <span class="comment">// doesn't interpret the input channel being closed as an abnormal termination.  </span></div><div class="line">    <span class="keyword">if</span> (mInputChannel != <span class="keyword">null</span>) &#123;  </div><div class="line">        mInputChannel.dispose();  </div><div class="line">        mInputChannel = <span class="keyword">null</span>;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    unscheduleTraversals();  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>（7）整体的调用关系是：</p>
<p>ViewManager  –&gt;&gt; WindowManager（继承自ViewManager） –&gt;&gt; WindowManagerImpl（继承自WindowManager） –&gt;&gt;WindowManagerGlobal（WindowManagerImpl内部的一个对象） –&gt;&gt; ViewRooImpl.die（ViewRooImpl是WindowManagerGlobal的removeView方法中的一个对象） –&gt;&gt; doDie（die中的一个方法调用，判断异步还是同步删除） –&gt;&gt; dispatchDetachedFromWindow（在doDie方法中调用，真正用于删除View的逻辑） –&gt;&gt; 通过Session的remove方法删除Window（IPC过程） –&gt;&gt; WindowManagerService.removeWindow –&gt;&gt; dispatchDetachedFromWindow（这个是子View的dispatchDetachedFromWindow方法） –&gt;&gt; onDetachedFromWindow和onDetachedFromWindowInternal（都是子View中的） –&gt;&gt; WindowManagerGlobal.doRemoveView</p>
<h2 id="4、Window的更新过程"><a href="#4、Window的更新过程" class="headerlink" title="4、Window的更新过程"></a>4、Window的更新过程</h2><p>（1）从WindowManagerGlobal的updateViewLayout方法看起：</p>
<p>首先它需要更新View的LayoutParams并替换掉老的LayoutParams，接着再更新ViewRootImpl中的LayoutParams，这一步是通过ViewRootImpl的setLayoutParams方法来实现的。在ViewRootImpl中会通过scheduleTraversals方法来对View重新布局，包括测量、布局、重绘这三个过程。除了View本身的重绘以外，ViewRootImpl还会通过WindowSession来更新Window的视图，这个过程最终是由WindowManagerService的relayoutWindow（）来具体实现的，它同样是一个IPC过程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateViewLayout</span><span class="params">(View view, ViewGroup.LayoutParams params)</span> </span>&#123;  </div><div class="line">    <span class="keyword">if</span> (view == <span class="keyword">null</span>) &#123;  </div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"view must not be null"</span>);  </div><div class="line">    &#125;  </div><div class="line">    <span class="keyword">if</span> (!(params <span class="keyword">instanceof</span> WindowManager.LayoutParams)) &#123;  </div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Params must be WindowManager.LayoutParams"</span>);  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="keyword">final</span> WindowManager.LayoutParams wparams = (WindowManager.LayoutParams)params;  </div><div class="line">  </div><div class="line">    <span class="comment">/* </span></div><div class="line">     * 首先它需要更新View的LayoutParams并替换掉老的LayoutParams， </div><div class="line">     * */  </div><div class="line">    view.setLayoutParams(wparams);  </div><div class="line">  </div><div class="line">    <span class="keyword">synchronized</span> (mLock) &#123;  </div><div class="line">        <span class="keyword">int</span> index = findViewLocked(view, <span class="keyword">true</span>);  </div><div class="line">        ViewRootImpl root = mRoots.get(index);  </div><div class="line">        mParams.remove(index);  </div><div class="line">        mParams.add(index, wparams);  </div><div class="line">        root.setLayoutParams(wparams, <span class="keyword">false</span>);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>（2）整体的调用关系是：</p>
<p>ViewManager  –&gt;&gt; WindowManager（继承自ViewManager） –&gt;&gt; WindowManagerImpl（继承自WindowManager） –&gt;&gt;WindowManagerGlobal（WindowManagerImpl内部的一个对象） –&gt;&gt; updateViewLayout（WindowManagerGlobal中的一个方法） –&gt;&gt; setLayoutParams（updateViewLayout方法中调用） –&gt;&gt; ViewRootImpl.setLayoutParams（ViewRootImpl是updateViewLayout中的一个对象） –&gt;&gt; scheduleTraversals方法（在setLayoutParams中调用，在ViewRootImpl中） –&gt;&gt; WindowSession（在ViewRootImpl中，是一个Binder） –&gt;&gt; WindowManagerService.relayoutWindow（具体实现，更新Window的视图，IPC）</p>
<hr>
<p>未经许可不得转载，转载请注明zilianliuxue的blog,本人保留所有版权。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Window是一个窗口的概念，是一个抽象类，具体实现是PhoneWindow。&lt;br&gt;通过WindowManager来创建Window。&lt;br&gt;Window的具体实现位于WindowManagerService，WindowsManager和Win
    
    </summary>
    
      <category term="android" scheme="http://zilianliuxue.github.io/categories/android/"/>
    
    
      <category term="window" scheme="http://zilianliuxue.github.io/tags/window/"/>
    
  </entry>
  
  <entry>
    <title>ContentProvider的工作过程</title>
    <link href="http://zilianliuxue.github.io/2016/05/28/ContentProvider%E7%9A%84%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B/"/>
    <id>http://zilianliuxue.github.io/2016/05/28/ContentProvider的工作过程/</id>
    <published>2016-05-28T13:12:00.000Z</published>
    <updated>2016-08-27T03:30:51.271Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>ContentProvider是一种内容共享性组件，它通过Binder向其他组件乃至其他应用提供数据。</p>
</blockquote>
<p>首先来看一下流程图：</p>
<p><img src="https://imuhao.github.io/image/androidart_contentprovider.png" alt="img"></p>
<p>一个应用的入口方法为ActivityThread的main方法，该方法是一个静态方法，在main方法中会创建ActivityThread的实例并创建主线程的消息队列，然后在ActivityThread的attach方法中会远程调用AMS的attachApplication方法并将ApplicationThread对象提供给AMS，ApplicationThread是一个Binder对象，它的接口是IApplicattionThread，它主要用于ActivityThread和AMS之间通信。</p>
<p>访问ContentProvider需要通过ContentResolver，它是一个抽象类，通过Context的getContentResolver方法获取的实际上是ApplicationContentResolver对象，该类继承了ContentResolver并实现了ContentResolver中的抽象方法。通过ContentProvider的四个方法中任何一个都可以触发ContentProvider的启动。这里选择query方法。</p>
<p>ContentProvider的query方法首先会获取IContentProvider对象，最终会通过ApplicationContentResolver的acquireProvider方法，该方法没有做任何逻辑，直接调用了ActivityThread的acquireExistingProvider方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">public final IContentProvider acquireProvider(</div><div class="line">        Context c, String auth, int userId, boolean stable) &#123;</div><div class="line">    final IContentProvider provider = acquireExistingProvider(c, auth, userId, stable);</div><div class="line">    if (provider != null) &#123;</div><div class="line">        return provider;</div><div class="line">    &#125;</div><div class="line">    IActivityManager.ContentProviderHolder holder = null;</div><div class="line">    try &#123;</div><div class="line">        holder = ActivityManagerNative.getDefault().getContentProvider(</div><div class="line">                getApplicationThread(), auth, userId, stable);</div><div class="line">    &#125; catch (RemoteException ex) &#123;</div><div class="line">    &#125;</div><div class="line">    if (holder == null) &#123;</div><div class="line">        Slog.e(TAG, &quot;Failed to find provider info for &quot; + auth);</div><div class="line">        return null;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // Install provider will increment the reference count for us, and break</div><div class="line">    // any ties in the race.</div><div class="line">    holder = installProvider(c, holder, holder.info,</div><div class="line">            true /*noisy*/, holder.noReleaseNeeded, stable);</div><div class="line">    return holder.provider;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面代码中首先会从ActivityThread中查找是否已经存在ContentProvider，如果存在就直接返回，ActivityThread中通过mProviderMap来存储已经启动的ContentProvider对象，该容器的声明如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">final ArrayMap&lt;ProviderKey, ProviderClientRecord&gt; mProviderMap= new ArrayMap&lt;ProviderKey, ProviderClientRecord&gt;();</div></pre></td></tr></table></figure>
<p>如果不存在就发送一个进程间请求给AMS让其启动，再通过installProvider方法来修改引用计数。<br>AMS是通过startProcessLocked方法来完成进程的启动，内部主要通过Process的start方法来完成进程的启动，新进程启动后的入口方法为ActivityThread的main方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">public static void main(String[] args) &#123;</div><div class="line"></div><div class="line">       ActivityThread thread = new ActivityThread();</div><div class="line">       thread.attach(false);</div><div class="line"></div><div class="line">       if (sMainThreadHandler == null) &#123;</div><div class="line">           sMainThreadHandler = thread.getHandler();</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       if (false) &#123;</div><div class="line">           Looper.myLooper().setMessageLogging(new</div><div class="line">                   LogPrinter(Log.DEBUG, &quot;ActivityThread&quot;));</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       // End of event ActivityThreadMain.</div><div class="line">       Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</div><div class="line">       Looper.loop();</div><div class="line"></div><div class="line">       throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>在该方法中首先会调用ActivityThread的实例并调用attach方法进行初始化，然后进行消息循环，attach方法会将ApplicationThread对象通过AMS的attachApplication方法跨进程传给AMS，最终完成Contentprovider的创建。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">try &#123;</div><div class="line">                mgr.releaseSomeActivities(mAppThread);</div><div class="line">            &#125; catch (RemoteException e) &#123;</div><div class="line">            &#125;</div></pre></td></tr></table></figure>
<p>APS的attachApplication方法调用了attachApplicationLocked方法，该方法又调用了ApplicationThread的bindApplication方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">thread.bindApplication(processName, appInfo, providers, app.instrumentationClass,</div><div class="line">        profilerInfo, app.instrumentationArguments, app.instrumentationWatcher,</div><div class="line">        app.instrumentationUiAutomationConnection, testMode, enableOpenGlTrace,</div><div class="line">        isRestrictedBackupMode || !normalMode, app.persistent,</div><div class="line">        new Configuration(mConfiguration), app.compat,</div><div class="line">        getCommonServicesLocked(app.isolated),</div><div class="line">        mCoreSettingsObserver.getCoreSettingsLocked());</div></pre></td></tr></table></figure>
<p>ApplicationThread的bindApplication方法发送一个BIND_APPLICATION类型定位消息给mH，mH收到消息后会调用ActivityThread的handleBindApplication方法，该方法就完成了Application的创建以及Contentprovider的创建，可以分为四步：</p>
<p>1 创建ContextImpl和Instrumentation</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">ContextImpl instrContext = ContextImpl.createAppContext(this, pi);</div><div class="line"></div><div class="line">try &#123;</div><div class="line">    java.lang.ClassLoader cl = instrContext.getClassLoader();</div><div class="line">    mInstrumentation = (Instrumentation)</div><div class="line">        cl.loadClass(data.instrumentationName.getClassName()).newInstance();</div><div class="line">&#125; catch (Exception e) &#123;</div><div class="line">    throw new RuntimeException(</div><div class="line">        &quot;Unable to instantiate instrumentation &quot;</div><div class="line">        + data.instrumentationName + &quot;: &quot; + e.toString(), e);</div><div class="line">&#125;</div><div class="line"></div><div class="line">mInstrumentation.init(this, instrContext, appContext,</div><div class="line">       new ComponentName(ii.packageName, ii.name), data.instrumentationWatcher,</div><div class="line">       data.instrumentationUiAutomationConnection);</div></pre></td></tr></table></figure>
<p>2 创建Application对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Application app = data.info.makeApplication(data.restrictedBackupMode, null);</div><div class="line">mInitialApplication = app;</div></pre></td></tr></table></figure>
<p>3 启动当前进程的ContentProvider并调用其中onCreate方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">List&lt;ProviderInfo&gt; providers = data.providers;</div><div class="line">if (providers != null) &#123;</div><div class="line">    installContentProviders(app, providers);</div><div class="line">    // For process that contains content providers, we want to</div><div class="line">    // ensure that the JIT is enabled &quot;at some point&quot;.</div><div class="line">    mH.sendEmptyMessageDelayed(H.ENABLE_JIT, 10*1000);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>installContentProviders完成的ContentProvider的启动工作,首先会遍历当前进程的ProviderInfo的列表，并一一调用installProvider方法来启动他们，然后将启动的ContentProvider发布到AMS中，AMS会把他们存储在ProviderMap中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">private void installContentProviders(</div><div class="line">    Context context, List&lt;ProviderInfo&gt; providers) &#123;</div><div class="line">final ArrayList&lt;IActivityManager.ContentProviderHolder&gt; results =</div><div class="line">    new ArrayList&lt;IActivityManager.ContentProviderHolder&gt;();</div><div class="line"></div><div class="line">for (ProviderInfo cpi : providers) &#123;</div><div class="line">    if (DEBUG_PROVIDER) &#123;</div><div class="line">        StringBuilder buf = new StringBuilder(128);</div><div class="line">        buf.append(&quot;Pub &quot;);</div><div class="line">        buf.append(cpi.authority);</div><div class="line">        buf.append(&quot;: &quot;);</div><div class="line">        buf.append(cpi.name);</div><div class="line">        Log.i(TAG, buf.toString());</div><div class="line">    &#125;</div><div class="line">    IActivityManager.ContentProviderHolder cph = installProvider(context, null, cpi,</div><div class="line">            false /*noisy*/, true /*noReleaseNeeded*/, true /*stable*/);</div><div class="line">    if (cph != null) &#123;</div><div class="line">        cph.noReleaseNeeded = true;</div><div class="line">        results.add(cph);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">try &#123;</div><div class="line">    ActivityManagerNative.getDefault().publishContentProviders(</div><div class="line">        getApplicationThread(), results);</div><div class="line">&#125; catch (RemoteException ex) &#123;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面来看一下COntentProvider对象的创建过程，在installProvider方法中有下面一段代码，通过类加载器完成对象创建</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">final java.lang.ClassLoader cl = c.getClassLoader();</div><div class="line">localProvider = (ContentProvider)cl.</div><div class="line">    loadClass(info.name).newInstance();</div><div class="line">provider = localProvider.getIContentProvider();</div><div class="line">if (provider == null) &#123;</div><div class="line">    Slog.e(TAG, &quot;Failed to instantiate class &quot; +</div><div class="line">          info.name + &quot; from sourceDir &quot; +</div><div class="line">          info.applicationInfo.sourceDir);</div><div class="line">    return null;</div><div class="line">&#125;</div><div class="line">if (DEBUG_PROVIDER) Slog.v(</div><div class="line">    TAG, &quot;Instantiating local provider &quot; + info.name);</div><div class="line">// XXX Need to create the correct context for this provider.</div><div class="line">localProvider.attachInfo(c, info);</div></pre></td></tr></table></figure>
<p>上面代码还会调用COntentProvider的attachInfo方法来调用他的onCreate方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">private void attachInfo(Context context, ProviderInfo info, boolean testing) &#123;</div><div class="line">    mNoPerms = testing;</div><div class="line"></div><div class="line">    if (mContext == null) &#123;</div><div class="line">        mContext = context;</div><div class="line">        if (context != null) &#123;</div><div class="line">            mTransport.mAppOpsManager = (AppOpsManager) context.getSystemService(</div><div class="line">                    Context.APP_OPS_SERVICE);</div><div class="line">        &#125;</div><div class="line">        mMyUid = Process.myUid();</div><div class="line">        if (info != null) &#123;</div><div class="line">            setReadPermission(info.readPermission);</div><div class="line">            setWritePermission(info.writePermission);</div><div class="line">            setPathPermissions(info.pathPermissions);</div><div class="line">            mExported = info.exported;</div><div class="line">            mSingleUser = (info.flags &amp; ProviderInfo.FLAG_SINGLE_USER) != 0;</div><div class="line">            setAuthorities(info.authority);</div><div class="line">        &#125;</div><div class="line">        ContentProvider.this.onCreate();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>到此为止onCreate方法已经被调用，意味着ContentProvider已经启动完成。</p>
<p>4 调用Application的onCreate方法</p>
<p>经过上面四个步骤，ContentPorovider已经成功启动，然后其他应用就可通过AMS来访问这个ContentProvider，拿到该对象之后就可以通过它所提供的接口来访问它了。</p>
<hr>
<p>未经许可不得转载，转载请注明zilianliuxue的blog,本人保留所有版权。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;ContentProvider是一种内容共享性组件，它通过Binder向其他组件乃至其他应用提供数据。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;首先来看一下流程图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imuhao.github.i
    
    </summary>
    
      <category term="android" scheme="http://zilianliuxue.github.io/categories/android/"/>
    
    
      <category term="ContentProvider" scheme="http://zilianliuxue.github.io/tags/ContentProvider/"/>
    
  </entry>
  
  <entry>
    <title>安卓实战之如何快速搭建app架构</title>
    <link href="http://zilianliuxue.github.io/2016/05/23/%E5%AE%89%E5%8D%93%E5%AE%9E%E6%88%98%E4%B9%8B%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BAapp%E6%9E%B6%E6%9E%84/"/>
    <id>http://zilianliuxue.github.io/2016/05/23/安卓实战之如何快速搭建app架构/</id>
    <published>2016-05-23T14:44:00.000Z</published>
    <updated>2016-07-30T02:33:03.267Z</updated>
    
    <content type="html"><![CDATA[<h2 id="如何选择app架构（MVC-MVP-MVVM）"><a href="#如何选择app架构（MVC-MVP-MVVM）" class="headerlink" title="如何选择app架构（MVC/MVP/MVVM）"></a>如何选择app架构（MVC/MVP/MVVM）</h2><p>最近越来越多的人开始谈论架构。我周围的同事和工程师也是如此。尽管我还不是特别深入理解MVP，但是还是觉得比较牛逼,然后呢也想在公司的项目中去使用它。</p>
<h3 id="项目时间紧迫：快速开发框架（迫不得已）"><a href="#项目时间紧迫：快速开发框架（迫不得已）" class="headerlink" title="项目时间紧迫：快速开发框架（迫不得已）"></a>项目时间紧迫：快速开发框架（迫不得已）</h3><p>目前网络上也有一些针对Android的快速开发框架，下面介绍3个主要的快速开发框架。针对这些快速开发框架，个人认为可以参考，但并不推荐使用，因为App整体依赖一个个人维护的框架风险实在太大，框架存在一些学习成本，本身也不一定完全符合App的需求，使用后可能存在代码的臃肿，还有就是架构限制。</p>
<ul>
<li><p>Afinal</p>
<p>GitHub项目地址：<a href="https://github.com/yangfuhai/afinal" target="_blank" rel="external">Afinal</a></p>
<p>Afinal是一个Android的IOC，ORM框架，内置了四大模块功能：FinalAcitivity, FinalBitmap, FinalDb, FinalHttp。通过FinalActivity，可以通过注解的方式进行绑定UI和事件。通过FinalBitmap，可以方便的加载Bitmap图片，而无需考虑OOM等问题。通过FinalDB模块，通过一行代码就可以对Android的SQlite数据库进行增删改查。通过FinalHttp模块，可以以Ajax形式请求Http数据。   </p>
<blockquote>
<p>然而项目从去年就没有人更新维护了，ioc框架很多人不太喜欢而且性能不好。</p>
</blockquote>
</li>
</ul>
<ul>
<li>xUtils3.0</li>
</ul>
<p>GitHub项目地址：<a href="https://github.com/wyouflf/xUtils3" target="_blank" rel="external">xUtils3.0</a></p>
<ol>
<li>xUtils 支持超大文件(超过2G)上传，更全面的http请求协议支持(11种谓词)，拥有更加灵活的ORM，更多的事件注解支持且不受混淆影响…</li>
<li>xUtils 最低兼容Android 4.0 (api level 14). (Android 2.3?)</li>
<li><p>xUtils3变化较多所以建立了新的项目不在旧版(github.com/wyouflf/xUtils)上继续维护, 相对于旧版本:</p>
<ul>
<li>HTTP实现替换HttpClient为UrlConnection, 自动解析回调泛型, 更安全的断点续传策略.</li>
<li>支持标准的Cookie策略, 区分domain, path…</li>
<li>事件注解去除不常用的功能, 提高性能.</li>
<li>数据库api简化提高性能, 达到和greenDao一致的性能.</li>
<li>图片绑定支持gif(受系统兼容性影响, 部分gif文件只能静态显示), webp; 支持圆角, 圆形, 方形等裁剪, 支持自动旋转…<blockquote>
<p>可以看出xUtils3对于快速开发是一个不错的选择。</p>
</blockquote>
</li>
</ul>
</li>
</ol>
<h3 id="自己从零开始搭建app架构"><a href="#自己从零开始搭建app架构" class="headerlink" title="自己从零开始搭建app架构"></a>自己从零开始搭建app架构</h3><h4 id="简单的看下这三个架构模式："><a href="#简单的看下这三个架构模式：" class="headerlink" title="简单的看下这三个架构模式："></a>简单的看下这三个架构模式：</h4><ul>
<li>MVC：Model-View-Controller，经典模式，很容易理解，主要缺点有两个：<br>View对Model的依赖，会导致View也包含了业务逻辑；<br>Controller会变得很厚很复杂。</li>
<li>MVP：Model-View-Presenter，MVC的一个演变模式，将Controller换成了Presenter，主要为了解决上述第一个缺点，将View和Model解耦，不过第二个缺点依然没有解决。</li>
<li>MVVM：Model-View-ViewModel，是对MVP的一个优化模式，采用了双向绑定：View的变动，自动反映在ViewModel，反之亦然。<h4 id="面对众多的架构模式你会选择哪个？"><a href="#面对众多的架构模式你会选择哪个？" class="headerlink" title="面对众多的架构模式你会选择哪个？"></a>面对众多的架构模式你会选择哪个？</h4><blockquote>
<p>MVC，MVP还是MVVM？</p>
<p>越高级的模式复杂性越高，实现起来也越难。然后搭建项目时也是看项目的需求，别人说好你也有要实用才好，高效的实现项目的功能才是最好的架构模式。</p>
</blockquote>
</li>
</ul>
<p>那么，哪一个才是最好的呢？</p>
<blockquote>
<p>个人觉得适合你的才是最好的，不要去盲目的跟风，大家说mvp好那你就使用咯，没有实践就没有话语权，所以说用哪种架构模式本人不发表任何意见：任何模式的动机都是一样的，那就是如何避免复杂混乱的代码，让执行单元测试变得容易，创造高质量应用程序，开发维护更高效。</p>
</blockquote>
<p>在实际项目中思考架构时，也不会想着要用哪种模式，我只思考现阶段，以现有的人力资源和时间资源，如何才能更快更好地完成需求，适当考虑下如何为后期扩展或重构做准备。</p>
<h3 id="我项目中的架构"><a href="#我项目中的架构" class="headerlink" title="我项目中的架构"></a>我项目中的架构</h3><p>这是我上一个项目的包架构：</p>
<p><img src="http://i.imgur.com/KuUakbm.png" alt=""></p>
<p>当然咯，是按功能分的包，项目的功能不一样然后分包也不一样，但是基本大同小异。<br>所以确定架构分包的时候那就按你的需求来咯。  </p>
<p>从上面可以看出：架构分包的时候我们包括逻辑功能和基础功能（通用功能）。  </p>
<h4 id="基础功能模块："><a href="#基础功能模块：" class="headerlink" title="基础功能模块："></a>基础功能模块：</h4><ul>
<li><p>日志管理系统（LogManager）</p>
<blockquote>
<p>不管哪个项目都需要自己的一套日志管理，一是为了生产调试时能更加高效的查看过滤日志，二是为了打包发布的时候用开关控制日志是否打印。  （我的日志用的是凯子哥的：<a href="https://github.com/ZhaoKaiQiang/KLog" target="_blank" rel="external">Klog</a>）</p>
</blockquote>
</li>
<li>异常处理(crashManager)<blockquote>
<p>作用：当程序遇见异常情况时我们能够自定义异常处理，二是程序对不同的机型有不同的反应，那么测试时候可能没有发现但是我们可以把捕获的crash上传到服务器，便于异常收集和bug修复。</p>
</blockquote>
</li>
<li><p>utils(工具类)</p>
<blockquote>
<p>根据你的项目需求来合理定制你的工具类，将会对你的项目开发速度有很大的提升（反馈，版本校验更新你肯定能够用到）</p>
</blockquote>
<p>看下我上个项目的工具类：  </p>
</li>
</ul>
<p><img src="http://i.imgur.com/paV4K5g.png" alt=""> </p>
<ul>
<li>permission(权限管理系统)<blockquote>
<p>这功能是绝对项目中需要的，别告诉我你的项目还没有适配安卓6.0，适配了就肯定会有权限管理，我这里用的是<a href="http://blog.csdn.net/u013278099/article/details/50612266" target="_blank" rel="external"> 安卓6.0权限处理在项目中的实践</a>,也还可以吧，反正github上的权限管理的开源东西比较多，觉得合适就ok。</p>
</blockquote>
</li>
</ul>
<p>哈哈，这样你的基础功能都搭建好了，然后就是一些逻辑功能的封装了。</p>
<h4 id="逻辑功能模块："><a href="#逻辑功能模块：" class="headerlink" title="逻辑功能模块："></a>逻辑功能模块：</h4><p> 1.封装自己的application和baseActivity类，最大可能的节省代码，加入mvp的思想来架构。</p>
<p> 2.选择自己喜欢的网络请求框架并且适当合理的进行封装，加快开发的效率。</p>
<p> 3.针对带有滚动控件嵌套有可能产生的滑动冲突，或者显示不全我们优先自定义一下viewpager,listview,gridview等。</p>
<p> 4.封装listView或者recyclerView打造万能的适配器，觉得翔哥的封装的不错<a href="https://github.com/hongyangAndroid/baseAdapter" target="_blank" rel="external"> 打造万能的适配器</a>。</p>
<p> 5.一般的网络数据格式是json(我们就逗：普通数据json,刷卡交易数据xml),所以呢我json格式的用gson封装一下,xml格式暂时用的是pull解析后bean对象封装。</p>
<p> 6.数据库的封装，对数据苦要求不高的话可以用原生的简单封装一下curd就好了，要求高点的话那就用第三方的好了。</p>
<h3 id="开发过程中第三方开源库的抉择"><a href="#开发过程中第三方开源库的抉择" class="headerlink" title="开发过程中第三方开源库的抉择"></a>开发过程中第三方开源库的抉择</h3><h4 id="图片加载库："><a href="#图片加载库：" class="headerlink" title="图片加载库："></a>图片加载库：</h4><ul>
<li><p>Glide:相比较UIL，glide可以支持gif和短视频,支持与activity，fragment，application生命周期的联动,支持 okhttp、Volley</p>
</li>
<li><p>Fresco:三级缓存牛逼，对多帧动画图片支持更好，如 Gif、WebP</p>
</li>
<li><p>UIL：老牌的虽然不再更新维护，但功能强大</p>
<blockquote>
<p>根据你的项目需求选择，熟悉UIL就用它，个人推荐Glide</p>
</blockquote>
</li>
</ul>
<h4 id="网络请求库："><a href="#网络请求库：" class="headerlink" title="网络请求库："></a>网络请求库：</h4><ul>
<li><p>okhttp:</p>
<blockquote>
<p>okhttp是高性能的http库，支持同步、异步，而且实现了spdy、http2、websocket协议，api很简洁易用，和volley一样实现了http协议的缓存。</p>
</blockquote>
</li>
<li><p>retrofit:</p>
<blockquote>
<p>简化了网络请求流程，同时自己内部对OkHtttp客户端做了封装，同时2.x把之前1.x版本的部分不恰当职责都转移给OkHttp了(例如Log，目前用OkHttp的Interceptor来实现)</p>
</blockquote>
</li>
<li><p>volley:</p>
<blockquote>
<p>volley是一个简单的异步http库，仅此而已。缺点是不支持同步，这点会限制开发模式；不能post大数据，所以不适合用来上传文件。</p>
</blockquote>
</li>
</ul>
<p>个人建议使用retrofit，volley的通用性不高（资料最多）。</p>
<h4 id="事件总线库："><a href="#事件总线库：" class="headerlink" title="事件总线库："></a>事件总线库：</h4><blockquote>
<p>主要用来消息/事件的传递，却能实现组建之间的解耦。</p>
</blockquote>
<p>eventBus3.0和otto都是使用注解的方式（@Subscribe、@Produce）来标注方法，Otto更多的使用场景是在主线程中，相对是轻量级的。</p>
<blockquote>
<p>如果你对是不是轻量级不关心的话，我觉得两个差不多，但是还是很多人推荐使用otto。</p>
</blockquote>
<h4 id="依赖注入库："><a href="#依赖注入库：" class="headerlink" title="依赖注入库："></a>依赖注入库：</h4><p>butterknife8.0： <a href="https://github.com/JakeWharton/butterknife" target="_blank" rel="external">https://github.com/JakeWharton/butterknife</a><br>在任何项目中使用butterknife都是正确且没有问题的. 非常轻量级的库，原因是性能高节省代码，而且不是你们所想的反射机制实现的。</p>
<p>Dagger2：它是不具有动态性的（使用时完全不使用反射）但是生成的代码的简洁性和性能都是与手写的代码同水准的。</p>
<blockquote>
<p>2个都是很棒的，你可以选择额。</p>
</blockquote>
<h4 id="数据库存储："><a href="#数据库存储：" class="headerlink" title="数据库存储："></a>数据库存储：</h4><ul>
<li><p>LitePal：LitePal是一款开源的Android数据库框架，它采用了对象关系映射(ORM)的模式，LitePal很“轻”，jar包只有100k不到，使用起来也比较简单，源码地址为<a href="https://github.com/LitePalFramework/LitePal" target="_blank" rel="external">LitePal</a>地址,郭神开发的就是牛。</p>
</li>
<li><p>greenDAO:greenDAO与LitePal不同，其原理不是根据反射进行数据库的各项操作，而是一开始就人工生成业务需要的Model和DAO文件，业务中可以直接调用相应的DAO文件进行数据库操作，从而避免了因反射带来的性能损耗和效率低下。但是由于需要人工生成model和DAO文件，所以greenDAO的配置就略显复杂。</p>
</li>
</ul>
<blockquote>
<p>greenDAO用起来繁琐但是效率高点，LitePal用起来简单，所以你自己选择吧，个人还是觉得LitePal好用点。  </p>
</blockquote>
<h4 id="简单缓存"><a href="#简单缓存" class="headerlink" title="简单缓存"></a>简单缓存</h4><p><a href="">ASimpleCache</a>:ASimpleCache 是一个为android制定的 轻量级的 开源缓存框架。轻量到只有一个java文件（由十几个类精简而来）。</p>
<ul>
<li>可缓存普通的字符串、JsonObject、JsonArray、Bitmap、Drawable、序列化的java对象，和 byte数据。普通的字符串、JsonObject、JsonArray、Bitmap、Drawable、序列化的java对象，和 byte数据。</li>
<li>替换SharePreference当做配置文件</li>
<li>可以缓存网络请求数据，比如oschina的android客户端可以缓存http请求的新闻内容，缓存时间假设为1个小时，超时后自动失效，让客户端重新请求新的数据，减少客户端流量，同时减少服务器并发量。    </li>
</ul>
<p>哈哈项目需要的基本架构需要的开源库都有了，你可以放心的开发了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong><em>其实架构并不是那么难，也不要别人说怎么好就怎么干，你要相信总有一个东西是适合你的，打个比喻app架构就是盖房子，砖少就盖矮点吗，但是必须保证得结实，就像 框架不一定要强大但是必须健壮具有扩展性。</em></strong></p>
<hr>
<p>未经许可不得转载，转载请注明zilianliuxue的blog,本人保留所有版权。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;如何选择app架构（MVC-MVP-MVVM）&quot;&gt;&lt;a href=&quot;#如何选择app架构（MVC-MVP-MVVM）&quot; class=&quot;headerlink&quot; title=&quot;如何选择app架构（MVC/MVP/MVVM）&quot;&gt;&lt;/a&gt;如何选择app架构（MVC/MVP
    
    </summary>
    
      <category term="android" scheme="http://zilianliuxue.github.io/categories/android/"/>
    
    
      <category term="快速开发" scheme="http://zilianliuxue.github.io/tags/%E5%BF%AB%E9%80%9F%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>BroadcastReceiver 的工作过程</title>
    <link href="http://zilianliuxue.github.io/2016/05/22/BroadcastReceiver%E7%9A%84%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B/"/>
    <id>http://zilianliuxue.github.io/2016/05/22/BroadcastReceiver的工作过程/</id>
    <published>2016-05-22T01:56:00.000Z</published>
    <updated>2016-08-27T04:51:33.667Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>本文将介绍BroadcastReceiver的工作过程,主要包含两个方面的内容，一个是广播的注册过程，一个是广播的发送和接受过程。</p>
</blockquote>
<h2 id="广播的注册过程"><a href="#广播的注册过程" class="headerlink" title="广播的注册过程"></a>广播的注册过程</h2><p>首先看下流程图：</p>
<p><img src="https://imuhao.github.io/image/androidart_broadcastreceiver1.png" alt="img"></p>
<p>广播注册分为静态和动态注册，静态注册是由PMS（PackageManagerService）来实现的，除了广播其他三大组建都是应用安装时由PMS解析并注册的。<br>这里只分析广播的动态注册，动态注册过程是从ContextWrapper的registerReceiver方法开始的，ContextWrapper并没有实际工作，而是将注册交给了ContextImpl来完成。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public Intent registerReceiver(BroadcastReceiver receiver, IntentFilter filter) &#123;</div><div class="line">    return registerReceiver(receiver, filter, null, null);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ContextImpl调用自己的registerReceiverInternal方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">private Intent registerReceiverInternal(BroadcastReceiver receiver, int userId,</div><div class="line">            IntentFilter filter, String broadcastPermission,</div><div class="line">            Handler scheduler, Context context) &#123;</div><div class="line">        IIntentReceiver rd = null;</div><div class="line">        if (receiver != null) &#123;</div><div class="line">            if (mPackageInfo != null &amp;&amp; context != null) &#123;</div><div class="line">                if (scheduler == null) &#123;</div><div class="line">                    scheduler = mMainThread.getHandler();</div><div class="line">                &#125;</div><div class="line">                rd = mPackageInfo.getReceiverDispatcher(</div><div class="line">                    receiver, context, scheduler,</div><div class="line">                    mMainThread.getInstrumentation(), true);</div><div class="line">            &#125; else &#123;</div><div class="line">                if (scheduler == null) &#123;</div><div class="line">                    scheduler = mMainThread.getHandler();</div><div class="line">                &#125;</div><div class="line">                rd = new LoadedApk.ReceiverDispatcher(</div><div class="line">                        receiver, context, scheduler, null, true).getIIntentReceiver();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        try &#123;</div><div class="line">            return ActivityManagerNative.getDefault().registerReceiver(</div><div class="line">                    mMainThread.getApplicationThread(), mBasePackageName,</div><div class="line">                    rd, filter, broadcastPermission, userId);</div><div class="line">        &#125; catch (RemoteException e) &#123;</div><div class="line">            return null;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>在上面代码中系统从mPackageInfo中获取IIntentReceiver对象，然后采用跨进成的方式向AMS发送广播注册的请求，之所以采用IIntentReceiver是因为注册是一个进程间通信的过程，IIntentReceiver是一个Binder接口，他的具体实现是LoadedApk.ReceiverDispatcher内部类，该内部类同时保存了BroadcastReceivr和InnerReceiver，这样当接受到广播时，ReceiverDispatcher可以很方便的调用广播的onReceiver方法。</p>
<p>广播的真正实现过程是在AMS中的，AMS的registerReceiver的关键只有下面一部分，最终会把远程的InnerReceiver对象以及IntentFilter对象存储起来。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public Intent registerReceiver(IApplicationThread caller, String callerPackage,IIntentReceiver receiver, 、</div><div class="line">IntentFilter filter, String permission, int userId) </div><div class="line"></div><div class="line">mRegisteredReceivers.put(receiver.asBinder(), rl);</div><div class="line">BroadcastFilter bf = new BroadcastFilter(filter, rl, callerPackage,</div><div class="line">                permission, callingUid, userId);</div><div class="line"> rl.add(bf);</div><div class="line">        if (!bf.debugCheck()) &#123;</div><div class="line">            Slog.w(TAG, &quot;==&gt; For Dynamic broadcast&quot;);</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<p>这样整个广播的注册过程就完成了。</p>
<h2 id="广播的发送和接受过程"><a href="#广播的发送和接受过程" class="headerlink" title="广播的发送和接受过程"></a>广播的发送和接受过程</h2><p>流程图：</p>
<p><img src="https://imuhao.github.io/image/androidart_broadcastreceiver2.png" alt="img"></p>
<p>当通过send方法来发送广播时，AMS会查找出匹配的广播接受者并将广播发送给他们处理。<br>广播发送有几种类型：普通广播、有序广播、粘性广播。这里只分析普通广播的实现。</p>
<p>广播的发送开始于ContextImpl的sendBroadcast，源码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public void sendBroadcast(Intent intent) &#123;</div><div class="line">    warnIfCallingFromSystemProcess();</div><div class="line">    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());</div><div class="line">    try &#123;</div><div class="line">        intent.prepareToLeaveProcess();</div><div class="line">        ActivityManagerNative.getDefault().broadcastIntent(</div><div class="line">                mMainThread.getApplicationThread(), intent, resolvedType, null,</div><div class="line">                Activity.RESULT_OK, null, null, null, AppOpsManager.OP_NONE, null, false, false,</div><div class="line">                getUserId());</div><div class="line">    &#125; catch (RemoteException e) &#123;</div><div class="line">        throw new RuntimeException(&quot;Failure from system&quot;, e);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ContextImpl几乎什么都没干，直接向AMS发起一个异步请求发送广播。下面是AMS对广播发送过程的处理。AMS的broadcastIntent的方法源码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public final int broadcastIntent(IApplicationThread caller,Intent intent, String resolvedType, IIntentReceiver resultTo,int resultCode, String resultData, Bundle resultExtras,String[] requiredPermissions, int appOp, Bundle options, boolean serialized, boolean sticky, int userId) &#123;</div><div class="line"></div><div class="line">    enforceNotIsolatedCaller(&quot;broadcastIntent&quot;);</div><div class="line">    synchronized(this) &#123;</div><div class="line">        intent = verifyBroadcastLocked(intent);</div><div class="line"></div><div class="line">        final ProcessRecord callerApp = getRecordForAppLocked(caller);</div><div class="line">        final int callingPid = Binder.getCallingPid();</div><div class="line">        final int callingUid = Binder.getCallingUid();</div><div class="line">        final long origId = Binder.clearCallingIdentity();</div><div class="line">        int res = broadcastIntentLocked(callerApp,</div><div class="line">                callerApp != null ? callerApp.info.packageName : null,</div><div class="line">                intent, resolvedType, resultTo, resultCode, resultData, resultExtras,</div><div class="line">                requiredPermissions, appOp, null, serialized, sticky,</div><div class="line">                callingPid, callingUid, userId);</div><div class="line">        Binder.restoreCallingIdentity(origId);</div><div class="line">        return res;</div><div class="line">    &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>broadcastIntent方法又调用了broadcastIntentLocked方法。该方法的开始有这一行代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// By default broadcasts do not go to stopped apps.</div><div class="line">   intent.addFlags(Intent.FLAG_EXCLUDE_STOPPED_PACKAGES);</div></pre></td></tr></table></figure>
<p>这表示广播不会发送给已经停止的我应用，从Android3.1开始已经具有这种特性，这是因为在Android3.1中为Intent添加了两个标记，分别是FLAG_EXCLUDE_STOPPED_PACKAGES和FLAG_EXCLUDE_STOPPED_PACKAGES用来控制广播是否对停止应用起作用。</p>
<ul>
<li>FLAG <em>INCLUDE </em>STOPPED _ PACKAGES</li>
</ul>
<p>表示包含已经停止的应用，这个时候广播会发送给已经停止的应用</p>
<ul>
<li>FLAG <em>EXCLUDE </em>STOPPED _ PACKAGES</li>
</ul>
<p>表示不包含已经停止的应用，这个时候广播不会发送给已经停止的应用。</p>
<p>从3.1开始默认为所有广播添加了FLAG <em>EXCLUDE </em>STOPPED _ PACKAGES标志。</p>
<p>处于停止状态分为两种情形：</p>
<ol>
<li>应用安装后未运行</li>
<li>应用被手动或其他应用强停。</li>
</ol>
<p>从Android3.1开始处于停止状态的应用同样无法接收到开机广播。</p>
<p>在broadcastIntentLocked内部会根据intentfilter查找匹配的广播接受者，将满足条件的广播添加到BroadcastQueue中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">if ((receivers != null &amp;&amp; receivers.size() &gt; 0)</div><div class="line">                || resultTo != null) &#123;</div><div class="line">            BroadcastQueue queue = broadcastQueueForIntent(intent);</div><div class="line">            BroadcastRecord r = new BroadcastRecord(queue, intent, callerApp,</div><div class="line">                    callerPackage, callingPid, callingUid, resolvedType,</div><div class="line">                    requiredPermissions, appOp, brOptions, receivers, resultTo, resultCode,</div><div class="line">                    resultData, resultExtras, ordered, sticky, false, userId);</div><div class="line"></div><div class="line">            if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST, &quot;Enqueueing ordered broadcast &quot; + r</div><div class="line">                    + &quot;: prev had &quot; + queue.mOrderedBroadcasts.size());</div><div class="line">            if (DEBUG_BROADCAST) Slog.i(TAG_BROADCAST,</div><div class="line">                    &quot;Enqueueing broadcast &quot; + r.intent.getAction());</div><div class="line"></div><div class="line">            boolean replaced = replacePending &amp;&amp; queue.replaceOrderedBroadcastLocked(r);</div><div class="line">            if (!replaced) &#123;</div><div class="line">                queue.enqueueOrderedBroadcastLocked(r);</div><div class="line">                queue.scheduleBroadcastsLocked();</div><div class="line">            &#125;</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<p>接着我们来看BroadcastQueue的scheduleBroadcastsLocked方法实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public void scheduleBroadcastsLocked() &#123;</div><div class="line">       if (mBroadcastsScheduled) &#123;</div><div class="line">           return;</div><div class="line">       &#125;</div><div class="line">       mHandler.sendMessage(mHandler.obtainMessage(BROADCAST_INTENT_MSG, this));</div><div class="line">       mBroadcastsScheduled = true;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>该方法并没有立即发送广播，而是发送了一个BROADCAST_INTENT_MSG类型的消息。当BroadcastQueue收到消息之后会调用processNextBroadcast方法。该方法对普通广播的处理如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">while (mParallelBroadcasts.size() &gt; 0) &#123;</div><div class="line">    r = mParallelBroadcasts.remove(0);</div><div class="line">    r.dispatchTime = SystemClock.uptimeMillis();</div><div class="line">    r.dispatchClockTime = System.currentTimeMillis();</div><div class="line">    final int N = r.receivers.size();</div><div class="line">    if (DEBUG_BROADCAST_LIGHT) Slog.v(TAG_BROADCAST, &quot;Processing parallel broadcast [&quot;</div><div class="line">            + mQueueName + &quot;] &quot; + r);</div><div class="line">    for (int i=0; i&lt;N; i++) &#123;</div><div class="line">        Object target = r.receivers.get(i);</div><div class="line">        if (DEBUG_BROADCAST)  Slog.v(TAG_BROADCAST,</div><div class="line">                &quot;Delivering non-ordered on [&quot; + mQueueName + &quot;] to registered &quot;</div><div class="line">                + target + &quot;: &quot; + r);</div><div class="line">        deliverToRegisteredReceiverLocked(r, (BroadcastFilter)target, false);</div><div class="line">    &#125;</div><div class="line">    addBroadcastToHistoryLocked(r);</div><div class="line">    if (DEBUG_BROADCAST_LIGHT) Slog.v(TAG_BROADCAST, &quot;Done with parallel broadcast [&quot;</div><div class="line">            + mQueueName + &quot;] &quot; + r);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到无序广播存储在mParallelBroadcasts中，系统会遍历该集合并发送给他们的处理者，具体的发送过程是通过deliverToRegisteredReceiverLocked方法来实现，该方法将一个广播发送给一个特定的接受者，它的内部调用了performReceiveLocked方法来完成具体的发送过程，实现如下，由于广播会调起应用程序，因此app.thread不为空app.thread指ApplicationThread。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">private static void performReceiveLocked(ProcessRecord app, IIntentReceiver receiver,</div><div class="line">        Intent intent, int resultCode, String data, Bundle extras,</div><div class="line">        boolean ordered, boolean sticky, int sendingUser) throws RemoteException &#123;</div><div class="line">    // Send the intent to the receiver asynchronously using one-way binder calls.</div><div class="line">    if (app != null) &#123;</div><div class="line">        if (app.thread != null) &#123;</div><div class="line">            // If we have an app thread, do the call through that so it is</div><div class="line">            // correctly ordered with other one-way calls.</div><div class="line">            app.thread.scheduleRegisteredReceiver(receiver, intent, resultCode,</div><div class="line">                    data, extras, ordered, sticky, sendingUser, app.repProcState);</div><div class="line">        &#125; else &#123;</div><div class="line">            // Application has died. Receiver doesn&apos;t exist.</div><div class="line">            throw new RemoteException(&quot;app.thread must not be null&quot;);</div><div class="line">        &#125;</div><div class="line">    &#125; else &#123;</div><div class="line">        receiver.performReceive(intent, resultCode, data, extras, ordered,</div><div class="line">                sticky, sendingUser);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该方法会调用ApplicationThread的scheduleRegisteredReceiver，他的实现比较简单，通过InnerReceiver来实现广播的接受。InnerReceiver的performRecerver方法会调用LoadedApk.ReceiverDispatcher的performReceive方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">    public void performReceive(Intent intent, int resultCode, String data,</div><div class="line">            Bundle extras, boolean ordered, boolean sticky, int sendingUser) &#123;</div><div class="line">        Args args = new Args(intent, resultCode, data, extras, ordered,</div><div class="line">                sticky, sendingUser);</div><div class="line">        if (!mActivityThread.post(args)) &#123;</div><div class="line">            if (mRegistered &amp;&amp; ordered) &#123;</div><div class="line">                IActivityManager mgr = ActivityManagerNative.getDefault();</div><div class="line">                if (ActivityThread.DEBUG_BROADCAST) Slog.i(ActivityThread.TAG,</div><div class="line">                        &quot;Finishing sync broadcast to &quot; + mReceiver);</div><div class="line">                args.sendFinished(mgr);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在上面代码中会创建一个Args对象并通过mActivityThread的post方法来执行args中的逻辑，而args实现了Runnable接口。mActivityThread是一个Handler，它其实就是ActivityThread中的mH，mH的类型是ActivityThread的内部类H。在args的run方法中有如下几行代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">final BroadcastReceiver receiver = mReceiver;</div><div class="line">receiver.setPendingResult(this);</div><div class="line">receiver.onReceive(mContext, intent);</div></pre></td></tr></table></figure>
<p>很显然这个时候BroadcastReceiver的onReceiver方法被执行了，也就是说应用已经接收到广播。</p>
<p>到这里这个广播的注册，发送和接受过程已经分析完了，读者应该对广播的整个过程有了一定的理解。</p>
<hr>
<p>未经许可不得转载，转载请注明zilianliuxue的blog,本人保留所有版权。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文将介绍BroadcastReceiver的工作过程,主要包含两个方面的内容，一个是广播的注册过程，一个是广播的发送和接受过程。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;广播的注册过程&quot;&gt;&lt;a href=&quot;#广播的注册过程&quot; clas
    
    </summary>
    
      <category term="android" scheme="http://zilianliuxue.github.io/categories/android/"/>
    
    
      <category term="BroadcastReceiver" scheme="http://zilianliuxue.github.io/tags/BroadcastReceiver/"/>
    
  </entry>
  
</feed>
